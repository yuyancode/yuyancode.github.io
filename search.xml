<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java知识点总结</title>
    <url>/2021/10/23/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1.单行注释"></a>1.单行注释</h3><p>格式：//注释信息</p>
<h3 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2.多行注释"></a>2.多行注释</h3><p>格式：/*  注释信息  */</p>
<h3 id="3-文档注释"><a href="#3-文档注释" class="headerlink" title="3.文档注释"></a>3.文档注释</h3><p>格式：/**    注释信息  */</p>
<span id="more"></span>

<hr>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="1-关键字描述"><a href="#1-关键字描述" class="headerlink" title="1.关键字描述"></a>1.关键字描述</h3><p>关键字：就是被java语言赋予了特定含义的单词</p>
<h3 id="2-关键字的特点"><a href="#2-关键字的特点" class="headerlink" title="2.关键字的特点"></a>2.关键字的特点</h3><p>2.1关键字全部小写</p>
<p>2.2常用的代码编辑器，针对关键字有特殊的颜色标记，非常直观</p>
<hr>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="1-常量概述"><a href="#1-常量概述" class="headerlink" title="1.常量概述"></a>1.常量概述</h3><p>在程序运行过程中，其值不能发生改变的量。</p>
<h3 id="2-常量分类"><a href="#2-常量分类" class="headerlink" title="2.常量分类"></a>2.常量分类</h3><p>字符串常量 ：用双引号括起来的内容</p>
<p>整数常量：不带小数点的数字</p>
<p>小数常量：带小数的数字</p>
<p>字符常量：用单引号括起来的内容</p>
<p>布尔常量：布尔值，表示真假，true，false</p>
<p>空常量：一个特殊的值，空值null</p>
<hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型包括基本数据类型和引用数据类型。基本数据类型包含数值型{整数（byte,short,int,long）,浮点数（float，double），字符（char）}和非数值型{布尔（boolean）}。引用数据类型包括类（class），接口（interface），数组（[]）。</p>
<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="1-变量概述"><a href="#1-变量概述" class="headerlink" title="1.变量概述"></a>1.变量概述</h3><p>变量是指在程序运行过程中，其值可以发生改变的量。</p>
<h3 id="2-变量定义"><a href="#2-变量定义" class="headerlink" title="2.变量定义"></a>2.变量定义</h3><p>格式：数据类型 变量名 =变量值；</p>
<h3 id="3-变量的使用"><a href="#3-变量的使用" class="headerlink" title="3.变量的使用"></a>3.变量的使用</h3><p>取值和修改</p>
<h3 id="4-变量使用的注意事项"><a href="#4-变量使用的注意事项" class="headerlink" title="4.变量使用的注意事项"></a>4.变量使用的注意事项</h3><p>变量名不能重复</p>
<p>变量为赋值不能使用</p>
<p>long类型的变量定义时，为了防止整数过大，后面要加L</p>
<p>float类型的变量定义时，为了防止类型不兼容，后面要加F</p>
<hr>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><h3 id="1-标识符概述"><a href="#1-标识符概述" class="headerlink" title="1.标识符概述"></a>1.标识符概述</h3><p>标识符就是给类，方法，变量等起名字的符号。</p>
<h3 id="2-标识符的定义规则"><a href="#2-标识符的定义规则" class="headerlink" title="2.标识符的定义规则"></a>2.标识符的定义规则</h3><p>标识符由数字，字母，下划线___,美元$组成</p>
<p>不能由数字开头，不能是关键字，区分大小写</p>
<h3 id="3-常见命名约定"><a href="#3-常见命名约定" class="headerlink" title="3.常见命名约定"></a>3.常见命名约定</h3><p>小驼峰命名法：<br>1.标识符是一个单词时，首字母小写</p>
<p>2.标识符有多个单词组成时，第一个字母单词首字母小写，其他单词字母大写</p>
<p>大驼峰命名法：</p>
<p>1.标识符是一个单词时，首字母大写</p>
<p>2.标识符由多个单词组成时，每个单词首字母大写</p>
<hr>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="1-自动类型转换"><a href="#1-自动类型转换" class="headerlink" title="1.自动类型转换"></a>1.自动类型转换</h3><p>把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量</p>
<p>​                                             数据范围由小到大</p>
<p>byte -&gt; short -&gt;int -&gt;long -&gt;float -&gt;double</p>
<p>char-&gt;(指向short)</p>
<h3 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="2.强制类型转换"></a>2.强制类型转换</h3><p>把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量</p>
<p> 格式：目标数据类型 变量名=（目标数据类型） 值或变量</p>
<p>范例：int k=（int）88.88；</p>
<hr>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验——树和图</title>
    <url>/2021/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E6%A0%91%E5%92%8C%E5%9B%BE/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="问题-A-图的遍历"><a href="#问题-A-图的遍历" class="headerlink" title="问题 A: 图的遍历"></a>问题 A: 图的遍历</h1><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>深度优先搜索遍历类似于树的先根遍历，是树的先根遍历的推广。其过程为：假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可以从图中的某个顶点v出发，访问此顶点，然后依次从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止。<span id="more"></span><br>其算法可以描述如下：</p>
<p>在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法遍历所有顶点，输出遍历顶点的顺序。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。<br>以后的n行中每行有n个用空格隔开的整数0或1，对于第i行的第j个0或1，1表示第i个顶点和第j个顶点有直接连接，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。<br>输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>只有一行，包含n个整数，表示按照题目描述中的深度优先遍历算法遍历整个图的访问顶点顺序。每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 0 1</span><br><span class="line">1 0 0 0</span><br><span class="line">0 0 0 1</span><br><span class="line">1 0 1 0</span><br></pre></td></tr></table></figure>



<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 3 2 </span><br></pre></td></tr></table></figure>



<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要熟练掌握图的邻接矩阵存储方式。在建立完成无向图之后，需要严格按照题目描述的遍历顺序对图进行遍历。另外，算法中描述的FirstAdjVex函数和NextAdjVex函数，需要认真的自行探索并完成。<br>通过这道题目，应该能够对图的深度优先搜索建立更加直观和清晰的概念。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.首先要学会利用邻接矩阵构造图，第二学会深度优先遍历对图进行搜索，每访问完一个节点就给该节点做标记，并且按题目要求输出结点序号。</p>
<p>2.此题中的深度优先遍历算法只能访问到连通图的每一个结点，对于非联通图如果要访问每一个极大连通分量，就要添加一个循环，判断是否每个有边存在的结点都被访问过。</p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">55</span>; <span class="comment">//图中最多顶点个数</span></span><br><span class="line"><span class="keyword">int</span> visited[MaxSize] = &#123;<span class="number">0</span>&#125;; <span class="comment">//全局数组变量visited初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MGraph</span>(<span class="keyword">int</span> n); <span class="comment">//构造函数，建立具有n个顶点e条边的图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFTraverse</span><span class="params">(<span class="keyword">int</span> v)</span></span>; <span class="comment">//深度优先遍历图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> edge[MaxSize][MaxSize]; <span class="comment">//存放图中边的数组</span></span><br><span class="line"><span class="keyword">int</span> vertexNum; <span class="comment">//图的顶点数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MGraph::<span class="built_in">MGraph</span>(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">vertexNum=n; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">cin&gt;&gt;edge[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::DFTraverse</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;v&lt;&lt;<span class="string">&#x27; &#x27;</span>; </span><br><span class="line">visited[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexNum; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (edge[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) <span class="built_in">DFTraverse</span>( j );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="function">MGraph <span class="title">MG</span><span class="params">(n)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">MG.<span class="built_in">DFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="问题B"><a href="#问题B" class="headerlink" title="问题B:"></a>问题B:</h1><h1 id="算法7-7-7-8：无向图的连通分量和生成树"><a href="#算法7-7-7-8：无向图的连通分量和生成树" class="headerlink" title="算法7-7,7-8：无向图的连通分量和生成树"></a>算法7-7,7-8：无向图的连通分量和生成树</h1><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先搜索或广度优先搜索，便可访问到图中所有顶点。对于非连通图，则需从多个顶点出发进行搜索，而每一次从一个新的起始点出发进行搜索的过程中得到的顶点访问序列恰为其各个连通分量中的顶点集。</p>
<p>对于非连通图，每个连通分量中的顶点集，和遍历时走过的边一起构成若干棵生成树，这些连通分量的生成树组成非连通图的生成森林。</p>
<p>假设以孩子兄弟链表作为生成森林的存储结构，则生成非连通图的深度优先生成森林的算法可以描述如下</p>
<p> 而建立以p为根的深度优先生成树的算法可以描述如下</p>
<p>在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立无向图的生成森林。对于森林中的每一棵生成树，遍历所有顶点，并输出遍历顶点的顺序。</p>
<h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。</p>
<p>以后的n行中每行有n个用空格隔开的整数0或1，对于第i行的第j个0或1，1表示第i个顶点和第j个顶点有直接连接，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。</p>
<p>输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图。</p>
<h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>每一行输出无向图中的一棵生成树，表示按照题目描述中的深度优先遍历算法遍历相应的连通分量的访问顶点顺序。每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">0 0 1 1 0 0</span><br><span class="line">0 1 0 1 0 0</span><br><span class="line">1 1 1 0 0 0</span><br><span class="line">0 0 0 0 0 1</span><br><span class="line">0 0 0 0 1 0</span><br></pre></td></tr></table></figure>



<h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 3 1 2 </span><br><span class="line">4 5 </span><br></pre></td></tr></table></figure>



<h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要掌握图的深度优先遍历的方法，并需要掌握无向图的连通性问题的本质。通过求出无向图的连通分量和对应的生成树，应该能够对图的连通性建立更加直观和清晰的概念。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1.这一题和上一题大同小异都是要去利用邻接矩阵来建立图。但这题要对深度优先遍历进行优化，使其能够对每一个极大连通分量遍历输出，这个深度优先遍历方法要学会。</p>
<p>2.添加了去领接顶点和某顶点后的下一个邻接顶点的函数（关键部分仔细研究）</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">55</span>; <span class="comment">//图中最多顶点个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MGraph</span>(<span class="keyword">int</span> n); <span class="comment">//构造函数，建立具有n个顶点e条边的图</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSC</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> *visited)</span></span>;</span><br><span class="line"><span class="keyword">int</span> visited[MaxSize] ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> edge[MaxSize][MaxSize]; <span class="comment">//存放图中边的数组</span></span><br><span class="line"><span class="keyword">int</span> vertexNum; <span class="comment">//图的顶点数</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MGraph::getFirst</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//取第一个邻接顶点</span></span><br><span class="line">	<span class="keyword">if</span>(v!=<span class="number">-1</span>)&#123;<span class="comment">//当顶点存在时</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vertexNum;j++)&#123;<span class="comment">//从第v行开始，第一个不为0或无穷大的边就是第一个邻接顶点</span></span><br><span class="line">			<span class="keyword">if</span>(edge[v][j]&gt;<span class="number">0</span>&amp;&amp;edge[v][j]&lt;MaxSize)<span class="comment">/*这里就是邻接矩阵的好处，直接在第v行找和v相连的顶点就行*/</span></span><br><span class="line">		&#123;</span><br><span class="line">				edge[v][j]=<span class="number">0</span>;<span class="comment">//无向邻接矩阵在找到对应邻接顶点后要把这两条边都做上标记</span></span><br><span class="line">				edge[j][v]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> j;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MGraph::getNext</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;<span class="comment">//取第v个节点的w顶点后的邻接顶点</span></span><br><span class="line">	<span class="keyword">if</span>(v!=<span class="number">-1</span>&amp;&amp;w!=<span class="number">-1</span>)&#123;<span class="comment">//当v和w结点均存在</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=w+<span class="number">1</span>;j&lt;vertexNum;j++)&#123;<span class="comment">//循环从w+1开始</span></span><br><span class="line">			<span class="keyword">if</span>(edge[v][j]&gt;<span class="number">0</span>&amp;&amp;edge[v][j]&lt;MaxSize)</span><br><span class="line">			&#123;</span><br><span class="line">				edge[v][j]=<span class="number">0</span>;<span class="comment">//双向边都要做上标记</span></span><br><span class="line">				edge[j][v]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> j;<span class="comment">//返回顶点序号</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MGraph::<span class="built_in">MGraph</span>(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">vertexNum=n; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">cin&gt;&gt;edge[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::DFSC</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span>  *visited)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;v&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	visited[v]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> w=G.<span class="built_in">getFirst</span>(v);</span><br><span class="line">	<span class="keyword">while</span>(w!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visited[w]==<span class="number">0</span>) <span class="built_in">DFSC</span>(G,w,visited);</span><br><span class="line">		w=G.<span class="built_in">getNext</span>(v,w);</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::DFS</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	visited[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vertexNum;v++)</span><br><span class="line"><span class="keyword">if</span> (!visited[v]) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DFSC</span>(G,v,visited);</span><br><span class="line">	cout&lt;&lt;endl;<span class="comment">//这里补上一个换行，对于不通的连通分量中的点换行输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="function">MGraph <span class="title">MG</span><span class="params">(n)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">MG.visited[i] = <span class="number">0</span>;</span><br><span class="line">MG.<span class="built_in">DFS</span>(MG,<span class="number">0</span>,n); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="问题-C-算法9-2：有序表的折半查找"><a href="#问题-C-算法9-2：有序表的折半查找" class="headerlink" title="问题 C: 算法9-2：有序表的折半查找"></a>问题 C: 算法9-2：有序表的折半查找</h1><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>用有序表表示静态查找表时，通常检索函数可以用折半查找来实现。</p>
<p>折半查找的查找过程是：首先确定待查记录所在的范围，然后逐步缩小范围直到找到或者确定找不到相应的记录为止。而每次需要缩小的范围均为上一次的一半，这样的查找过程可以被称为折半查找。</p>
<p>其查找过程可以描述如下：</p>
<p>在本题中，读入一串有序的整数，另外给定多次查询，判断每一次查询是否找到了相应的整数，如果找到则输出整数相应的位置。</p>
<h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含2个正整数n和k，分别表示共有n个整数和k次查询。其中n不超过1000，k同样不超过1000。</p>
<p>第二行包含n个用空格隔开的正整数，表示n个有序的整数。输入保证这n个整数是从小到大递增的。</p>
<p>第三行包含k个用空格隔开的正整数，表示k次查询的目标。</p>
<h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>只有1行，包含k个整数，分别表示每一次的查询结果。如果在查询中找到了对应的整数，则输出其相应的位置，否则输出-1。</p>
<p>请在每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 5 7 8 9 10 15</span><br><span class="line">9 2 5</span><br></pre></td></tr></table></figure>



<h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 -1 2 </span><br></pre></td></tr></table></figure>



<h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要按照题目描述中的算法完成折半查找过程。通过将需要查询的值与当前区间中央的整数进行比较，不断缩小区间的范围，直到确定被查询的值是否存在。</p>
<p>通过课本中的性能分析部分，不难发现折半查找的时间复杂度为O(log2n)，这是一种非常高效的查找方法。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这题只有25%的通过率，坑就在oj中对于相等的数值查找要输出以一个找到的位置。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> obj,<span class="keyword">int</span> num,<span class="keyword">int</span> *List)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low=<span class="number">0</span>,high=num<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> mid=num/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">		mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(obj&gt;List[mid]) low=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (obj&lt;List[mid]) high=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (obj==List[mid]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(List[mid<span class="number">-1</span>]==obj)&#123;<span class="comment">//仔细思考，找第一个符合条件的值 </span></span><br><span class="line">				high=mid;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,sum,obj;</span><br><span class="line">	cin&gt;&gt;num&gt;&gt;sum;</span><br><span class="line">	<span class="keyword">int</span> List[num];<span class="comment">//表中数字已经由小到大拍排好序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">			cin&gt;&gt;List[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum;i++)&#123;</span><br><span class="line">		cin&gt;&gt;obj;        </span><br><span class="line">		cout&lt;&lt;<span class="built_in">Search</span>(obj,num,List)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//传统的二分查找法，oj上要注意多个同样的值要找第一次出现的时候</span></span><br></pre></td></tr></table></figure>

<h1 id="问题-D-算法9-5-9-8：二叉排序树的基本操作"><a href="#问题-D-算法9-5-9-8：二叉排序树的基本操作" class="headerlink" title="问题 D: 算法9-5~9-8：二叉排序树的基本操作"></a>问题 D: 算法9-5~9-8：二叉排序树的基本操作</h1><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>二叉排序树或者是一棵空树，或者是具有以下几条性质的二叉树：</p>
<ol>
<li><pre><code>  若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；
</code></pre>
</li>
<li><pre><code>  若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值；
</code></pre>
</li>
<li><pre><code>  它的左右子树也分别为二叉排序树。
</code></pre>
</li>
</ol>
<p>二叉排序树又可以被称为二叉查找树，根据上述定义的结构不难知道，它的查找过程十分简单，只需要通过不断的将当前结点的值与需要查找的值进行比较，如果相等则直接输出，如果要查找的值更小则深入至左子树进行比较，否则就深入右子树进行比较，直到找到相应的值或者进入了一棵不存在的子树为止。</p>
<p>其查找过程可以描述如下：</p>
<p>而其插入过程同样也十分简洁，可以描述如下</p>
<p>而删除操作可以描述为如下的两个算法</p>
<p>在本题中，读入一串整数，首先利用这些整数构造一棵二叉排序树。另外给定多次查询，利用构造出的二叉排序树，判断每一次查询是否成功。</p>
<h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含2个正整数n和k，分别表示共有n个整数和k次查询。其中n不超过500，k同样不超过500。</p>
<p>第二行包含n个用空格隔开的正整数，表示n个整数。</p>
<p>第三行包含k个用空格隔开的正整数，表示k次查询的目标。</p>
<h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>只有1行，包含k个整数，分别表示每一次的查询结果。如果在查询中找到了对应的整数，则输出1，否则输出0。</p>
<p>请在每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 5 7 8 9 10 15</span><br><span class="line">9 2 5</span><br></pre></td></tr></table></figure>



<h4 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 1 </span><br></pre></td></tr></table></figure>



<h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><p>在本题中，首先需要按照题目描述中的算法完成二叉排序树的构造过程，之后需要通过在二叉排序树中的不断向下查找，将需要查询的值与当前节点的值进行比较，直到确定被查询的值是否存在。</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>1.学会构造二排序（搜索）树，利用二叉排序树左子树结点&lt;根&lt;右子树结点的特性进行搜索，本质上就是一种折半查找。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">	E data;</span><br><span class="line">	BSTNode&lt;E,K&gt; *left,*right;</span><br><span class="line">	<span class="built_in">BSTNode</span>():<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">BSTNode</span>(<span class="keyword">const</span> E d,BSTNode&lt;E,K&gt; *L=<span class="literal">NULL</span>,BSTNode&lt;E,K&gt; *R=<span class="literal">NULL</span>):<span class="built_in">data</span>(d),<span class="built_in">left</span>(L),<span class="built_in">right</span>(R)&#123;&#125;</span><br><span class="line">	~<span class="built_in">BSTNode</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(E d)</span></span>&#123;data=d;&#125;</span><br><span class="line">	<span class="function">E <span class="title">getData</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> data;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">BST</span>():<span class="built_in">root</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">		<span class="built_in">BST</span>(K value);</span><br><span class="line">		~<span class="built_in">BST</span>()&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		BSTNode&lt;E,K&gt; *root;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		</span><br><span class="line">		K RefValue; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Search</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *ptr)&#123;<span class="comment">//搜索函数，类似于折半查找</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Insert</span>(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//核心，插入函数</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		ptr=<span class="keyword">new</span> BSTNode&lt;E,K&gt;(el);</span><br><span class="line">		<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&lt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&gt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line">BST&lt;E,K&gt;::<span class="built_in">BST</span>(K value)&#123;<span class="comment">//构造函数，利用插入函数进行</span></span><br><span class="line">	E x;root=<span class="literal">NULL</span>;RefValue=value;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="keyword">while</span>(x.key!=RefValue)&#123;</span><br><span class="line">		<span class="built_in">Insert</span>(x,root);cin&gt;&gt;x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Remove</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//删除结点</span></span><br><span class="line">	BSTNode&lt;E,K&gt; *temp;</span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">if</span>(x&lt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;right);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ptr-&gt;left!=<span class="literal">NULL</span>&amp;&amp;ptr-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			temp=ptr-&gt;right;</span><br><span class="line">			<span class="keyword">while</span>(temp-&gt;left!=<span class="literal">NULL</span>) temp=temp-&gt;left;</span><br><span class="line">			ptr-&gt;data=temp-&gt;data;</span><br><span class="line">			<span class="built_in">Remove</span>(ptr-&gt;data,ptr-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				temp=ptr;</span><br><span class="line">				<span class="keyword">if</span>(ptr-&gt;left==<span class="literal">NULL</span>) ptr=ptr-&gt;right;</span><br><span class="line">				<span class="keyword">else</span> ptr=ptr-&gt;left;</span><br><span class="line">				<span class="keyword">delete</span> temp; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k,j,q;</span><br><span class="line">	BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Tree;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;j;</span><br><span class="line">		Tree.<span class="built_in">Insert</span>(j,Tree.root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">		cin&gt;&gt;q;</span><br><span class="line">	cout&lt;&lt;Tree.<span class="built_in">Search</span>(q,Tree.root)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;Tree.root-&gt;data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="问题-E-二叉排序树"><a href="#问题-E-二叉排序树" class="headerlink" title="问题 E: 二叉排序树"></a>问题 E: 二叉排序树</h1><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一系列整数，建立二叉排序树，并进行前序，中序，后序遍历。</p>
<h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>输入第一行包括一个整数n(1&lt;=n&lt;=100)。接下来的一行包括n个整数。</p>
<h4 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h4><p>可能有多组测试数据，对于每组数据，将题目所给数据建立一个二叉排序树，并对二叉排序树进行前序、中序和后序遍历。每种遍历结果输出一行。每行最后一个数据之后有一个空格。</p>
<h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2 </span><br><span class="line">2</span><br><span class="line">8 15 </span><br><span class="line">4</span><br><span class="line">21 10 5 39 </span><br></pre></td></tr></table></figure>



<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 </span><br><span class="line">2 </span><br><span class="line">2 </span><br><span class="line">8 15 </span><br><span class="line">8 15 </span><br><span class="line">15 8 </span><br><span class="line">21 10 5 39 </span><br><span class="line">5 10 21 39 </span><br><span class="line">5 10 39 21 </span><br></pre></td></tr></table></figure>



<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>二叉排序树构建好了，添加前中后序遍历就行。每处理完一组数据后都要把树清空。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">	E data;</span><br><span class="line">	BSTNode&lt;E,K&gt; *left,*right;</span><br><span class="line">	<span class="built_in">BSTNode</span>():<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">BSTNode</span>(<span class="keyword">const</span> E d,BSTNode&lt;E,K&gt; *L=<span class="literal">NULL</span>,BSTNode&lt;E,K&gt; *R=<span class="literal">NULL</span>):<span class="built_in">data</span>(d),<span class="built_in">left</span>(L),<span class="built_in">right</span>(R)&#123;&#125;</span><br><span class="line">	~<span class="built_in">BSTNode</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(E d)</span></span>&#123;data=d;&#125;</span><br><span class="line">	<span class="function">E <span class="title">getData</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> data;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">BST</span>():<span class="built_in">root</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">		<span class="built_in">BST</span>(K value);</span><br><span class="line">		~<span class="built_in">BST</span>()&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Pre</span><span class="params">(BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">In</span><span class="params">(BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Post</span><span class="params">(BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		BSTNode&lt;E,K&gt; *root;<span class="comment">//偷个懒，正常要写个返回根节点的函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		</span><br><span class="line">		K RefValue; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BST&lt;E,K&gt;::<span class="built_in">MakeEmpty</span>()<span class="comment">//把树清空</span></span><br><span class="line">&#123;</span><br><span class="line">	root=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Pre</span>(BSTNode&lt;E,K&gt; *ptr)&#123;<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		cout&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">Pre</span>(ptr-&gt;left);</span><br><span class="line">		<span class="built_in">Pre</span>(ptr-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">In</span>(BSTNode&lt;E,K&gt; *ptr)&#123;<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">In</span>(ptr-&gt;left);</span><br><span class="line">		cout&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">In</span>(ptr-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Post</span>(BSTNode&lt;E,K&gt; *ptr)&#123;<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">Post</span>(ptr-&gt;left);</span><br><span class="line">		<span class="built_in">Post</span>(ptr-&gt;right);</span><br><span class="line">		cout&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Search</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *ptr)&#123;<span class="comment">//搜索</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Insert</span>(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//插入</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		ptr=<span class="keyword">new</span> BSTNode&lt;E,K&gt;(el);</span><br><span class="line">		<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&lt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&gt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line">BST&lt;E,K&gt;::<span class="built_in">BST</span>(K value)&#123;<span class="comment">//构造函数</span></span><br><span class="line">	E x;root=<span class="literal">NULL</span>;RefValue=value;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="keyword">while</span>(x.key!=RefValue)&#123;</span><br><span class="line">		<span class="built_in">Insert</span>(x,root);cin&gt;&gt;x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Remove</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//删除函数</span></span><br><span class="line">	BSTNode&lt;E,K&gt; *temp;</span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">if</span>(x&lt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;right);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ptr-&gt;left!=<span class="literal">NULL</span>&amp;&amp;ptr-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			temp=ptr-&gt;right;</span><br><span class="line">			<span class="keyword">while</span>(temp-&gt;left!=<span class="literal">NULL</span>) temp=temp-&gt;left;</span><br><span class="line">			ptr-&gt;data=temp-&gt;data;</span><br><span class="line">			<span class="built_in">Remove</span>(ptr-&gt;data,ptr-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				temp=ptr;</span><br><span class="line">				<span class="keyword">if</span>(ptr-&gt;left==<span class="literal">NULL</span>) ptr=ptr-&gt;right;</span><br><span class="line">				<span class="keyword">else</span> ptr=ptr-&gt;left;</span><br><span class="line">				<span class="keyword">delete</span> temp; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,temp;</span><br><span class="line">BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Tree;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		Tree.<span class="built_in">Insert</span>(temp,Tree.root);</span><br><span class="line">	&#125;</span><br><span class="line">	Tree.<span class="built_in">Pre</span>(Tree.root);cout&lt;&lt;endl;</span><br><span class="line">	Tree.<span class="built_in">In</span>(Tree.root);cout&lt;&lt;endl;</span><br><span class="line">	Tree.<span class="built_in">Post</span>(Tree.root);cout&lt;&lt;endl;</span><br><span class="line">	Tree.<span class="built_in">MakeEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="问题-F-算法6-12：自底向上的赫夫曼编码"><a href="#问题-F-算法6-12：自底向上的赫夫曼编码" class="headerlink" title="问题 F: 算法6-12：自底向上的赫夫曼编码"></a>问题 F: 算法6-12：自底向上的赫夫曼编码</h1><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>在通讯领域，经常需要将需要传送的文字转换成由二进制字符组成的字符串。在实际应用中，由于总是希望被传送的内容总长尽可能的短，如果对每个字符设计长度不等的编码，且让内容中出现次数较多的字符采用尽可能短的编码，则整个内容的总长便可以减少。另外，需要保证任何一个字符的编码都不是另一个字符的编码前缀，这种编码成为前缀编码。</p>
<p>而赫夫曼编码就是一种二进制前缀编码，其从叶子到根（自底向上）逆向求出每个字符的算法可以表示如下：</p>
<p><img src="http://192.168.173.163/JudgeOnline/upload/pimg1344_1.png" alt="img"></p>
<p>在本题中，读入n个字符所对应的权值，生成赫夫曼编码，并依次输出计算出的每一个赫夫曼编码。</p>
<h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含一个正整数n，表示共有n个字符需要编码。其中n不超过100。</p>
<p>第二行中有n个用空格隔开的正整数，分别表示n个字符的权值。</p>
<h4 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h4><p>共n行，每行一个字符串，表示对应字符的赫夫曼编码。</p>
<h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">5 29 7 8 14 23 3 11</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0110</span><br><span class="line">10</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">110</span><br><span class="line">00</span><br><span class="line">0111</span><br><span class="line">010</span><br></pre></td></tr></table></figure>

<h4 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h4><p>赫夫曼树又名最优二叉树，它是一类带权路径长度最小的二叉树。通过构造赫夫曼树，我们可以得到赫夫曼编码，从而使得通信能够得到更高的效率。在本题中，构造赫夫曼树的过程使用了从叶子到根的逆向顺序，另外，还有一种从根出发直到叶子的赫夫曼编码构造算法，这将在下一题中进行讨论。</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>cv战士只想看懂大佬们的解法</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span><span class="comment">//最小堆要用的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> w[MaxN];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;<span class="comment">//权值</span></span><br><span class="line">    <span class="keyword">int</span> parent, lchild, rchild;</span><br><span class="line">&#125;HuffmanNode, *HuffmanTree;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *HuffmanCode;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seletTMin</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n, <span class="keyword">int</span> &amp;m1, <span class="keyword">int</span> &amp;m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = INT32_MAX;<span class="comment">//int32_t.max=2147483647</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; min &gt; HT[i].weight)</span><br><span class="line">        &#123;</span><br><span class="line">            min = HT[i].weight;</span><br><span class="line">            m1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    min = INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; min &gt; HT[i].weight &amp;&amp; i != m1)</span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            min = HT[i].weight;</span><br><span class="line">            m2 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (m1 &gt; m2)</span><br><span class="line">        <span class="built_in">swap</span>(m1, m2); <span class="comment">//交换，这一段必不可少，不然构造出来的编码是不唯一的</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree &amp;HT, HuffmanCode *&amp;HC,<span class="keyword">int</span> w[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    HT = <span class="keyword">new</span> HuffmanNode[m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        HT[i].weight = w[i];</span><br><span class="line">        HT[i].lchild = HT[i].rchild = HT[i].parent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        HT[i].lchild = HT[i].rchild = HT[i].parent = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m1, m2;</span><br><span class="line">        <span class="built_in">seletTMin</span>(HT, i - <span class="number">1</span>, m1, m2);</span><br><span class="line">        HT[i].lchild = m1;</span><br><span class="line">        HT[i].rchild = m2;</span><br><span class="line">        HT[m1].parent = HT[m2].parent = i;</span><br><span class="line">        HT[i].weight = HT[m1].weight + HT[m2].weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    HC = <span class="keyword">new</span> HuffmanCode[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> * cd = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = i, f = HT[i].parent; f != <span class="number">0</span>; c = f, f = HT[f].parent)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c)</span><br><span class="line">                cd[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        HC[i] = <span class="keyword">new</span> <span class="keyword">char</span>[n - start];</span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], cd + start);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> cd;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"> </span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">    HuffmanTree HT;</span><br><span class="line">    HuffmanCode *HC;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> data[MaxN];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            cin &gt;&gt; data[i];</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">HuffmanCoding</span>(HT, HC, data, n);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            cout &lt;&lt;  HC[i] &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">delete</span> HC;</span><br><span class="line">        <span class="keyword">delete</span> HT;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h1 id="问题-E-算法7-15：迪杰斯特拉最短路径算法"><a href="#问题-E-算法7-15：迪杰斯特拉最短路径算法" class="headerlink" title="问题 E: 算法7-15：迪杰斯特拉最短路径算法"></a>问题 E: 算法7-15：迪杰斯特拉最短路径算法</h1><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>在带权有向图G中，给定一个源点v，求从v到G中的其余各顶点的最短路径问题，叫做单源点的最短路径问题。</p>
<p>在常用的单源点最短路径算法中，迪杰斯特拉算法是最为常用的一种，是一种按照路径长度递增的次序产生最短路径的算法。</p>
<p>可将迪杰斯特拉算法描述如下：</p>
<p><img src="http://192.168.173.163/JudgeOnline/upload/pimg1352_1.png" alt="img"></p>
<p>在本题中，读入一个有向图的带权邻接矩阵（即数组表示），建立有向图并按照以上描述中的算法求出源点至每一个其它顶点的最短路径长度。</p>
<h4 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含2个正整数n和s，表示图中共有n个顶点，且源点为s。其中n不超过50，s小于n。</p>
<p>以后的n行中每行有n个用空格隔开的整数。对于第i行的第j个整数，如果大于0，则表示第i个顶点有指向第j个顶点的有向边，且权值为对应的整数值；如果这个整数为0，则表示没有i指向j的有向边。当i和j相等的时候，保证对应的整数为0。</p>
<h4 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h4><p>只有一行，共有n-1个整数，表示源点至其它每一个顶点的最短路径长度。如果不存在从源点至相应顶点的路径，输出-1。</p>
<p>请注意行尾输出换行。</p>
<h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">0 3 0 1</span><br><span class="line">0 0 4 0</span><br><span class="line">2 0 0 0</span><br><span class="line">0 0 1 0</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4 7 </span><br></pre></td></tr></table></figure>

<h4 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要按照题目描述中的算法完成迪杰斯特拉算法，并在计算最短路径的过程中将每个顶点是否可达记录下来，直到求出每个可达顶点的最短路径之后，算法才能够结束。</p>
<p>迪杰斯特拉算法的特点是按照路径长度递增的顺序，依次添加下一条长度最短的边，从而不断构造出相应顶点的最短路径。</p>
<p>另外需要注意的是，在本题中为了更方便的表示顶点间的不可达状态，可以使用一个十分大的值作为标记。</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>cv战士不做挣扎</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3fffffff</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = inf;<span class="comment">//距离为最大 </span></span><br><span class="line">        vis[i] = <span class="number">0</span>; <span class="comment">//未访问过 </span></span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span> &amp;&amp; dis[j] &lt; min)<span class="comment">//找到未访问中最小的点 </span></span><br><span class="line">            &#123;</span><br><span class="line">                k = j;</span><br><span class="line">                min = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = <span class="number">1</span>;<span class="comment">//加入访问后的集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;dis[k]+a[k][j] &lt; dis[j])<span class="comment">//没访问过 </span></span><br><span class="line">                dis[j] = dis[k] + a[k][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=s &amp;&amp; dis[i]!=inf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=s &amp;&amp; dis[i] == inf)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;s)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</span><br><span class="line">                    a[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        dijstra(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验——栈和队列</title>
    <url>/2021/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="数据结构第二次实验课——栈和队列"><a href="#数据结构第二次实验课——栈和队列" class="headerlink" title="数据结构第二次实验课——栈和队列"></a>数据结构第二次实验课——栈和队列</h1><h2 id="问题-A-出栈合法性"><a href="#问题-A-出栈合法性" class="headerlink" title="问题 A: 出栈合法性"></a>问题 A: 出栈合法性</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>已知自然数1，2，…，N（1&lt;=N&lt;=100）依次入栈，请问序列C1，C2，…，CN是否为合法的出栈序列。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入包含多组测试数据。<br>每组测试数据的第一行为整数N（1&lt;=N&lt;=100），当N=0时，输入结束。<br>第二行为N个正整数，以空格隔开，为出栈序列。</p>
<span id="more"></span>

<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对于每组输入，输出结果为一行字符串。<br>如给出的序列是合法的出栈序列，则输出Yes，否则输出No。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 1 5</span><br><span class="line">5</span><br><span class="line">3 5 1 4 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>无</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.分析此题可以看出本题要求在入栈情况一定时判断所给的序列是否可能存在的出栈序列。对于每组数据我们分开处理。</p>
<p>2.出栈序列可以依次存放在数组中，新建一个空栈模拟入栈出栈的情况，用current指针指向数组中下一个要出栈的元素。入栈顺序指定为1,2,3,4…..</p>
<p>3.具体思考过程如下：</p>
<p>first：将入栈的第一个数即数字1入栈，将出栈顺序的数组中的current所指的数字和栈顶元素进行比较。current初始指向数组中第一个数。</p>
<p>second:比较的结果有两种，如果两个数字不相等，则下一个数字入栈（即数字2），再次将栈顶元素和出栈顺序中current所指元素作比较；如果两个数字相等，那么栈顶元素出栈（空栈时下一个元素直接入栈），current指针后移。注意：如果两数字相等，此时要做一个循环，判断此时栈中第二个元素是否和下一个要出栈的元素相等，如果相等，继续循环比较，直到不相等或者所有数字遍历完为止。</p>
<p>third:循环结束条件是所有该入栈的数均进入过栈中进行过比较。合法的条件是栈空。</p>
<p>fourth:每处理完一组数据都要把栈清空，指针初始化。</p>
<p>思路图：</p>
<p><img src="../images/1.jpg" alt="header"></p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;              </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::Empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::GetTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> data[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	data[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,num,current=<span class="number">0</span>;       <span class="comment">//current指针指向出栈顺序中下一个将要出栈的数字</span></span><br><span class="line">	Stack A;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">int</span> Chu[n];</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;                                  <span class="comment">//遇到结束符0，就跳出循环 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">		cin&gt;&gt;num;</span><br><span class="line">		Chu[j]=num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;                                <span class="comment">//核心代码行 </span></span><br><span class="line">			A.<span class="built_in">Push</span>(i);                                   <span class="comment">//每进入一个新的循环时，把数字入栈 </span></span><br><span class="line">		<span class="keyword">while</span>(A.<span class="built_in">GetTop</span>()==Chu[current]&amp;&amp;!A.<span class="built_in">Empty</span>())&#123;     <span class="comment">//当发现栈顶元素和出栈顺序current所指一样时，让栈顶元素出栈       </span></span><br><span class="line">			A.<span class="built_in">Pop</span>();                                     <span class="comment">//注意进入while循环的条件是栈非空且栈顶元素和current所指元素相等 </span></span><br><span class="line">			current++;                                   <span class="comment">//current指针后移 </span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">Empty</span>())</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">	A.<span class="built_in">MakeEmpty</span>();              <span class="comment">//完成一组数据的处理后进行初始化，即把栈清空，指针指向第一个该出栈元素的位置 </span></span><br><span class="line">	current=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>







<h2 id="问题-B-算法3-1：八进制数"><a href="#问题-B-算法3-1：八进制数" class="headerlink" title="问题 B: 算法3-1：八进制数"></a>问题 B: 算法3-1：八进制数</h2><p>时间限制:1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>将十进制数转换为八进制，并输出。</p>
<p><img src="../images/2.jpg" alt="header"></p>
<p>图：将十进制数转换为八进制并输出</p>
<h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>输入包含若干十进制正整数。</p>
<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>输出相应的八进制数，每个占一行。</p>
<h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">19</span><br><span class="line">10020345</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">23</span><br><span class="line">46162771</span><br></pre></td></tr></table></figure>

<h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>书上有相应的算法，需要补充缺失的函数。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h4><p>1、数值转换使用到堆栈，但是用函数调用（系统的堆栈）将会更为方便。</p>
<p>2、书中的算法实际上只能处理正整数，你有更好的方法还能够处理0和负整数么？ 可以把负数转化成正数进行如上运算，最后把符号加上即可。</p>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>1.首先这道题是利用栈先进后出的特性进行数据存储，在进制转换的时候要利用好这点。</p>
<p>2.十进制转换成八进制的方法就是：除8倒去余，直到商为零。（倒取余显然就是栈先进后出的特点）。</p>
<h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;data[top];</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	data[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Stack A;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;num)&#123;</span><br><span class="line">	<span class="keyword">while</span>(num)&#123;                <span class="comment">//除8取余，入栈</span></span><br><span class="line">		A.<span class="built_in">Push</span>(num%<span class="number">8</span>);</span><br><span class="line">		num=num/<span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!A.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">		A.<span class="built_in">Pop</span>();             <span class="comment">//弹栈</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="问题-C-算法3-2：行编辑程序"><a href="#问题-C-算法3-2：行编辑程序" class="headerlink" title="问题 C: 算法3-2：行编辑程序"></a>问题 C: 算法3-2：行编辑程序</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<p>​           一个简单的行编辑程序的功能是：接收用户从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输入时，不能保证不出差错，因此，若在编辑程序中，“每接收一个字符即存入用户数据区”的做法显然不是很恰当。较好的做法是，设立一个输入缓冲区，用以接收用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正。例如，当用户发现刚刚键入的一个字符是错的时，可补进一个退格符“#”，以表示前一个字符无效；如果发现当前键入的行内错误较多或难以补救，则可以键入一个退行符“@”，以表示当前行中的字符均无效。例如假设从终端接收了这样的两行字符：<br>whil##ilr#e(s#*s)<br>  outcha@   putchar(*s=#++);<br>则实际有效的是下列两行：<br>while(s)<br>  putchar(s++);</p>
<p>   为此，可设这个输入缓冲区为一个栈结构，每当从终端接收了一个字符之后先作如下判别：如果它不是退格符也不是退行符，则将该字符压入栈顶；如果是一个退格符，则从栈顶删去一个字符；如果它是一个退行符，则将字符栈清为空栈。上述处理过程可用下面算法描述之：</p>
<p><img src="../images/3.jpg" alt="header"></p>
<p>​                                                                   图：行编辑程序算法</p>
<h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>若干行程序或者数据，每行不超过200个字符。</p>
<h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>经过行编辑程序处理过后的输出。</p>
<h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whil##ilr#e(s#*s)</span><br><span class="line">	outcha@	putchar(*s=#++);</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(*s)</span><br><span class="line">	putchar(*s++);</span><br></pre></td></tr></table></figure>

<h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><p>无</p>
<h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>1.这题上面的图片已经给出来思路了，只要注意用getchar()读取带空格的字符串即可。注意处理的单位是一行，换行符的转义字符是‘\n’,文件结束标志是EOF。</p>
<p>2.注意，每组数据处理完记得把栈清空；此外这里除了栈正常的函数之外，要加一个从栈底到栈顶输出的函数。</p>
<h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>; </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=top;i++)</span><br><span class="line">	cout&lt;&lt;data[i];</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">	data[++top]=ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	Stack A;</span><br><span class="line">	ch=<span class="built_in">getchar</span>();                              <span class="comment">//从终端接收第一个字符 </span></span><br><span class="line">	<span class="keyword">while</span>(ch!=EOF)&#123;                            <span class="comment">//EOF为全文结束符 </span></span><br><span class="line">		<span class="keyword">while</span>(ch!=EOF&amp;&amp;ch!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span>(ch)&#123;</span><br><span class="line">				<span class="keyword">case</span><span class="number">&#x27;</span>#<span class="string">&#x27;:A.Pop();break;         //当且仅当栈非空时退栈 </span></span><br><span class="line"><span class="string">				case&#x27;</span>@<span class="string">&#x27;:A.MakeEmpty();break;   //重置栈为空栈 </span></span><br><span class="line"><span class="string">				default:A.Push(ch);break;      //有效字符进栈，未考虑栈满情况 </span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			ch=getchar();                       //从终端接收下一个字符 </span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	A.Show();                               //输出 </span></span><br><span class="line"><span class="string">	cout&lt;&lt;endl;</span></span><br><span class="line"><span class="string">	A.MakeEmpty();                           //重置为空栈 </span></span><br><span class="line"><span class="string">	if(ch!=EOF)&#123;</span></span><br><span class="line"><span class="string">		ch=getchar();                         //读取下一行的第一个字符 </span></span><br><span class="line"><span class="string">	&#125;	</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	&#125;	</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>





<h2 id="问题-D-算法3-7：银行排队"><a href="#问题-D-算法3-7：银行排队" class="headerlink" title="问题 D: 算法3-7：银行排队"></a>问题 D: 算法3-7：银行排队</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们大多都有在银行排队的经历，唉，那坑爹的排队啊！现在就让我们来算算我们这些客户平均需要等多久吧。<br>每天刚开始时银行会开m个窗口来为我们total个客户办理业务，当有客户需要办理业务时，先选择可以办理业务的窗口，如果有多个窗口可以办理业务就选择空闲时间最长的窗口，如果有多个窗口空闲的时间一样长，则选择序号小的窗口办理业务。假设我们每个人来到的时间和办理业务所需要的时间（为了简化问题，采用整数表示时间）都知道了。现在请你算算我们平均需要等待多久呢？</p>
<h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>有多组测试数据，每组数据开始有两个正整数m(&lt;20)和total(&lt;200)，后面有total对整数，对应客户先后到来的时间以及办理业务所需的时间。</p>
<h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>平均等待的时间，保留两位小数。</p>
<h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 6 1 3 4 1 5 3 9 2 13 4 13 3</span><br><span class="line">3 14 0 3 2 2 2 4 5 4 7 2 11 3 12 3 12 4 12 1 13 3 15 4 19 1 22 3 23 2</span><br><span class="line">2 5 0 6 0 5 0 6 7 1 7 2</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.00</span><br><span class="line">0.29</span><br><span class="line">1.20</span><br></pre></td></tr></table></figure>

<h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><p>题目中选择办理的窗口有三个状态，实际上从序号自小到大查找可以最早办理业务的窗口就已经满足上述三个状态了。可以使用数组来模拟列表。</p>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a><strong>总结：</strong></h4><p>实际上数组既可以模拟堆栈又可以模拟队列。</p>
<h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>1.将输入的数据分组进行处理，即一组顾客按一组数据处理 。</p>
<p>2.在每一组数据数据处理中，首先把顾客数据录入，每位顾客进入银行第一件事就是寻找最优柜台（等待时间最短且序号最小）。</p>
<p>3.在找到最优柜台后对柜台的状态进行判断，如果柜台在空闲状态，顾客直接进入服务，柜台结束时间更新；如果<br>柜台处于服务状态，则计算顾客需要等待的时间，然后顾客进入服务，柜台结束时间更新。</p>
<p>4.处理完每一位顾客后输出平均时间 </p>
<h4 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> hour;</span><br><span class="line">	<span class="built_in">Node</span>():<span class="built_in">hour</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;<span class="comment">//hour为柜台的结束时间 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m=<span class="number">0</span>,total;</span><br><span class="line">  <span class="keyword">while</span>(cin&gt;&gt;m)&#123;</span><br><span class="line">  	cin&gt;&gt;total;</span><br><span class="line">  	<span class="keyword">double</span> time=<span class="number">0</span>;</span><br><span class="line">  	Node*count=<span class="keyword">new</span> Node[m];<span class="comment">//m个柜台 </span></span><br><span class="line">  	<span class="keyword">int</span> *come=<span class="keyword">new</span> <span class="keyword">int</span> [total];<span class="comment">//每个顾客到来的时间</span></span><br><span class="line">	<span class="keyword">int</span> *deal=<span class="keyword">new</span> <span class="keyword">int</span> [total];<span class="comment">//处理业务所需要的时间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">		cin&gt;&gt;come[i]&gt;&gt;deal[i];<span class="comment">//顾客信息录入 </span></span><br><span class="line">	&#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> temp=<span class="number">0</span>;<span class="comment">//用来暂存最优柜台号 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123; <span class="comment">//依次处理每一个顾客 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(count[j].hour&lt;count[temp].hour)&#123;<span class="comment">//如果被检索柜台的结束时间小于，第一个柜台的结束时间 </span></span><br><span class="line">  		temp=j;<span class="comment">//按题目要求寻找需要等待时间最短的柜台，并且按序号小者优先 </span></span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(count[temp].hour&lt;=come[i])&#123;</span><br><span class="line">  	count[temp].hour=come[i]+deal[i];<span class="comment">//如果该优先柜台结束时间早于顾客来的时间 </span></span><br><span class="line">  &#125;<span class="comment">//顾客直接进入柜台服务，柜台结束时间更新</span></span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//顾客到来时，该最优柜台正在工作 </span></span><br><span class="line">  	time=time+count[temp].hour-come[i];<span class="comment">//加上等待时间</span></span><br><span class="line">	  count[temp].hour=count[temp].hour+deal[i];<span class="comment">//更新柜台的结束时间 </span></span><br><span class="line">  &#125; </span><br><span class="line">  temp=<span class="number">0</span>;<span class="comment">//最优柜台初始化 </span></span><br><span class="line">&#125;</span><br><span class="line">time=time/total;</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;time&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="问题-E-算法3-4：表达式求值"><a href="#问题-E-算法3-4：表达式求值" class="headerlink" title="问题 E: 算法3-4：表达式求值"></a>问题 E: 算法3-4：表达式求值</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>算数四则运算的规则是1）先乘除，后加减；2）从左算到右；3）先括号内，后括号外。</p>
<p>由此，算式4+2<em>3-10/5的计算顺序为4+2</em>3-10/5=4+6-10/5=4+6-2=8。</p>
<p>给定一个以“#”作为结束符的算式，求出算式的结果。</p>
<p>给出严蔚敏《数据结构（C语言）》中的一段算法描述以作参考：</p>
<p>图1：表达式求值算法</p>
<p><img src="../images/4.jpg" alt="header"></p>
<p>图2：表达式求值算法（续）</p>
<p><img src="../images/5.jpg" alt="header"></p>
<p>图3：表达式求值算法（续）</p>
<p><img src="../images/6.jpg" alt="header"></p>
<h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>以“#”结尾的表达式，运算数为正整数。每个表达式占一行。</p>
<h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><p>输出表达式运算的结果。</p>
<h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4+2*3-10/5#</span><br><span class="line">3*(7-2)#</span><br><span class="line">2*3/2#</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">15</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h4><p>使用栈来解决本题，很多人都会想到。但怎样建栈，却带来了问题。同样，严书上的代码实际上也给大家带来了问题。看过严书光盘中代码的人应该知道，代码中使用了两个栈，一个是存储运算符的，类型为char；另一个存储运算数，类型为float。而操作两个栈的函数都一样。要知道，除非像C++中使用泛型，C语言中却基本不能实现这样的操作。所以在C语言环境中需要将这两个栈结合在一起。由于char与int有种特别的联系，可以使用int来代替char存储运算符。</p>
<h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><p>注意灵活运用栈，要是能够学习C++使用template就更好了。可以模拟STL了。</p>
<h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>这题作者本人也正在学习，等思路整理清晰再上传。</p>
<h4 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> SElemType;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> prior[<span class="number">7</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;=&#x27;</span>&#125;&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> OPSET[<span class="number">7</span>] = &#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;#&#x27;</span>&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack *s)</span><span class="comment">//初始化栈 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;base = (SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span>(!s-&gt;base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    s-&gt;top = s-&gt;base ;</span><br><span class="line">    s-&gt;stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *s,SElemType c)</span><span class="comment">//入栈 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((s-&gt;top - s-&gt;base ) &gt;= s-&gt;stacksize )</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;base = (SElemType*)<span class="built_in">realloc</span>(s-&gt;base ,(s-&gt;stacksize +STACKINCREMENT)*<span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span>(!s-&gt;base )</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        s-&gt;stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *(s-&gt;top)++ = c;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack *s)</span><span class="comment">//取栈顶元素 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SElemType e;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;base == s-&gt;top )</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(s-&gt;top<span class="number">-1</span>)    ;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">In</span><span class="params">(<span class="keyword">char</span> c,<span class="keyword">char</span> str[])</span><span class="comment">//判断是否为运算符 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c != str[i])</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Strcat</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span><span class="comment">//字符串连接函数，把字符串str2连接到str1后 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str1[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(str2[j]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str1[i++] = str2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    str1[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Atoi</span><span class="params">(<span class="keyword">char</span> *c)</span><span class="comment">//把字符串转为数字 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data= <span class="number">0</span>,d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        data = data*<span class="number">10</span> + c[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;    </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">precede</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">char</span> b)</span><span class="comment">//判断优先级函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(OPSET[i] != a)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(OPSET[j] != b)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prior[i][j];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *s)</span><span class="comment">//脱括号函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;base == s-&gt;top )</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--(s-&gt;top);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Opereta</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><span class="comment">//运算函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a+c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a-c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a*c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a/c;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EvaluateExpression</span><span class="params">(<span class="keyword">char</span> *MyExpression)</span><span class="comment">//算法3.4 </span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//算术表达式求值的算符优先算法。</span></span><br><span class="line"><span class="comment">//设OPTR和OPND分别为运算符栈和运算数栈</span></span><br><span class="line">    SqStack OPTR;<span class="comment">//运算符栈，字符元素 </span></span><br><span class="line">    SqStack OPND;<span class="comment">//运算数栈，实数元素 </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">char</span> TempData[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> data,a,b;</span><br><span class="line">    <span class="keyword">char</span> *c,Dr[<span class="number">2</span>],e;</span><br><span class="line">    <span class="keyword">int</span> theta;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">InitStack</span>(&amp;OPTR);</span><br><span class="line">    <span class="built_in">Push</span>(&amp;OPTR,<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="built_in">InitStack</span>(&amp;OPND);</span><br><span class="line">     </span><br><span class="line">    c = MyExpression;</span><br><span class="line">    TempData[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(*c != <span class="string">&#x27;#&#x27;</span>|| <span class="built_in">GetTop</span>(&amp;OPTR) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">In</span>(*c,OPSET))<span class="comment">//不是运算符则进栈 </span></span><br><span class="line">        &#123;</span><br><span class="line">            Dr[<span class="number">0</span>] = *c;</span><br><span class="line">            Dr[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">Strcat</span>(TempData,Dr);</span><br><span class="line">            c++; </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">In</span>(*c,OPSET))<span class="comment">//是运算符时 </span></span><br><span class="line">            &#123;</span><br><span class="line">                data = <span class="built_in">Atoi</span>(TempData);</span><br><span class="line">                <span class="built_in">Push</span>(&amp;OPND,data);</span><br><span class="line">                TempData[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(<span class="built_in">precede</span>(<span class="built_in">GetTop</span>(&amp;OPTR),*c))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                    <span class="built_in">Push</span>(&amp;OPTR,*c);</span><br><span class="line">                    c++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                    <span class="built_in">Pop</span>(&amp;OPTR);</span><br><span class="line">                     </span><br><span class="line">                    c++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                    a = <span class="built_in">Pop</span>(&amp;OPND);</span><br><span class="line">                    b = <span class="built_in">Pop</span>(&amp;OPND);</span><br><span class="line">                    theta = <span class="built_in">Pop</span>(&amp;OPTR);</span><br><span class="line">                    <span class="built_in">Push</span>(&amp;OPND,<span class="built_in">Opereta</span>(b,theta,a));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetTop</span>(&amp;OPND);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">EvaluateExpression</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<h2 id="问题-F-算法6-1-6-4：二叉链表存储的二叉树"><a href="#问题-F-算法6-1-6-4：二叉链表存储的二叉树" class="headerlink" title="问题 F: 算法6-1~6-4：二叉链表存储的二叉树"></a>问题 F: 算法6-1~6-4：二叉链表存储的二叉树</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<p>树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构，其形式定义如下：</p>
<p><img src="../images/7.jpg" alt="header"></p>
<p>而二叉树的前序、中序遍历是非常重要的能够访问二叉树所有结点的算法，下面分别列出一种先序遍历和两种中序遍历的算法</p>
<p><img src="../images/8.jpg" alt="header"></p>
<p>第一种中序遍历的方法（算法6.3）：</p>
<p><img src="../images/9.jpg"></p>
<p>  第二种中序遍历的方法（算法6.2）：</p>
<p><img src="../images/10.jpg" alt="header"></p>
<p>通过一个字符串，建立二叉树的算法如下：</p>
<p><img src="../images/11.jpg" alt="header"></p>
<p>  在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。</p>
<h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>输入只有一行，包含一个字符串S，用来建立二叉树。保证S为合法的二叉树先序遍历字符串，节点内容只有大写字母，且S的长度不超过100。</p>
<h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。</p>
<h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABC  DE G  F   </span><br></pre></td></tr></table></figure>

<h4 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A B C D E G F </span><br><span class="line">C B E G D F A </span><br><span class="line">C B E G D F A </span><br></pre></td></tr></table></figure>

<h4 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h4><p>遍历是二叉树各种操作的基础，可以在遍历的过程中对节点进行各种操作。通过二叉树的遍历，可以建立二叉树。而先序、中序和后序遍历分别具有各自的特点，是探索二叉树性质的绝佳“武器”。</p>
<h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>1.此题的难点在于利用树的先序遍历建立一棵树。</p>
<p>2.从我目前学的数据结构来看，一般的数据结构题目如果采用类模板来写十分耗费时间而且容易出错，下面的代码是使用结构体和一些函数来写的，十分简洁便利。</p>
<h4 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree *<span class="title">create</span><span class="params">()</span></span>&#123;                    <span class="comment">//先序递归建立树 </span></span><br><span class="line">	<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	Tree *root=<span class="keyword">new</span> Tree;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			root-&gt;data=ch;</span><br><span class="line">			root-&gt;lchild=<span class="built_in">create</span>();</span><br><span class="line">			root-&gt;rchild=<span class="built_in">create</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(Tree *root)</span></span>&#123;            <span class="comment">//先序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">Preorder</span>(root-&gt;lchild);</span><br><span class="line">	<span class="built_in">Preorder</span>(root-&gt;rchild);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(Tree *root)</span></span>&#123;            <span class="comment">//中序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;lchild);</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;rchild);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder</span><span class="params">(Tree *root)</span></span>&#123;           <span class="comment">//后序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	<span class="built_in">Postorder</span>(root-&gt;lchild);</span><br><span class="line">	<span class="built_in">Postorder</span>(root-&gt;rchild);</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Tree *root=<span class="built_in">create</span>();</span><br><span class="line">	<span class="built_in">Preorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>随手记</title>
    <url>/2021/10/27/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="不知道密码还想看我的秘密？" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ffb6eec1f92343b3bed3df8bb87664ae356e3aaef1996e2629577ee8d672df46">4630436162ade97ba2718b7d0c4b3b63501b8b0e90dd70c68cacef77fafaa69c73d49a7156173c422d6734de366dde9d5fecd900b2df01a8c98b7476333a840598dee0dfe1bfba9f459fd97d4287d9cc42d6cec2cef86ed0c53d1caca01938c63454e314b09f8bd28b0404acb69b00633346c197b926c957c4991dbab9a73e1480414b31272b423d970840e8318460bc6ff61c3d49965abb139361ffb0f95007f9a372dfb98d038952f6bee686e8d52185c055103f0679c799d3b07336a1bbecf03372524ee865886dc52ad8e7e88f243394d99bd7653c4a4e19f486d12026b43e9d1e36105a4eda1781da2c1c55a896ebafd9c43b1ad29f9836784ef67270aac781c414b6d7c7deee5e5d4e9847105ece31aef684a74289130a15728af0bb58ab14f2c1e4ba482a811e49a12e8ae912270bbc17f9359fde974d42b5fd40c79984b0b23dcbba0d2803e9be3033aa149f906eb33bc07ed46f0c8c1ce52e4547849a814b7afb778f6e19d781076739e9a7554ecf8667690ce0170d524d5c516c9896fc57904ae3b6dc135d66673e238a951f884fac72371351d6c23b5f08b0bbe2b60811e0d41a5ab5c5e5f4a9f78a5c5329386e815ebb3200c52a8aef556bef0658b8a7ecc084ccb1a1713de800c2650a5265e0dbc3add4c373377787df33ae7550014a36a71d56a1ac8851dde177789c38dbae6e2d48c3053bfb1b998ebc18e886213934426b1f603230f19a102d70af95210a8400bc3dbe3301ed0c621287fded2743b0a74e1916dca5dba16417223cadf0101f8a8926f01d51abd6abc4797470bd360d07223b0e81b12c1197dfd0dc38f68312a2d3622b7adecb5922f67e0ab54a6180aae4c8a36c710cd717c8dcc1387b06499a8bea3499dd4beb7143ee976110e6a81f56ed58e75e2d64317d0889290b94493e219caad98fbf2f62490eada79e3e442c2cf3c28a73264f19059c975232322ef13df8cddd6cd83482e057567f7fc6b8e7daa5870a745320b563306f1dec2b3895383f9c078db96ac5350e6df4d13e7435f49564f733530004fa6b03f125a4fafca75cabd450f61077a5d4ad9b2d402fc624f151f033a16bb8d3f5ebb5037fe613650ac18eaf9696cc6640b8614797d28b3b23bb7aa2afbbfd22eb587ef4d3525f35b05463993a5e5495f3fcfa16a970561cbcdbb95efa99652d15633ef8f0b91ec3d901f84636f6bffa902bfebbfe486b104ad6e8d0195edee959ba60d568d3350938c2710aa1a865116711c2c9e654b3cb4fd72bec6dffc105a9454c9b927189d0cfe4960d052d04663cc84a6a316cbfbc5f8fcbe76b64f0854ae3dccdeb95a8303df385699f984756af6e67b99583a7b222096fa77a4fa104dae4734bb9390aab64b288a780928f3a274c746edb6fa9c92a36c4b34c1cd941717e6be71b8e0a4f92210be0faf43c7758b1a65944ff2c9d8c18950a120ec4157a4e0b3661fa3d904a95b52784a58100b6ee31223284b1550b54cb41fa0ffdd96450330d0cf34300ab8fef2b819fb7f6fc88961813b2340969fc1c2444282cfe28ab6fd84ce996dfb63f2cf0b48e7f5215b26ea8208274d1a22f1bab279ac9c78cec82a09b582ea6e2ccd0d03df25bb11361508ed30f36ac5756c2ce9304325ceeac0b20844aa7c47fdd083849107a1fbd5e43c529eb80757203ac99e395f1586cef3c46455cf365222c6b78f5bbc6b3d2e4e45f108249f89ddf964efea6b3d57e0891789b4522fcc3f92e3823d8300dc505ff9aa98485a8ed74e8b7b178f5b42bd154d9f1aa1ccf20a128e57e4467c584a7522c65d944455ff506a23fbe45e54d7a67bcedad5b57ff540f94c5c689c5f032b721b1c429fc0f9ec09197f873214f9ce9de6c88215d40a3d6b4707306481af58c8a1ec304f1a56dc0c1a347cc4d7210820676ce0356a7eae308bd299c92649790c1cd81f82cbb9a4019d3a90f5efa88638775020ef5f886bebf51aaf7981ec18d916be38099fecf52982e457c34baf68331e45e565dd5c1cd3a2f63edaa2cba3a38c72947dc8149d298305a8fbf1e373430924345822378c2bc111e29f970f85f5ec7d639095f6f041460fa33927309ad8272a75faa672c67f875dfcd639a4e06ec51701c8c24ec715cd931445129d9765dcd460a9430abbe74e39db86e2693477e4cdeea858bcc7587844c9a4fda846e0987c08ada906998375e238c8154148e7a89fae0a390b69d3689176504a89ec08fff23dc6d3439419d973a8c7670e64172d45b87eafb160d84418d9003a1c322ae1a0270b777c20b4ef79709c6049b6f9b53f441f44b407ac25cff1d6657b043a9486498ce66e8b57fcc6126cd8cc9356635f16005885ed477ae8dddf73c7b105db6f10ec3ebe822ff0396cc113c6c72a976fe805a589d902c99da60875b15d91616834b6c370c5ef9be29a7fde44b8887c39b44c12bc4648cd45f15ae0aa913fe4417b1c536b978c7e881bdf3d700c7cb4ec0c3a52f82bc50e14e18c4f6e5c8f32926d0c818a8de0187382d469208750a5710b0cab5a98ac562ff24662cc87a58e5ad1e45ad1f27339b0f1f7b396aaf09b1c38a68551919e1ae755849a76752bfcc638c507406c88b1820beb8dc7091c9271586c119fbe1685d1159ddd1dbbb4099fbe21c3ae8a94c9a35359ffb5d6a1b6e06779d248477e43aa1f0801a0d40e29ba122f566dc82853543d95313c75b90961e5522072abd3ac9b1246d14c643a3e9c9146fcb3f5114886402b5c12b0df81863bd76834e8a27686699203295ba5dd079189726b56af079285b2cf8ff1486b4a9ebc5d1fcac82ab30cb44a420b4a818dcbaecf8b26ec3ee10bc5624cd4a13cf55b3af65e61d62220550949d4e9af8d3d807efec0de4a1f15c4748a1fe34b9792d538bc90919dfc54d0bdbef8669c0c907475afe3f5aff3634ad02997abf4c13656e41128e7d767d6d1f8effd417aa0feefdf3e74e6fb0fc60da3e0d18b55ccbd4a529c37fb7d4d9334275a95cf32dd765c0cc4b481661327e4dfd00d093ff7c18591ed782a8608581aae5e1d3f61ae91555472c26a89f6c01ba321fca050914ea84174dad96c5e56d45ffc33bbec23c9dd83fb0e3b29e54ca4e4ae2ad519f84d10bd28abd24b10cdacba1c7701ba3dbeed02b2dc8d2071a1d1d4c7ed459990a376107b843bbddad8f42479a5aff27b972d70dcfee738352ba1e3b42d3f3ba49654bca8a9a0c9de859281cc6b82d3f030db5cdddbf774bc7418e8f6e999e2b80ba9627cd765e5a3354be4dbef32f4baf8085b21eb94cb44ea1dc7fcd28b355e911703ea0c7bd8b128465ce504f54eee6b9f73b423ee238d28c9c1e4d09482d0ee470483a8aa06d323a10bbd3f4cabcd21efac416517169b603d7ef93d53d31a229b11b582809a1f768bfa4a10082f5d2d37c31d72e6107a89f62158e203282f2c9a5c40ddda02d5496abf5a9fc3bea65fa69dc6f6847168bb87ae380e1fffdcc1fdbe2d96ac6b9546c3fcb722db605e789925d483585a5af56a2b4e52761bb1d95ab2eaed44c8b35f5794fc0610cf7863debfc16ad26341583adb61f6f2b1598a5fb0478c26c092ec2accc0725041f42d505a378b0a82e73efa032b065dc607573c0a0e8a3b4448b4c934857d257ea23dd102d2d53eb67ad50721bf7e3bd790142df5794eef17dd6111f7f6d41c6e14da0d37e43bc898d812a1ef304cfd1cd8998e2e09299a4e174303759273dc2aeb107423e04f81a3691d676e6fe1e944872be7a2cc8bf2d2f2dbb7b035cf2ff524e7105a9f4fca043baabf6dce707e40094f0ee7877ac03a8f02a4120281835569fec938d68dfa3a8210d66aa1cbf399f2093375ba12c318a3386cb61c06c44a43b6bce521ad86c0dd0ca05808a519c0c4d0c01a4f82483f310d6775178abcf31385a92cfc55f771d5936cf5b89162d9d9768f9fbaacc15996725d282eed88dd1fd1c8877fafc79dcf50df836c30d912f8e673aad499f3c687eb5cd28e0950c02dd3c076931672f81169d9d8b664f800be31835bafa2d02842d0ba4e8d70f8afa489887032a36890987d661f95cb8328e9ad5bfd805e0519236377f5895d4176e7b37ff9290120ac2109ec4f8a7d5c1c10dc8f48c7f800b9411085a236c4e0dca9d2d0d89368afb62570747b726c160c840a4c63fd380a074017f5c9e214c04e9caa19bb4f50c71977c792faaea0bbc86622cead4379abf3087fa8664f1d45604f033b22e4bbc394422d50bd4b48f110f0e80763fa64d32cbb822e76c743ec7192b1a0aac3ab4315d8db799dcc26e6a93ad4c29686e7da93b7611d590b5fd20e8dd0ce390f68e0dd72594480612d3a3b1d2c3c2e31f663d97b6321d4f1b33bb5e281fbae444b4d931eb33d8c5ada45409f9efbf41d94ccc48f5f3520a3f0798ef4f9786ac16123ce1eec6b07947bceb38b4475c758431000a91963cbd2ad4483c9e84e09d9f681c28381906a005183abf5912d735fea694144c5bd61c254f442024df89347446592885ef985bd8f7710a902bc1d01ec6aeb5dc8305cf56c572f87fa792b8c17dffd06dd534deb9cf17c053eacbb6e0957719e10f50d6aa986e7a903c945dc03750c4e5a184aeb94e670c63170eb9523af18414080d062b303dedb99bd11eaadaf79a6732963488a3bb674278cd85783f3ba0040d0e41972978dd4fdad3a42b1055ad430533c5d88701279ce84b2364922e766dfe905d47017ce39a3623aa44c959e17a9ca562b20b7753957855fea3d86cffc305162904e0a6b5332cf7ecf2373d0925c958cfd31ffeca5c33bc7e2ffab982a8310acabecbbc5cce3c70e67b8a69330937e0ddeda42be1ff527b57812da9e1dd2e3de051c06ce46d73a78f60dea137bed172ec86623476e16016392b15c21227aa1e53b9543264611f3fdab13e010917bf5f01ee2f07fdf58d7e90600013f0267a0d54cbb58a72b7f0848e39c2f5336c8d5f9f76996d71cfc15a7c1352d003238cd8155f11d9051a81659645442d8a92e4a0e3d123347dbedf71cbe1ed715cdff816f7d3628a57f0e70d66133eef304fda96e3f72bff884ea0acee04ab7616bb7e740c9e9d3819965961e5b6296acc084d2fbadc3653b3d7fa977d329282bb16360fe3030322c5122f6eeaabcc24c9053b345e8ba325f4fe130a2a34d2a520f066ee3ca7d85bbfad74f9ee2eed6f2a5f6f978d9982bcb866e81a34ac5cb4eb7ac80c2e7d0fef75deef3f6e136582e8e2886ba0eb988b0825be459f56d25115e86cedad33ac78251cb5a71be7a7911ba789865ac8a4e1327f1e717a1fe797393b546e43a0658a292847c5f6c586ee5a950473c253df022d83899ce9b82ddff6fbd05350e0dc12c845ec8bc41660e8b8fec4101cf04085a5e8d92eb744e1407decb1f003b3978f5c71fbd40cb4d02a37b80330fa2cb0b36143e595082fb4ef1c7ebcc2c480b7323d0d79ddb33526d0f359b0ad9da22abd54d19cdfd289f5a716eb8fe6c3110a5a96b805b4d3ca98d2d6bfd1fc116e6e4ae0a08907ae37c6547d19131bb22d95d14470a8c4aff73b1497a7412fbbd673709faa62264b109909c91d2dcabd8a94c537e5ffa9731aff7cbd647d59521cfc3b50520da460bf7da48c28de9a03e4c034a0d23f52a982451032dfe6d1b50256fdd7354d73f4c51a9bcb6c12809c8ffc6f04e2c48e708afe545b9595fc4b890b1bd9a64ef8c86a4053a5594dbb23e02983676820155de871766c3e8c4ef6a1d35f54decc15779fcafb488b7ac783bb36dc31bbda4364197a539a6dec29e5e63e57c6197ca58b0c6d141a67e68a9dc75cacde0adb53f609d545641830805448b07ba7c6623fadaea7bf72f5035ec6c12b39954e7493108b91c487d82abeeb1f6819e9766905553fb856d964ea47dfac411de6bb51fb6e53c6ad8236acc06e9aaae550aab4f13b7e6c9799ac1117fe870a2eb7fa3e9f42e4f3d933297352248cdcba58b971471db667df9a3afee28134b157037ed7ace34c3fa16dd5b930b27027566280d4dc598470cd0e84f0cc71cd048cf9203c316552f1360b01603d79e186427e2498431316925a6b43472131b1c266131a708ff936e96a95b86f2304edf27713f9f071e293f66876c81eb79956a41b30263df91e777c6c00c39b97e547f5f1195aa3d02d70af647e9c36f9b63923d957f5cba7e9d2b16388e6c64e163576d038af2e2a0363f2acf197e3e155190ac54995ebbd3b4a25d497bd6befcca192ae75b2e501228f077136bdc8d747cbd8e6d641623c4cf0f49615fd5997b2227040f32e859bd24799504cbab8933773bab029d5abeba60d597737a6e6d52f9d2dee5a750947dd940ae8fd04602cf5cad641bd25a95c0308928d55319d470ce77b2fe954867331ca417262535446203332334f138782a0bf537fd5710d4405687aaf1586c3956f5981dc5bd59cfe2bfc6c60c0cc8e4e5df4b66dcb04e6cdaee7cfb9516613dc268ed8fda9f1ac020abf1a64bcd382959be2b4a320ec2ae26c74ee0fe75b1ca039d10f8392dd01c6e0ea5d7797ef34093c77f63fabf3046739a9b1f9c27120988110ab8cd9a59e3caebb430dd05e0f5f81ea0defdf843f8e4e4efe47f46f1e1de101a2f1e7e4d3c5d792a57dd614733a20356dc83d29f96ce01d7438ac00f0d3c4dd9295cedf7b8765292b0c18503246f1cc2d2b02cb60281072ac6b01d8bded5e7e3e9a54f99d122ef9dd91d241a345db29ca6959efb0d320415f0d362eba206ac1637f375667d43ac15feac2709112770efe12708f88d2ba0358bdfc21d5964f555c21100c4834c823557dbb752bfdbf2697ef97a7e71a5e86edd074d0540a02e2eebb201437b27faad5bbbff4b1d7f41cdbb3ded02e96728edbb20f0dad723c01aac059f57cbc0b94044b121bf33e2d12f22cbdcae6596a9113ecd9d8b23229dd75548156c9cd13a5bda1897b304c4df881637b3d11e317004ec3137b9fe9b4ed6adfc191266e3edc20ea1c15521b3be77921a7109ae2bd95a45ce142a3660ea12d10e2111bcb76efc1b9f7d17c74b8606188252e081db4fc72475722ed81377ec1016bf4394795b238bb261f41fc735887099b9bafc80612ae212d274fa5d1650421554bf77342a7a8961a5ad891091e2307bf40a113e42c21b48c973fd97bd62ef48cd9ba22d58048faf47c8dfe1e2987bc9a676df35a9964674e797c5249fad735496c7b385e4f8939d60c27585c4d879fb426f78de49d8d7e2ef039f3180f7f7c4ebf227dee2f87abac589d7196ecfc8e84dc985a8f62ce2d32502ae5ccd7cd459901fa04e9fbfe01928900c8d3ee58cf4350621ae711ef7079224dd72d33974ea7ffc468a7b6b4580ae4c3aa20c603cc19e1b72d02b348a471df9b3365aea3f9eb3b10a394564ec6142329a923ec98cb6137945e43ed94bd181ff54cb079be8c21563888e1770228d8d31b740f7a8d7d341348dfaa653ee48db98f722065c5dcf6df9939b7d3bb46b38f9ec3f469e3d34768471e964181ea4e121e0d8b34c58d4e4c45d41f9b7381698a39ebacb9943131e55d7e830924c1fc27dc4bb826cdebae8c5ea8dc5e0f00f7416d339ed39c98c4830b2f5493282e523cb6a30f56444194abfa6897216d43fa6eb87de0dee6990a9833798ac9511b13d7aeb1d89ffb6a93e2ea1efc0b4999c0fca25bd4b2d2225f929a99c756c42a7e893cbcd6056534c244d5ef2b554412ee5f09bd3ba81499d141cc33deb9bc5ba032197081051e39d50ad2e139ff9c72282a41f14912d93389999766631b8363421209fcad02d848df0c1c0fd294abdc05b7047694288d3d9fc91c0ada26ddb80308df05dbc185f65b8daf41f134ccff2ac3458ae2e63a96042950bc10ceebb1ca34356e4fc6969b8f1c9f706a490a6bf69dd1e8e949bf26a1290889e9025b9a2e09957f1098200e35d9b28f632e712a863bf2c34cbdfc4d0ff54596b7976180548e4517cf8153ad53975571b15044abdb69cd21b5811bb25382710fb4c3a35dd7a12e47558eb7d4455a71f472e699cf3dc044b7ddf4737d711550cf6e4d116baca563f441243563b394a69958ffd0496616e8799d8c445feeb2b6ba3ec15eb79eb064bcbaabf8477fd94b0b7721510d4acdf9ae76d7e77daf47f5eb95aac227ba7dd4afd74b3610ffe529780cc2a9f4c6f9401469019ed32550180e95186e24cc2449648f180e7de3e64646a979ef16cdaa349b4a5c1797f91062e84932e882f309ff9638728882253dc90f8df0bfdd0d7fe9c2feee4850ebd83db89b5efc432566aa9ae1fa6e40e92213addd5b5ea7e2a1e681c1b6fea2451df914404b9209d2c8b195113b49caac23deec2c898c0a67967bd1cc6fef4f6132742bf4fc638efaeb73f04c2973a91aac0c5b4a51f3aea7e7ebd44ec5bd319e716510f4b7f88b4e61d911f8c3921a4a75c8a28535486dab74a4343fab9ae2f45710aba8b4522521d3bdd4856aff8e4450fddee127228ac884f8730bfa83f5cfdb55956d01c0652cd01abc16f3b99914a0a8420a94f798b59eaec03d76c8973b4978be759a21ef0c8d1ae36accd861905396ffbf338393eadf3d2bb55ea93d29307328ac59a7bdd38667ce6c0cdb6ce60e782fb54948f5c5bf05daab0f8540eec61a6e89b3bca1a47181ba17c990bc864fd89ef2c85b8add9efcf21414807b774b0d717f814ea9705333c2742158cf6fa0fe4b6288147e7c7b41dd1c8647de71dfd3ff619f56c6e8087c5ba6e14680a62bc433860e91d885d683fda3d9835c2cb663f21c9321d1b671994524bb22139e08a89a80747b9929b4565ed8df5df4019a1a2ae9b94af44a6b93d6b80eed8eeab9f5b4a40d6b156d480d586c16caa8828c88bab5ee30e12cb1c2c0ca5b634ebe12179d9eb9872739319d4433e2a8adec4e51224921bef6abb9823c3045adf38282f21d97123ae4c566d1e339f5bef9d38aae799d33bcad79aed85bd3a4c6076371d8726a94f2446b36e2990b4d3c09bdb2b30eff51f86fa09711bc93356121eb8616b88044e48b5d5ad576f94868e7146c986efbc77d06797e7abfc223d3df48f146d79ed0870260b7a78407157ea0f86de1cac55964b5522b1741b992e830cedf0b0e1c9ea0294f02e67728d8d5cccf780b98fa8392c9876114875a563903ff392e9150f1fc1a2d3b5d6eebae7d832367c201a5789ee2e34796b3a54c6537e261efebe5403fc81e548a4c9e4b3843f6fb0db8fcb4071e3c3dc80de4d38b64a37de1ff0adf71c9f5a27b4ebbf86985600708d1faaf4e610685e01dee2ecb6fe8564122e05664373f8489735a40cb8231a2b1a7a09c7a6386a1df0a158dbc644a70ad2de0ae1a9ac5fb0e3fd5d149a679f47470f8f21fafe173fe275162d7902c73d5ec5bcf22fcab270723adadf57d716b8c0d5f834083e861328de2048fe752418d45e75b8ce252920740147d3842bc470d24bebc30cca8cbcc763da4d9909bb5c5c81bcbe0ddff80f31e551ebcbfaf96a3b3813eecd04fbf8f4cabeb43ba27dfe4ca0a54265fab075a54690d7a98bb48f58ae0f158b9cbce1eb7372f728f5aae339c44ac5ae6f315d4f53f32187770bd3fa5f4d168e10c7f67599c796b5532370b0bead4633b0042e5a246af81a64385525f6d729a9a08ea003290fc83b3620fe1bb915afed61fc6313fcb1ef0f2f31b64e564cd6479d346a80df685d865d544c29cd13ceba5ed07a64dbfa2aac34b76709a2087a8cca7141a0b9a2ca3ff91e66c409955f4216ceb29423c71893e516cff282292096d9b3020cb0c9734901c8c0e9139ac29a4ad534e4658a9cf395c52a7e7b07bf70056e622c85477dfd26a745a6ba098469b21f6dd72ea19d8b3b2a2dae7705640cf16d6cfd3895d9f0db9fa062ba02f95262f81891e474241bf88bff45b7aaa5aa8453bef20ee7531f258eb3bdc1b8ec2510823870d6b10ece7041eec1ad691fceeabcde5b52ff502e7455ef091b79a10abcdfc6d5af86a55362628ab8122ac7c99b0c91e3ed265aefd0bdd02cb481cbcef8efc436c02796d1031d78054c83ca19554fdb4d67e2c8bc5bee58dd16bd02ffe5a441fa105a15856cef8e6ac91c920f9df0e57f8a2e0b51e79f527b2b8c234200bd496375f9f21313ca6ab09e032a5584bdd5e2c4b22cb66e2a1f5dd3388ef3457713b879c2115dc1bef8d935f1ccf80dd6b567859404d279f21ca684730e04e59e7be680ab5d545a4ac053b39fb99b9c0be43692869ff073703715cd165a42c87db4e1a8c67c884b333cb4d41e6ff2738a513bffd04e191a6d602fa69429beaca4110d98f49c395879ed7f48285d74a03322e9b3407b2a4fa865a2f1d53077eecb7740e16bb2736441e22a52d890df4a12b70b033de5e84fe2d2ecd433a9c0d8a03c78f51947dc8702d4d70aa0f44afdeff7155cbc0f7e973567acfc3457a9d3cd51be0eac9576ff714b7a7c70e2ef437755a2d63a8d9ad22135f4307506719832aa6edc4b34c5c96ea20f1aab2dac376adb98fc6548b5ec31119f6a9d4fab432491ab2ee88c306a984f04ee1e1f47accd0d72f13736b35c959f75836ed8a08618b8de3fdec6fc034edd8826208f0225e81caee4149796ff4d9497e8411865a3daa49ba28f554dae0e83e184c8c39ac9589cf4f6fac77597f5d974e39430164cf951fcebf29b12200a80ecef7da0175632cc691798099365c46a9aabc5eda34bbdbd063d252b4b9c6736798c34eec60cf0af662d972caf9a84f6b17ddf65f216a777889f7c4083fd24f2ba142e41e9734d0c1833f8425f6995f16ad4ca9aec8d136486213040227441c1fef403c194f7cccab6c5ca4ca6ac6756a0570069ee817d4d5b1f6a96a8f6f327c8c4f81e15c9e87b61bd2a9d41cc792aa3ea04d5df8a4260e3bf7394f3293c5889e1025dbc5dd5bf1d99bcde5465c3b6fb86e14d933a6af941f99569789030792a8146a04b5f9f24f08e2e35d6f77d02e7612dca9cee06ca783f1734608b1f4d0d685420b35653a59297814c74cea8b585f631ea63f1227e0ab856d0be19538190375c2d867b14e12d2f1b37983883ca9e614196456e1bb6e398a26a26b8bd800c462c9b9a3e946fb5444d6dc92acfc89794b6239824030e3121368876a3691ba8c69e704bae8765e99fb03239b8468f109cafc3fe171a010d16f223a7614bfd14beb7542aaf082cd3168692052f9801ee7d498588dc33a09e16cc618df0f1e5dbb6ae08d8d486320046b5cbff247723323779ae42904f3e982c44acff01509f1eccd2ee1ad3d10c8e8836ee338b57addbb4102a3daf26850f5892d613735fd0b6282e1af5b44e9de52247ee478e0f5e18a2038cfcc9fcb74e411c50f2c86e4142869f95d4a03a4d1f6d7e89786fddb246625fd00ace518ba8011e1d8eccd2f4fb9e279947dc8093bb22c2858479fb515d7320b8d180f8577542ed0da4594df3b8c74a01b1b5995b0c0bb9c843061353466726da937a132a3c8936ccf01cf3782c6a8ae07ed3939dee81750b5ca78b57d9dc0a1203f24ad120d0a3cbf3896a4f0f94b1d3ef5f1e77a11513ad74bc2e03b5afd68b44a64009411085b700b7534a859f4e37511164a52e6a87e8fd62d77b3e01baaa15d3e5cda50ac15ef714c30a8f11d00bce6cd04693f62c9517abc431ff6fabdb3f8cd76d7a5f4a6f41169d97529448ed3fbb18e7dfb79a370cd9db272914457a9a2cfcc09ac36e210bab759a4f80867dc93001eeca9dad906c421d68fcee7e009e6db36aed358dd40ec042847c3400a0184aa50c8e074190044a0f06dd2762caad9a4768c82b4987d13cc522850f65b88422840cb604ed7a23b4e13049118d4aaa65056383241605f655ef6ca75cf65e6f116e3656d27cc2a38937c889b1eaf2a59c7eceeb2126a8ab244b016a42580e4af069f54c367c18c9b9211e53e281d7653141f8b248dd48d272181fbfa69d4cc4011a37594044596317f8a6d007a3262272f7891dd80159c9f28f258292c35a54d82fd70a3f4c4148072b29e2a0ad27b0fff1c41a77e0406ee5eccd784b74e3299a133374fb9cdd66eaa24ecc831a9f270109a61196c566958be2e450af5b8e7b9fe92fdb07fae3545466bad1209b93f235457d0934729dbc331694ca65587dd922d670698e403b2f8e3da62daab95d569c4d3f925a0466bdfecdd0c132c35888ffdf3b9029bc08af83881b727c3a1d713732bdc4f4fed4a11083320be2187ab6066c12642eba0686183a28e2e5846cc1a60d8cb8b31f4c9072176f8a09fe04002aeeb8372b2c14d64b341651b79635ce3c7d782e0bfac84285ad12655891c9ea2ed3d5ea89e0a3b0b082fd790e0eb7ac27100ab371dd847e98d4e05b0eaddc5c1331d0142314718ce86dbfd7fb590417270c773342954e2293924f3e797e8653f74081162dd4f2bf036a5c96417e6f61dccc1830ee54ff5aaa216d49401f89f8a3993e45aa9bc9e08ca157db1e78fa05f4812f01a7a2eeb72ba6665f826809fabcd3cf7231d2b04cd7c0c59430582dacf604f1d68f5aa19480fef4eebc76fb99557d29d7f0450371ff191f90141dfb2ca25c5fba5b88789f39ccd8b52e0cd7d29a7b7077ba2e5f7310e1c19eb1ad085bb64c0dd432084de213fe026206c49e3ce8d41920c88386e8878fe6fd8302845ebfc4ce3a624cdc0da70b234195285ef18d2e4c1082bc4611baf46aeee6fb251540f1b2be1a63ef2e7a2d62fd762016d2047d8097863ac883101e1a7f818f86d0f077f88a475987bfd20f48eb5bed562cd7175c869ec2cd7a575e7478acae80200a72594cf09e52f6c7f0c8318d2ff0977d23a8ac3d02d1a093d34d415e8ee4fd5716835ecb9e25ee6721c2e26dda1197cd6a1e9d50d465df04e55a0d685aaac00ea9c520cc42271aa16d175e6d03b85e18ab871407c54a282968840913dd271ba60e5cedeb4714c24d61ee2c19cbc7d5612f52ab5e9d42be06ab32263717d6f4539db595c4b4eacbc4dac5094d29b92f2150ff390c347046f412a15e85a4da46cfbc8e3787735e4ea71414e6f2d45efb150dd09d90baf501c9b622a2fe916ac23a72e3b19aa5e4ff3ae6b37c6a6920add92dc283bf273efc374795e8030078e48ec5957482b171bbc7483c8dce00be9a957cb80ff1d41dcf1715d4b7d42f868f007c8d1d0700e9ddf768793dcca84242587bd9ddffc3f912d784a7e022c5ac15a4b0f185ba9ab6e1607d037ce8702a5e65c290664ecca02894af24d778f608308fd1912fc61d86ff4fae5065b6ed415bc64beee93f7161621a1469d8caaf6cc78469ce0f48fb92ca8d3f5fb4b80108671e1873b6f645da0e253e57d4b33a3db7a85d4a84c3f0059f6f36e3a1aab279122fae1c3af22246a7fd2bf4eadeae78522f53ce8bb9dd2e400cb52a0322b18b4610ce26901b9821df6644051b53e4c3d13fda807d5fc816eb83c230876e9765a8158baf1f393177924697a02cbd1f7bd460c054592bfda4b042d1fae7e9bc794a78cad0e26fe782af4f7b9acc9df6920a27107df862b535f0c6e8017b99645061ca6b15a17085845c74a0a0bda5e326e9bc2bbf344557dc3e375e250386c5b52a21d49041fb9b7f663ae48799bae559790faa5252222c32e3b0e7ba4c5c38625c7970ce024c1289b81624b76f9862249ece2377df8f226695b8a8f752bc88ed96abfe3a3c34e56817537313a475e6f48ae4a04ad08889053ace587b4650c905ac4f93e8f47b3c1e597d335b81a8e446da00f2d410f19c460e01c3632c0e5611bc47218859e08b5df447b577e08dbd419bf2763ea92c3f809f772d82f506206b0d670152ff4ff14179a6293dca7c097074d42685ea2ad412d638ac150b9f530b14f824bbf4a1887896c08143646094bc6233e86c57fa47c5ae3d215567499716b6245af9c6af703ed8fbe678267b27cdfd1b3a62da9e1b061324f4bcd217e9b80c691fcdadb7ab0acdfcd4b56fd35f477b98e24a0bd491e3f1251684d5678f5c989afb01047722f4fa2115b7f666e3f1f46bfc6a2ade00d61748ed8b129ea43956407f80de86dac176732d17119d8ebcfef490681dbd3b8956a22cc857163ca99c0e11460ff0de304be18fe25f191106eb59310ba92bc746bab2a6b113bf50e5c0971595a6ed5f35f00ac4a348434edabc3171807a5be5dcb8357ee27818c9b2adb7addda321823b499f3240012a802134267ea6755150c2293dd56454793db77d12f8fdc17ffe59b53913e694896dbdc865da5c04d8dff63807ee91dade932eb8a6210eb5c657e2da4a40e06dba0b63bdefcec2f418b68e32e1193ae26de725a6016fad8abeac170e815c8acd3c53b80b6776e737894d79e0ae5cd0aa9eebacb94a0638cb902a06bfc29a6f8c2ff64592a6ada2fd8154e3ed58dc7192e804d9974e0b4fe3c17ad4d106ebd001af62c5d73ab945529575c17d5228e009747cced1e9e532a7772b2d605791ca4b637fb9b3b37e1d0ef5d32c4052e2eca62bfe85347d4ca7d0fbdd696ae8429a60e6a08b87f4563db472d78802a0f7fe863708d253e861d5aae5eb5e2d5b6c3906420558e627ecdc171d642221df4e466a45ec299776620bb97a7fbe76fb6e56e2c349b88e0fc7fa06e66adf14d0cede39bf4a9950949b26c3a2b77e1b1ed58b95d763bc8a12575d9b8032432adc8c652678626da741c3371a594d9ba1a783950f17615afc6f9b07e272d0b2b3eab4b4ff1eb81a0243da67f6e72ae5390694d3e9986e9c97bdbaf479394db43122309bd9d2d6d2cce8092b1cbe29d05514044579848266b06503efa03a6101b208539b69e59536f73710a898c8f135c3731eb512f77e62afd86f57aa18796795303565709b0e916be01aff442867e8e598cee7590df8789e6705a76f07fb45ba4d3de68661d544b15b9f0c0735a12e0cedaab45ab48fc42d710224d12766e3b441c96e16c50c1907b78166bc89638571d03939109198566f46add82cfcc309dd6d416e6ef37b31d94840963949a6e3e265f7fcb62e632db59c649ba0d0ef6b39a6e606fd072e52ef6e73b78b55c9ce7c6149dc6c848c2aad5f9d83349b42834e68859e8932296fc0160ab35a0e1bed1e40e7a9c2a70a701c02ead999e3c11e783476ea2d8ba66758acf22e6790208bbabe6d92905784d8914bc6a0fad1ae4e3144a8713eb8b05a3dea204cf525886b146e10e00a2d1f9ef6a9e65a5bf885715e6e52493b75bd4f929c0ce58750ffc9279efc2edd0e41b674050102eab92954006c55979e000817569b8d56a23729ba695f6ce751f76a5bb10adf779c5227a7d846530d787be139c5faa142bcfa0e1e00b7fb776fb4e030a68f9e601e93d67ab91ea17f711082d53b6f409c902c9749b393753fed68f36e0006f485a39d778554a73dd13f601f2f5b7d7600e2a1c7835be1af706daec9b9e69c0578b103edc23ebad25b7c61d25a6090ddf2de247f056e9975d74bdbc5eb01d21b8284999b780c87a537a4b0866795b19e5a6501db124addb0c2e127a4fec9a7d0e385755b2c10b2e7ad265c9274a2bd333a7823b7a187f3deaf802bcb4c97d3022d6041893ba9fa1b613e69b627d8f9f0706e964572df680de20eda6b961006ab213ff12ac7e1f8b4ee094f0747d5efa62c641ea3c6995b8ae048c47158043b5efe1d8c5b253fd89632e79099723e03f52050bb10bf0003d180c4b24861c488de25c9abe234dd08ba0e9ade1e81fc7822a96853cb2892ed0e34113a0ab158ec0a91fde8c012497d6a319e11fffcdc5cc953bc54105eced989e968e6034a76d7cea7f911deac0b21faecef2fd99191c2ba8d7f30e59c1aaa17f9c2e235568dc814c5fb6ae6a52b6387c8a7bd02df4a9ffb0ed870e495a3db986c7c2e1d8ee5f08a2780ccd9dce1a6b97ec29946b0fc0cf9f14b5965fbe48ef874d658ab854eaa1905570fc7cfe8bc2638297f2418e5162f6821fc3fc9384d106fb733d931a3185a35d6df11683be565b4ce74359d974099395a1dafe1388b1fabeb1b05b3c648be80fa1f12797605764b1891eeefa6b5126f1d32398a93987ce837166966b3a203c8f39639b5796ca861791932b8bd53e1d01cfbebc3becee7104db07a3f61ad8a209878d5195dc7f0328452dd8cba8cc66a5007188f00a347338e52e93e80cdfb6766d9413c4cddb2a044e9ebf1e66ae42d0202283a1c25dbe7dc5e363cca45e61bee2e08e9d1d3f424995aecc59f3c19c395cbc3c9635638d764eb0f4b1c76867783c38f5ac13dbfedb968d643d7788aa94ed8c8e2bdc3c84eabad92da00dbe1ea10f6ae86753cfdd6f27ea1f2124f71d91560f98e8eebe284254ad0016eaa0d49a33e59f3f998b9dadab656dd345b92480cca71c7af9596978b9ca1cac63d74dbf0d9428bb9b6774225a2a351285c2dc58855f3d54e3e781b34b3fa0b1240edfaec47c54983d21dc5b00c1861c17ffee130e95a7e2c9ddc15425894cc16e77b44915bdcfe1ab77387f7b223e0e10982d1ad0c6d3b94a788381194c48cfc0d55ad5e3c856d7d81c842ca182a0ba00716a143fd86989d6555836e878ca29dd87c144e190627dadc5cbaba7a6964094f2d422cbc3a5975c8ad0e411f258abab9c7757922653dbe27f5c0fb3a6d0a5c27ffa18fe37b16d806cca1013a1d4e8c7a2f4c1a1d27daac744f9e9d73de2f7790fb6443f7df49a9a8e5fa520bcb285ae23b16fb8e2f8676ba1dd8081fb209f6e49a33c8b19624d1cd3ea4e6ee639393865235772df2a06801a6d5d079f07abce21554e18c9ba5c460bedad378a289c3c937a4314f63a79e426048aecec96a21add0c9f9fed98302b3658531139ebc14d6f570d32b81653451e81bf71fb124f489a28bdb222d96b6344f43886c05808a4b1f5a61e6c91769f381e9400f50d6ea6f0efa90571c86c07026748956441d1b0aa9c2d4208a7b6d1c57c8dccd798d11ba3775a2d634174a6835d164697382641382bca5fd061ee5a7d6bf1c711435ef5dbbe0a3f46dfdd28d14bf1d2b73bb4a2859ac59da15900cc730de20043c8f4e31a3227d4db7daa01b757ff4ba9be80772775586506626c61f40bae7993964fdf7224ddafe6e242fd935539439ab0efc180f8ed28aed39d10ba21c1c3974d955e83912f423769e370cd8b35814b9c071be83cca62b76a0c4cbe9d76a22b169c1e3e4c8f9099f5ad5900e5114c551ed5f3a308d47cad94df30853ac8e7f961470cfc40c8cf62acbd48f2c130e187bde77f5df4af426eb2ea890550b835b5873f977eaa9c753031e9e6e17927521c67e8165bfd7833ddba6ebb431a5de56fe170bbe39a9b9cd432169c65775818991d68c8faec2ade978fb3259a28d9fc13fe9ba368f43e3f23c360b7571c7c043ab7d41311a25df63414930f22627137bc8d3d7a5b1f3ff624c88ecee1e764aedf813ef9274bc8a11514d9e01eb49330d89f00006ec4947cf8c5f24231045b6f11a58a6d2657720139e8217d1a5347b2eb20e57b1c797f77d06ca72513a0361b970871b22a0b89b6f7bae11c91a27a6ca4c7ae11ac50d2aba70d1baa8b22d9a8f561ad17c980880ba428cbfedc075858466f22c324242e0fecdf645ac2d6490112d7185f83f0f6e014da6aacf796bf59e0ecf7d554cb185fe6c0308387190853b5598a2e2cf7608983ade1cecdaa851968a785ee81405470a9978f7c6dea04d9ca2fcbe04e522eb4dd00154bbf4e1a7f5cbb755d0196e355a78ef682d741de6b141f7d44e5705c8657a56ce9e756520f6c97b1cebb975c8cba43f0f340dd339048084a490dd159d2f5ed226dea337248dc418e83d8ca80edd32ec8807ded14d5b43ee0395841d36282506bd6dfe9b40e592e0055a8e505d4b9470c2dd00b9fbe12f08c7954a9cdcf861c060a4803b87e9e5eaf2d70387bd776833271471a4c48ab0a7f8b83541e7fc6277f2c6aff4932ad70c64df2688e082f57c1eefa1299439ab71e9c2c8f84b78839df7207a1c832b32e5e81f7386a4cf17cc70b9ae6a00958aeea757c79f1c9aebccc9797a1a2cd235f9dff5357dc1abf37daa178edaa8e7df72801c3ac02fc07c99cafabbcbc437e3494343b3b97bcf413fccd995769371e8b037a2167773fd3f519dbe0311433066f1d1f20a282ae7f25179aab5438b4910a3e16e57ca89f2bb321674f83b3e585275c30d91ffafc1f44352a0f67263ae4b5e2db4f2396a9f01841ea0016e9367ecaf41ca13f2b8dc41e6403aa51876f58f6c70717494074e92dbe0d0c5ef515a77b6b83e19dd0717e028682648537bbc9f3ba60b7fc73e396576daff4b2ded3019c17a5c120e8ad1c02bd806aa88cf065531026b4830a86f43a8e4df8b4c149b7979d6f416c3b40a888629d8213fb7fbb38256c3fbe71823ec33be98a548855dc4affefc8b3eefa8638ec5c0603ec28aff3887a0b23ba77c77adb144622947f8312b606ee37c0d26991adc00d0ebe430d0bf4f22be7debf1d19710fee7d5018b4446dc7f61d2143d544311efc2202c7fc047d7ddc8f866d5950f03d6d7128240552dc52ec53697b302d013bc264e86e8fac2a619e3b09d8c2a0897e82ead33d82dfa2a2f89416a3fd0db1672c49c38d7ae0e9f90c91296e7a234fed97386ef9c9dfd63d762c0496363a026f4cadcb3ba7af822cdcf3e1d73014e465850fd7dd2fc6670ec0f19b2adf4ccdc094fbb43f2c150a491d8c8efb7aaebc956e049b36dad90aff9d4cfe21600b70a9be82bf044e509821a526d57fc1528eabcf87d863ea8900d64d5ea467a4ab1d6212c5014614854c5af316cb99d7e28f9eb414b6ec7f37f5924a510bd2d391fd4312beaadfb0874ccac5f80a8d5f7e6c5aab31369e9a7182118a5c8de9c1a4bc50674219da115dbe22c528632679cf50cd85860643852d563b0134c82e2fbb20af578cb840f07f499c924e953a5816adfae9bad4c31ddc8dc08a1a449692908506cb96d1615e2523fe12b48809f867b91a7000351ccfbae02877011ffc787258e517690e65eb11fbcc65c2bd47c943f4651d09c24284402e2ed5a16db557218bba79013fc2508d7ed733f8de30c79596aaedb1f0253ea281cf568b9eab76798c88d3c56fa6aafa2625f57a1502d190efbf0f52d9a0d1e47cd87717242ffc0458e9b9783903074364633a3d31fd62397ae3ba3d8d6da9eaa8133ee7be7557b0d91be10f5208f2dffcf3a75bb69b2789b065c370f2d9b1278990808e8eea900c269aaa937ac209fd8eea896e0bbae7c91eecd0ebd772f5d36119f74f64f064539081611bb40b1253a1c1d0fc617a9a52c9e9e9020a8b40ba0f514f54948380193f5a4dd3c035a9830ac8529c5111a0c54511348313f5844c51c5e50630e8b36d53bedf29095c77f730793b60db97096d62dea5c6f2070cdc86bd6ea35e52ae6c9201b95b17455d1f3c47f3af15bdb99aedf49a1ecbedf08d4d7f2b5fbf2b30b8048b0820e3032e4bdf3f10eb0b92afb3ebf7e8903a4744fa7d7ea25118ff37ce9b1eb2bd611952f495f0993e874da765ac70a69d31f20c50ef9d467550d5164632529c38d1d71a1de8bdfe86d14bc2358cbbbab1907585f7c246db6326fdee48f7b1039d05f6a01a0f43c2de98ee7a750205c707c37f9a373b4dcec7da249740333dc5e482b7de6e5d3c801f7290758fdf5d07fdbd61589f627e94a139b3f359d426a032a2594978af16aa03f790a682503753eb49beb7e9db1712dc0af2ae360ba75b8e2174d944e7be6e6b33b98adeb182a21437fd6f1d1636cb67fb69dcd599faba43d0fa47dbd6ce3402260693ca5e280e0e0627ddd00c61c343f85c959a7c2d9766d0923ffb2765c491ba3e2153d19ad08ffdcf43565952b6bf7f6fba2e537bef30c571bb22bbd527035d4d49e1ecaf993fa2797683aec463a703bc1eca0bf41f128d5c6ae2011d09d2ab4c6cf042d50aeb649dd0c3bf255f2e402cc9ea0a25db176454435b3c28421be1459ba7a415ea2ca768523cbd11d620995c4e91cbadfc39ebb58a9d1997420c33b2dd2dfd030d7cdcae4e7f29cd2a4be34df124d25f16b8eccfa3856eede24be3f4806eb380280abf04fe890a0086d1603daab97f90cf2eef269e93a7022159c2b07687808cdd762d27644b22639c0a554d069f332400e0d399a641140dc2a4435f2a758326237ff37a5b1c72757b9a2b4b1e7d0d53ea2101ca19cea3a503a287805dfe8a1831a1152442347ddce85dacfdaae30e82a453962221bdb5d6f47fde02ece5d91bd95fbbc53efc5caf75fb436572f17c89f3e58bfafe87ba18d89a7806cffaf07ed283efc00983441b0f9770173418952fee85b12a25d968881719e5b9e54e4902166b6b4d83ee7c93bddb6a3c521699427dccda4322083233cf2f48982a41653ea4d9e133425eacf88f01fc5a06b8f2858d7286cc1ed8ad5425a4543d38a7f43daa60c7276b5da51b045136401675a8447a31d70ee34be995b5be6f6da77a0792674bb4cb98d8d1b434e420b6e4482d7816327c996bcad1e06485b0cd1b752497080772f9cd30c72eb9d9d72c04da7fd3baf251400e914e1dabafbd172d83f56cc0925f94d3546eda328df9375a0f709959891b0677d945c45bda8448585375e574ed3a9c57492cd054bfa6c4d7e496babf265118ea72436453cb08d05b64eb18ff020f7ca7c2f97ae4d3233a2739f53e4b2f8b3501ceeec97afddeda316569c99076aa1c26287495a931e162bef0236a9cb0e280109e0e92020c6919bc5b98169a292e4093a1f53bd91741a61df8478ff1329dde5c794a90f1ee6d600f94ba20751fdeb6d4b4ed5193d8491d4f6e769811cf3c7c99b261f74508e9752c4507c558c780b92683b68125f6ffe298387a24447b586630b6367dddcb4a74ca3fefd568bf26f9c341448997674095e516c3d8cba1a5ecb7e20a751b5eb3d713e05fa0f3e68e3f93deb12f5ed4c8bece17f0113489a5f3df03625ab44a69d32f0764adeeda5a10da77a953e162a8b6c1a1cf49077e57cf4a709d351695385468fff09665c1c34db725e0f44fa2b5cc9717cc81b1ce6525e996dd80344dd6e069904e141e029e0d65090bd5d725e83a954c2b291bc65dc00714533c85859bfc2d8ac5919748e65409ecb9f9a1280280aedd72b387a2b99d99ce596dc5f503c4048135a42d08732af041fb8cf371213468ec731eb42861a8d4b7f81488d49cb4295660e8fd7fffd3be2f93ddfa7f23b38ee14d3b90456d7f51551b043c7a024493664a4b1d8e324bd7a898d1a8cf2e0e3ed6beaae9d086e903b515888b7d28674b6bb9115cb29151bd1a6242fc9b8fa4a53f84c7faa8daf7b9023596e3486c5ab5dfd5d90527d10a396e7b057541cb42a83cdb80059b1f08cc82eb0d55d3878856472df8cb4db42b1d26c8678388e69caf677221ee96bc5cab51484282c2a62d075d32dffdfb08de6a8b55b28ebe1c1526e8b2a3dd6072e91345403205cb8d5084cc4e0aa5186b3cee3a5e0fb90a85d2c18aeb8ed4591c856ea89d6559c7cbcf059348dd41ccc324238a27cc5d4bc557f7e3555a54f0909e81e6689568e08506a0037ddaa15f1e833990a184500cf03d63c65a34410acc49e2772c674e2967c0b95abb4c96bb9e587bd27f37c28a29c209c74642ee4c2544df9ac9721674807e86b906ad980fc17474f9a8bec2df4e7f62a023aa3dbbc0e262498a3b4dad4cb042294b36ca3ec674ba6b26d0ce920a9a90e584290e42a4d4f14a4e0eb308434b7147aaeafd03d7ced3d27350a025f84894cd82a90298b1c188b6d741f7489e9c1a22ce0217d857cb445c5ed7c4ce6105d3767a12287489c291b2bde8536848bee48d0b8a00848b7e7cab19b6121662741a2eb67ab366cd813f8b37bf598eca255f62bba852ca0f7ff2f564faffe6ba48ce97fd41c42b74e9f9fc8eaa57d6929a82775fd49b258213cafdc6d45323fcbd8337b48527c45f203f296d721b167bc2bf433c2b20bb5ddfac7d63527898f8a9c21ee593d5f76d2e6985b18d3c85ca81306099c19e981881dfb9a80b797f7280e180bc9f3f5e9c67c6f66202bec40429145f1b4faa29cab834a966ec7649694c4a3a17fe65fa60f5d0b793bdaa6fa658343614148393b3420ecde9321e977b99d238b581c026839812e1f88843232db64811fc2e30f9a4975f4bb5c3a90de83924176ccefadbab4aae83fd3c79f0de8474685574cdfacd4bf37170b9f4ed0376f22e1daa1bba48efd3b3af78d1208b8a5d74d8c0e3e707797782f2155aa82d6393f51b25fe178db851a002d0fbbefed0d6285734aa52e7d36a5f75689d59aa98ba7445e6a14294240586658b9054b8e5edb99a84eb2743473f274d723ea9db61725e9fbae57e3e61f10958829e95a9e18ca653e7a3a8f6fd82b666ad70f49d7a3b64785fc7708b41109f461877697900cce2eb94af0410fb0be194c48c9aac4a9c14e787b0bfee38f601facb6185cdfd4ecb1c5b121883ce1cea22584cc9ffc3e6eb1caa0d7aa8e12c0c031ceb5b709b03ee0589baad1541f455ec1c44cda36c8786a44c452b45f871acb1ca29e7914ccf2f20af6255df3b3f56cf37a279719fd68c29ba98ac609bfe39bad3fb79d8759251c6612cd9cabceeb3b54e1019a3a7ed350eb2ac13b07ada15eabaa7b0b6aabbafc8a2c0181f4fb4ddc1727b26910a4c85db95c7bdd15b928d8ee1e22379a32a5cf476912b75555861f077eda69742e9557c8d52fdd467d1730b89bd4fd41badb00fb9d63ee748e1d163daecc1aa5ca01d6401d31c28adcf8778d693dedc585fc258b9b5ee51a407d2f8c5125cedeb79f560b31da82919d870ba34bb53202083fba09e1132bd650d03082a4fb2c32a2e71438ca5ecaee4f6959d2d3f936eff02262629a42789e95dc2e8596a882003ef3ec3369565bae9eff786525760edb43b184fcf5ba688cda97cd38aaf2e44cfbc37951aa5c68783e1bc2c328f499273751fb40e7ed64b0356a192c6fc358f9a7d8a0a7daffc47bf31c2ce03a59d5ec236fb27c8f5090960889e104109efe71ea7d1bebf1f6dcc1f7cf32142250f58fbd5bbba8ad5fb534a04915a6f3e2a0d6dceb5f146ff67ca43d80c2041155bf97af93f6fe160fb893f714b1b4bb33c43ae5e5ad2e121baf0eb6341b4ba4e8490234c95f836a585d004b06ffe2e0d9c27568e223910c7bf9ae0936b819049767def4dfac038f50207b8bc0f5f4369c4c6702ef88695d8d6122f68d3ae8cdf301dfcf6c6b082b5b88cff71eba7af4c9bcd029896fa2897798700b92c7d1e07cb3b3d773405185b7eff1ca70f19aa30734d6f50263ca52a83f3ce674f06c03057059c048ea8b8a3e4627765b46c06daca318260e747f135c51f1705ca7700bd930af3f19468505ad2a2154f8a48533ff7fd69d7705d41c41fa7d766cdc4299a42a74b89666aaae5800d276df667c432c850adfa6c8c167a37383af34491e3aed2478800c29f80d4c366d73a46cc92a2e7f119a388606e90914ccef9ef14704b947f4dfc05da33fc2406a3e077008fcf55c66aaac23dc9931e02a31ab1184ecc09b47d95b333bf9d0fb8cee4bd598a039c579717b92a229838bc396b4e5809ae16be5f0f77905dccedf3b241357ee53e85d5bfeef89cb0955678baae74ea60fecf53012c5bd3508a8b48639cfcf7b3eaf85901101b12bebab553d8534cb7dafc976684679879494df8b62300d4cf10b79b7fa2bec8746d137b157c3b88aac22966ec01dcf5f359729d2351e68185b5d71692486f8adc1f053b8d2e0dff8ce49e62ce617595867232f63fcd5c2438f383d90cb6e1e46f375e766b868d46ec7ae5fad55239ad03895bb05e10c305afdd38ec1f0f6768cf267de5a90e37ac66913f862bd238b0f248682a240f67fd676e8ddb7587eb740259695e9aaa212e403389d175d32641cc28bef44fccd69275cf04f6a44edfccdebe3b067311661feb098c8ae9ec529f1ec4d7150c1ab66236ccf618695cd9c0aee6b9c9d3008e10cd9e12d08127c795358fdf1b9d5e53312a5af807782514754926549e29692f3f513d5622f61a2a890432a333c2588aa9275c17641536577761112e7b32e985c04512dd88a6efe61187e32492e947bdee4872087f0e412707f4d13ebd81b30c0f5146e3c1164edb0661ebe111c272efcf7ca79fffdbbacefec681644c08fda9ea3045cec04b8e8e51692600d1e238909697af6abcbff902bbb4472696a825ae6bd40f9e791cd31bbec6356933d5867b2022d1bf5d10eca9a6c6dbda114fc1408389c082d2a6e8a6dc475ee6c2e08011e93b9c3753b3a44321b3984e51eeb4513dbcb3d5d106f828ded235cfc503ea895ea8b43b525785bcc02908b37d04a40e1b46e5fbe0ff80f7782eab7e110155cb9daac8aab1f99d1e55a6f4b7785c5e3bc26f8e718429818e55ea4537a2f86d112bf8452e580c55be15b3938a43bdc3a55a78c91aa3c250563b351eab36e9f9078029e2f869f92d5b9f513a8aa9c23f0c51f716c569d35f4af6ed67265dfe74a79b96b5f6d00a407d4d830570d1cc869a514d21185ff4c31a5ea46ccc3cba495ea515ddb1de7dccd5b57dec270277349b26a15da6b3228170b2c654f9182b9801538c3a94979a5ecd71a38d1de22a993ac163654e493d03bea6197664ed58121488291cce1c79924ffb6807b0cd8b136d3d8292e8e23d6932d22ffcc294c4138ca72a01543c24a379aaa8d8fffb88ece6deddcb5b46b873020da72da57f797849798c5d36a2582ddd4a202f44822dcaff04836096c9d23271fb08a348cb9025e891429b6a8ad5d0f807cccfd8fc94eb562a995fcc1e9a3070ca6d9889fef0fc3b7913d9aef0d39b4460a23e2f1db07bca196238fce189d5aa849f57833e7373539ddf9b3790f0fff889d0ce659e867237a58512d0a6026abd6ca9de5455e34e4d61d21e4627b235f501f2a1a304287411c356b50131b8a926998243c6636874107e1bbda62fd5fcbdd7a2082fa6fe015e12541de904056c1d484ceb2e627a92381751f3baa20aa8912a838890305d261e63a8695e4db23ea246e1d273b3b532cb6fdb81c9bb3da7a42f053a306131734471b872d68c2a8bbf6d9d8a28a3403fc5a7dabf84236b2730a8c546e6dcfdc4c35a5262a308d20f35a0de959053338672b5ff98c79bdfa149fbdcb5c0a628d1d8088c925e83f04b63e0bc66fcc7d8782d04e2883149039bbe2b76c2897e37c4f25dc499741c5ed1458bff525b80251e1f229093febe836f9e9401cf37de52f7159a3db97ed90ef9f0a2a371f7d811ce3555a3b4b40c6153a698305630ae757969289c8662a07a27f1b5ccf3da879a51d193a5640f005f95ccceacbcc1098821a5367883fd3c6ee18abb9fce4534d61a771781f26a6427f3a6575edec18b480b8928fbe4f796960a9cda98919a861545ff8d73111e47f3487af8eb19c2ca392772dba786b58232d82b5ae2ccbcfbdffa6c4e444ba1331b179d559197348a031feb41e306fcf4258efbd5be6b1f9a57f2fd0edbe2750b8e2d2807c740d3dc6c57793a1696c24be697e1b586e9a3a3eed6f17bf84d86e779e31d15590c658dc62d94209d321f90a2a5f0f31f3736ff6d9a3a39ebb4c354f2291785c49fee8d6005fa741e5e6899620c78fc86bacee256e689b9b668a372662ad383ac5d64e4e592400232a580189317ebed781cd8d81e82cf3ca25631a30377633f8a51ab03ec4ab9722424313bc9250c50aec0c59172ad0664e6bdc2c7abc502754fd826b189f7cf6a7e5efa84247598fc05cafb82ca115c0a0c15659088768c0cd84b8d1ca9b9e7acf8eebe853fd7e1d68f8214085350e93f64883dfe1db641fe1cf2c06946a48446a0a827f86b697913f431c595585d101ac0b00613fbf5be287df81f04c8b1939c0ef5223ddb7c7ef4e56e3a679fdda998b9728ddabbfae9b6a570377510e334bcc14ed11a507519327cbbe8714778539609e4ab49cc4415defdf85f51fdbcf1fd0e5ef20473d3e5acc7d51b986d4ec9e7ca6e376300e630e63b57dd7b7f538f9a0f49b14f5975988028cf9de467277de600d10ba529b1f959340865fdb450083f9d5d7ca52373cf56219b32e287b341b04cd8f87178115da20e752d28990d3b4a77698064121778f77ebbf708bf455138f14fc96ca1a910a2191cfc4ede4eac88ce43abedbfffbf4dc18d51dfa42e2b68c5d132b5ad537f278d3d38765b5803243f4932037b11a3574705555ee84ce0b3a56cc4cdb92d142c3c2cba54df8977e6d65faf8850cd71fcbac10154285bec702661d61909579aa9101e5bc33f80e20029d159eda938ac42d93a7566b41e046d6a84e175d2f7737d61313c52aa41ea0126848f6fb06fd04196c140913177812e0565d54bb185f79977c301c091494a37719bf0b67729fdebcb72ca57aec73adf5023318644dbd11702302c31f2d1c42a3c6d3e0b098a6513016fa569bd832e835049fedc3a9bfbb4095c098fb7757d1cc7508e120b2a014a074d38c22b4cff2ed8480969bde578c030b0fb03ea8e8911b3897ff1efbd65a6b5a61e48ce7d1bfb49c844bedf92a629f5faa0faab2d814fad3fa2f6ed2f808a5148b1a86304522c756069d35d55510f32f0156718d4a7b63fb8caff02e86744c9a0fb0f8a1ea261c1bea64f4ba06ad1038a95bcdebb64d10bf507fc20c9a07422d04ee3378cf27a7067c54a3d46c29b238461663216070dcc7e72fdf465710d6e022bdf332ccc6da195c12471d5569d8988a6dc1c179ef74820f49a55dc2901e9e54e1bcccfad7ab14f2ac06aa495ceaf5545b90228b5bcd059fdb81dc859052c434e91139374088ce527147d1b2e27c67f7bf157c0a61af94c82121a51f627581d77dc6fe12ebe60a6fd4c707a69c9e71c20708a12fe848efbdff56ca9b76fb8e0cc71afc9f5e9cf09467fac09da365e2ef7c266a56a6081711c43b6720c7033dcee23ef421d9dc3717f9816394a462445cb435edc0c6e24b3766d17f0349d34e24f3671f916f2c58f3f335159910db5b137d3da4db0fd80ad1a04a4baf5ec910199570fb140d2c87a12c40a338b21f9c0e9b6aa14244009dedf84a0cd0da38da567448e339dc9ab50634cfe12f0b85a3ea33ac34ddb2d9c97c6b9303f1eb105f2206c241750f8ed708b457bac5fe8b32a90d3ab02b60c34b280671cf27af661cc4fa426b995338bb665d67217efabff87cd84bbcf7c12ea0871c954ecc3b3e40f320819a50f26658d3d06392338937d81e3f4ab062c39519f66464646e6145cb3a6aef8519b10ec5a3d8c6692b59974931cb7a460ed27b5b8ec1c7f20c50bdefd19df7804f05a076449094a01eb66eaa57e90b94bdb7031b7bc82343d02eafd27751d3488866c79b5c15efdd9af110e143aa45a18488b5d93230eb98498f30686cbfe01a5e2350fca55bf4509ab7309cfd46c1ece37092b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码拿来</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL笔记</title>
    <url>/2021/11/08/MYSQL%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="MYSQL常用命令"><a href="#MYSQL常用命令" class="headerlink" title="MYSQL常用命令"></a>MYSQL常用命令</h3><p>1.启用/暂停/退出MYSQL服务：启用——&gt;net start mysql80(最后的是本机的mysql 服务名称)//必须要以管理员身份运行命令行cmd，本机已经设置cmd默认管理员身份运行。</p>
<span id="more"></span>

<p>​                                                      暂停——&gt;net stop mysql80</p>
<p>​                                                      退出——&gt;exit                            </p>
<p>2.查看有哪些数据库：show databases;(注意mysql命令以英文的分号;结尾)</p>
<p>3.使用某个具体数据库：use 数据库名;</p>
<p>4.创建一个新的数据库：create database 新数库名;</p>
<p>5.查看某个数据库下有哪些表：show tables;</p>
<p>6.登录mysql： win+R cmd 后  mysql -uroot -p 然后输入密码就可以了。</p>
<p>7.导入数据：source 路径名（路径中不要有中文）//没有分号</p>
<p>8.查看表的所有数据：select     *     from     表名;（*代表所有） </p>
<p>9.查看表的结构：desc     表名;（desc是describe的缩写）</p>
<p>10.查看MYSQL版本号：select version();</p>
<p>11.查看当前使用的数据库：select database();</p>
<p>12.终止命令的输入:\c或者;(英文)（使用；会执行之前写的所有语句，而\c直接结束这条命令的输入，之前的输入无效。</p>
<hr>
<h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><p>DQL:</p>
<p>数据查询语言（凡是带有select关键字的都是查询语句）</p>
<p>select…</p>
<p>DML:</p>
<p>数据操作语言（凡是对表当中的数据进行增删改都是DML）</p>
<p>insert     delete        update </p>
<p>insert增</p>
<p>delete删</p>
<p>update改</p>
<p>DDL:</p>
<p>数据定义语言（凡是带有create，drop，alter的都是DDL）</p>
<p>DDL主要是操作表的结构，不是表中的数据</p>
<p>create：新建</p>
<p>drop：删除</p>
<p>alter：修改</p>
<p>TCL:</p>
<p>事务控制语言</p>
<p>包括：</p>
<p>​    事务提交：commit；</p>
<p>​    事务回滚：rollback；</p>
<p>DCL:</p>
<p>是数据控制语言</p>
<p>例如：授权grant、撤销权限revoke…</p>
<hr>
<h3 id="导入数据-amp-查看表的数据或结构"><a href="#导入数据-amp-查看表的数据或结构" class="headerlink" title="导入数据&amp;查看表的数据或结构"></a>导入数据&amp;查看表的数据或结构</h3><p>首先要有一个sql文件</p>
<p>导入命令：source 路径名（路径中不要有中文）</p>
<p>查看表的数据：select * from 表名;</p>
<p>查看表的结构：desc     表名;（desc是describe的缩写）</p>
<hr>
<h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p>查询字段要注意：    </p>
<p>1.查询一个字段：select  字段名 from 表名;</p>
<p>​                select和from都是关键字。</p>
<p>​                字段名和表名都是标识符。</p>
<p>​            强调：</p>
<p>​                对于SQL语句来说都是通用的，</p>
<p>​                所有的SQL语句以”;”结尾。</p>
<p>​                另外SQL语句不区分大小写。</p>
<p>2.查询两个字段：用逗号“,“隔开；注意要用英文</p>
<p>select  字段名1,字段名2 from 表名;</p>
<p>3.查询所有字段：</p>
<p>​                            方式1：用13.2把 所有字段一个个写上；</p>
<p>​                            方式2：select  * from 表名;</p>
<p>注意：方式2的效率低且可读性差。在实际开发中不建议写，可以自己玩，在dos命令窗口中想快速看一看全表数据可以使用这种方式。</p>
<hr>
<h3 id="给查询的列起别名"><a href="#给查询的列起别名" class="headerlink" title="给查询的列起别名"></a>给查询的列起别名</h3><p>select 列名 as 别名 from 表名；</p>
<p>结论：字段可以参加数学运算</p>
<p>注意：</p>
<p>1.当别名里面没有空格时，可以把as省略，变成空格。select 列名 别名 from 表名；</p>
<p>2.有别名空格时可以用单引号或者双引号（不标准）括起来；//单引号是标准，一般数据库所有字符串都用单引号括起来。</p>
<p>3.别名是中文的时候也要用单引号括起来；</p>
<p>4.注意这里的起别名只是查询显示时，起别名的项变成你改的样子，在数据库里面列名并没有被更改.</p>
<p>select不会改变数据库里面的内容；</p>
<hr>
<h3 id="列参与数学运算"><a href="#列参与数学运算" class="headerlink" title="列参与数学运算"></a>列参与数学运算</h3><p>select 列名*12（数学运算式可以按照要求自己写，这时显示的列名会变成类名乘以12，如果觉得不好看可以用as起别名） from 表名；</p>
<hr>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>查询符合条件的数据。</p>
<p>1.语法格式： </p>
<p>select</p>
<p>​        字段1，字段2，字段3…</p>
<p>from</p>
<p>​        表名</p>
<p>where</p>
<p>​        条件；</p>
<p>2.条件有：</p>
<p>=    等于</p>
<p>&lt;&gt;或！=不等于</p>
<p>&lt;,&gt;大于和小于；&lt;=,&gt;=小于等于和大于等于；</p>
<p>between…and…两个值之间，等同于 &gt;= and &lt;= ；注意：必须遵循左小右大；是闭区间；</p>
<p>is null 为空（is not null 不为空）注：数据库里的null不能用=衡量，只能用is</p>
<p>and并且</p>
<p>or或者</p>
<p>in包含，相当于多个or（not in 不在这个范围之中）//in后面跟的是具体的值，不是区间。例子：num in（800,5000）找出num为800和5000的num，不是找800-5000之间的所有的num。</p>
<p>not  可以取非，主要用在is或in中</p>
<p>like 称为模糊查询，支持%或下划线匹配查找特殊字符入_时会导致歧义，这时候可以使用转义子父来查询。</p>
<p>%匹配任意多个字符</p>
<p>下划线，一个下划线只匹配任意一个字符</p>
<p>注意：条件之间有优先级关系，注意使用括号。</p>
<hr>
<h3 id="查询排序"><a href="#查询排序" class="headerlink" title="查询排序"></a>查询排序</h3><p>格式：</p>
<p>select 列名 from 表名 order by 排序条件列；默认升序查询</p>
<p>select 列名 from 表名 order by 排序条件列 asc；指定升序查询</p>
<p>select 列名 from 表名 order by 排序条件列 desc；指定降序查询</p>
<p>注意：关键字的顺序不能改变</p>
<p>select    …    from    …    where    …    group by     …    order by    …</p>
<p>执行顺序：</p>
<p>第一步    from</p>
<p>第二步    where</p>
<p>第三步    group by</p>
<p>第四步    having（必配合group by使用）</p>
<p>第五步     select</p>
<p>第六步     order by（排序总在最后执行！）</p>
<p>（因为group by 在where后面，而分组函数使用前必须进行分组，所以where子句中不可以使用分组函数）</p>
<p>按多个字段排序：</p>
<p>select 列名 form 表名 order by 排序条件1 排序升降序，排序条件2 排序升降序；</p>
<p>注意：这里的排序主要是按照排序条件1的顺序来排，当两项的排序条件1相同时才使用排序条件2比较排出二者顺序。</p>
<p>按照字段的顺序来排</p>
<p>select 列名 form 表名 order by 列数；（按表中的第二列来排）</p>
<p>不建议使用，因为不健壮，列的顺序很容易发生改变。</p>
<p>注：select后面可以跟某个字段名（看做变量）或者字面量/字面值</p>
<hr>
<h3 id="单行处理函数"><a href="#单行处理函数" class="headerlink" title="单行处理函数"></a>单行处理函数</h3><p>概述：数据处理函数又被称为单行处理函数。</p>
<p>单行处理函数的特点：一个输入对应一个输出。</p>
<p>和单行处理函数对应的是多行处理函数：多个输入对应一个输出。</p>
<p>常见的单行处理函数：</p>
<p>sum()    求和函数</p>
<p>lower()     转换小写</p>
<p>upper()    转换大写</p>
<p>substr()    取子串//起始下标是1select substr(ename,1,1);从第一个字母开始截取，截取的长度为1；</p>
<p>concat()    字符串拼接</p>
<p>length()    取字符串长度</p>
<p>trim()    去除字符串中的空格</p>
<p>str_to_date()     将字符串转换成日期</p>
<p>概述：将字符串varchar转换成date类型，通常使用在insert后面</p>
<p>格式：str_to_date(‘字符串日期’,    ‘日期格式’)</p>
<p>mysql的日期格式（将你写的字符串日期格式里的对应数字换成下面的符号就得到了你的日期格式）</p>
<p>%Y    年</p>
<p>%m    月</p>
<p>%d    日</p>
<p>%h    时</p>
<p>%i    分</p>
<p>%s    秒    </p>
<p>注意：如果你提供的日期格式是%Y-%m-%d，那么就不用str_to_date()了，mysql会自动把字符串转换成date。</p>
<p>date_format(date类型数据,    ‘日期格式’)    格式化日期，date转换成字符串</p>
<p>概述：这个函数通常使用在查询日期方面，设置展示的日期</p>
<p>注意：当你不用date_format(date类型数据,    ‘日期格式’)函数时，select后的date类型数据会自动转换成varchar类型，并且固定展示成’%Y-%m-%d’</p>
<p>format(数字，格式‘$999,999’)    设置千分位</p>
<p>round(num,保留小数位数)    四舍五入//如果是负数就是继续往左边四舍五入个，十，百，千，万。。。</p>
<p>rand()    生成0-1内的随机数</p>
<p>ifnull(数据，代替值)    空处理函数，当数据为NULL时，数据就会被代替值代替//注意在数据库中，只要有NULL参与的数学运算式，其结果就是NULL，但分组函数自动忽略NULL；</p>
<p>case…when…then …when…then …else …end</p>
<p>注：改变表中的数据大小都是在select后面直接写的，不在其他地方写。（但只是改变显示的大小，不改变数据库中真实的数据）</p>
<hr>
<h3 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h3><p>概述：又称多行处理函数，特点是输入多行，输出一个最终结果；</p>
<p>一共有5个：</p>
<p>​    count()    计数</p>
<p>​    sum()    求和</p>
<p>​    avg()    求平均值</p>
<p>​    max()    求最大值</p>
<p>​    min()    求最小值</p>
<p>注:</p>
<p>1.分组函数在使用前必须先对数据进行分组，然后才能使用；如果没有对数据进行分组，就默认整张表是一组。</p>
<p>2.分组函数会自动忽略null；</p>
<p>3.count(具体字段)：表示统计该字段下所有不为NULL的元素的总数</p>
<p>   count(*)：统计表中的总行数（只要有一行数据就count++，并且数据库中不存在一行记录全为null）</p>
<p>4.分组函数不能直接使用在where子句中//解释在上面</p>
<p>5.所有的分组函数可以组合起来使用</p>
<p>​    </p>
<hr>
<h3 id="分组查询-非常重要，五颗星"><a href="#分组查询-非常重要，五颗星" class="headerlink" title="分组查询(非常重要，五颗星)"></a>分组查询(非常重要，五颗星)</h3><p>概述：在实际应用中，需要先进行分组，然后对每一组的数据进行操作。这时候我们需要进行分组查询。</p>
<p>1.格式：</p>
<p>select    …    from    …    group by    …</p>
<p>2.重要结论：</p>
<p>在一条select语句当中，如果有group语句，select后面只能跟：参加分组的字段，以及分组函数。其他的一律不能跟！！！添加其他的没有实际意义而且在其他数据库里面可能会报错。</p>
<p>（mysql语法相对松散，编译时不会报错；oracle里面就会报错）</p>
<p>3.技巧：</p>
<p>1.多个字段合成一个字段来看（多个字段联合分组）</p>
<p>2.使用having 可以对分完组的数据进一步过滤。having不能单独使用，必须配合group by配合。</p>
<p>3.having不能代替where，二者有很大的区别。where的执行顺序在group by前，having执行顺序在group by后，因此分组函数可以在having字句中使用，不可以在where字句中使用。</p>
<p>4.优先策略：where和having，优先使用where，where实在完成不了的再选择having。因为用where筛选后，可以减少分组的工作量，提高运行效率。</p>
<p>执行顺序：</p>
<p>第一步    from</p>
<p>第二步    where</p>
<p>第三步    group by</p>
<p>第四步    having（必配合group by使用）</p>
<p>第五步     select</p>
<p>第六步     order by（排序总在最后执行！）</p>
<p>语言描述：先选择数据库中的某张表，先经过where条件筛选出有价值的数据。对这些有价值的数据进行分组，分组之后可以使用having继续筛选，select查询出来，最后排序输出</p>
<p>书写顺序：</p>
<p>select…    from    …    where    …    group by    …    having    …    order by    …    limit    ….</p>
<hr>
<h3 id="distinct关键字"><a href="#distinct关键字" class="headerlink" title="distinct关键字"></a>distinct关键字</h3><p>概述：查询结果中可能会出现重复的数据，此时需要使用distinct关键字。</p>
<p>注意：distinct关键字只能放在所有字段的最前方，表示去除后面的所有字段的重复数据。</p>
<hr>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>1.概述：从一张表中单独查询，称为单表查询。跨表查询，多张表联合起来查询数据，被称为连接查询。</p>
<p>2.分类：</p>
<p>根据年代分类：SQL92，SQL99（分别是1992年和1999年出现的语法）</p>
<p>根据表的连接方式分类：</p>
<p>内连接：等值连接，非等值连接，自连接。</p>
<p>外连接：左外连接（左连接），右外连接（右连接）</p>
<p>全连接：不讲</p>
<hr>
<h3 id="笛卡尔积现象"><a href="#笛卡尔积现象" class="headerlink" title="笛卡尔积现象"></a>笛卡尔积现象</h3><p>当两张表进行连接查询，没有任何条件限制时候，最终查询的条数，是两张表条数的乘积，这种现象被称为笛卡尔乘积。</p>
<p>避免方法：添加附加的连接条件</p>
<p>给表起别名可以提高匹配效率。</p>
<hr>
<h3 id="内连接之等值连接，非等值连接，自连接"><a href="#内连接之等值连接，非等值连接，自连接" class="headerlink" title="内连接之等值连接，非等值连接，自连接"></a>内连接之等值连接，非等值连接，自连接</h3><p>SQL92语法：select e.ename,d.dname from emp e,dept d where e.deptno=d.deptno;</p>
<p>SQL99语法：select e.ename,d.dname from emp e join dept d on e.deptno=d.deptno;</p>
<p>SQL99 优点:结构更清晰，表的连接条件和后期的where的筛选条件进行了区分。</p>
<p>SQL语法：</p>
<p>select </p>
<p>​    …</p>
<p>from</p>
<p>​    a</p>
<p>inner join    //inner可省略</p>
<p>​    b</p>
<p>on</p>
<p>​    a和b的连接条件//条件是等式就是等值连接，不是等式就是非等值连接，表内的查询就是自连接（一张表看成两张表）</p>
<p>where</p>
<p>​    筛选条件</p>
<p>内连接特点：把完全能够匹配表连接条件的数据查询出来</p>
<hr>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="外连接之右（外）连接"><a href="#外连接之右（外）连接" class="headerlink" title="外连接之右（外）连接"></a>外连接之右（外）连接</h4><p>格式：select 左表.字段1，右表.字段2… from 表A名 right（此处省略outer,写不写都可以） join 表B名 on 表连接条件。</p>
<p>right：表示join关键字右边的表是主表即被匹配表，左表是匹配表，查询出的结果要包含右表中的每一行，意思是把左表中的数据拿来和右表的每一行数据进行匹配，匹配成功就显示出来，若右表中的某一行和左表中的每一行都不匹配，此时左表.字段1显示NULL，右表.字段2正常显示。（若这种情况发生，在内连接时，两个表都不会显示</p>
<h4 id="外连接之左（外）连接"><a href="#外连接之左（外）连接" class="headerlink" title="外连接之左（外）连接"></a>外连接之左（外）连接</h4><p>格式：select 左表.字段1，右表.字段2… from 表A名 left （此处省略outer,写不写都可以）  join 表B名 on 表连接条件。</p>
<p>类比右连接，位置关系相反</p>
<p>注意：</p>
<p>1.在外连接中，表有主次关系，而内连接中没有。</p>
<p>2.左连接和右连接可以相互转换。</p>
<p>3.外连接的查询结果条数一定大于等于内连接的查询结果条数。</p>
<hr>
<h3 id="多张表的连接"><a href="#多张表的连接" class="headerlink" title="多张表的连接"></a>多张表的连接</h3><p>语法：</p>
<p>select …from     a     </p>
<p>join      b     on      a,b连接条件    </p>
<p>join     c    on    a,c连接条件</p>
<p>join    d    on    a,d连接条件；</p>
<p>注意：一条SQL语句中内连接和外连接可以混合使用。</p>
<hr>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>概述：select 语句中嵌套select语句，被嵌套的select语句称为子查询。</p>
<p>位置：</p>
<p>select</p>
<p>..(select ).</p>
<p>from</p>
<p>..(select).</p>
<p>where </p>
<p>..(select ).</p>
<h4 id="where中的子查询"><a href="#where中的子查询" class="headerlink" title="where中的子查询"></a>where中的子查询</h4><p>一般是利用子查询处理分组函数，得到结果当做where的筛选条件</p>
<h4 id="from子句的子查询"><a href="#from子句的子查询" class="headerlink" title="from子句的子查询"></a>from子句的子查询</h4><p>注：from后面的子查询，可以将子查询的查询结果当做临时表</p>
<h4 id="select后的子查询"><a href="#select后的子查询" class="headerlink" title="select后的子查询"></a>select后的子查询</h4><p>就是把where后面的的筛选条件改写到select后面，注意此时子查询一次返回的记录数目只能为1，不然会报错。</p>
<hr>
<h3 id="union合并查询结果集"><a href="#union合并查询结果集" class="headerlink" title="union合并查询结果集"></a>union合并查询结果集</h3><p>union的效率要高一些，对于表的连接来说，没连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。但union可以减少匹配次数，在减少匹配次数的情况下，还可以完成两个结果集的合并。union把乘法变成了加法，减少了连接次数。</p>
<p>格式：</p>
<p>select….(后面省略，是一个完整的查询语句)//注意此处没有分号，语句还没有写完</p>
<p>union</p>
<p>select…(后面省略，是另一个完整的查询语句)；</p>
<p>注意：</p>
<p>1.union在进行结果集合并的时候，要求两个结果的列数相同。</p>
<p>2.合并集合的对应列的数据类型也要一致（在没有mysql里面不会报错，在oracle里面会报错。）</p>
<hr>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>概述：limit是将查询结果集的一部分取出来，通常使用在分页查询之中。分页的作用是为了提高用户体验，一次都提取出来会不方便阅读，limit可以分页查看。</p>
<p>格式：select …  一个完整的查询语句…  limit startIndex，length/num；</p>
<p>解释：</p>
<p>完整用法： limit startIndex，length</p>
<p>startIndex是起始下标最小是0，length是要提取的数量。</p>
<p>缺省用法：limit num</p>
<p>直接提取前num位</p>
<p>注意：mysql中limit在order后执行！！！！！！！！</p>
<h4 id="通用分页"><a href="#通用分页" class="headerlink" title="通用分页"></a>通用分页</h4><p>公式：limit （页数-1）*每页数据条数，每页数据条数；</p>
<hr>
<h3 id="表的创建和删除"><a href="#表的创建和删除" class="headerlink" title="表的创建和删除"></a>表的创建和删除</h3><p>1.概述：建表，删除属于DDL语句，DDL包括create，drop，alter；</p>
<p>2.建表的格式：</p>
<p>create    table    表名（</p>
<p>字段1    数据类型，</p>
<p>字段2    数据类型，</p>
<p>字段3    数据类型）；    </p>
<p>3.表名建议：以    t_    或者    tbl_    开始，可读性强，见名知意。            </p>
<p>4.mysql中的部分常用数据类型：</p>
<p>varchar ：最长255位，可变长度的字符串，根据实际的数据长度动态分配空间，但速度慢。</p>
<p>char：最长255位，定长字符串，不管实际的数据长度是多少，分配固定长度的空间存储数据，速度快，但使用不恰当会导致空间的浪费。</p>
<p>int：最长11位，数字中的整数型，等同于java中的int</p>
<p>bigint：数字中的长整型，等同与java中的long</p>
<p>float：单精度浮点型</p>
<p>double：双精度浮点型</p>
<p>date：短日期类型</p>
<p>datetime：长日期类型</p>
<p>clob：字符大对象，最多可以存储4G的字符串，超过255个字的都要采用这个来存储，全称：Character Large OBject</p>
<p>blob：二进制大对象，全称Binary Large OBject，专门用来存储图片，声音，视频等流媒体数据。往BLOB类型的字段上插入数据的时候，必须采用IO流。</p>
<p>5.删除表:</p>
<p>drop table 表名；//注意当表不存在的时候会报错</p>
<p>另一种种写法：drop     table     if     exists     表名;//防止表不存在</p>
<hr>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>1.格式：insert into 表名（字段1,字段2,字段3…)    values(值1,值2,值3…);</p>
<p>注意：</p>
<p>1.字段名要和值一一对应，即数量和数据类型要对应。这里的字段是创建表的时候指定写好的。不给字段指定值默认NULL。</p>
<p>2.insert语句执行成功一定会多一条记录。</p>
<p>3.建表的时候default可以指定字段不给出的时候的默认值。</p>
<p>4.insert插入记录是从上到下依次插入的</p>
<p>create    table    表名（</p>
<p>字段1    数据类型    default     默认值1，</p>
<p>字段2    数据类型    default     默认值2，</p>
<p>字段3    数据类型    default     默认值3）；    </p>
<p>4.如果insert的字段命都不写就默认是写上了所有的字段名，所有的值都要写上。</p>
<p>insert into 表名    values(值1,值2,值3…);</p>
<p>5.insert语句插入多条记录</p>
<p>insert into 表名（字段1,字段2,字段3…)    values(值1,值2,值3…),    (值4,值5,值6…),    (值7,值8,值9…),    (值10,值11,值12…);</p>
<p>6.将插入结果插入一张表</p>
<p>insert    into    表名    select    要插入的内容;</p>
<p>上面插入了四行数据</p>
<p>数据库中的命名规则：所有的标识符全都小写，单词和单词之间用下划线 _ 分隔开</p>
<hr>
<h3 id="date和datetime区别"><a href="#date和datetime区别" class="headerlink" title="date和datetime区别"></a>date和datetime区别</h3><p>date：短日期，只包括年月日信息</p>
<p>datetime：长日期，包括年月日时分秒信息</p>
<p>mysql短日期默认格式：%Y-%m-%d</p>
<p>mysql长日期默认格式：%Y-%m-%d     %h-%i-%s</p>
<p>now()    获取系统当前时间，并且是长日期的格式。</p>
<hr>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>1.格式：update    表名    set    字段名1=值1，字段名2=值2，字段名3=值3    …    where    条件;</p>
<p>注意：没有条件限制会导致所有数据全部更新。</p>
<hr>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>1.格式：delete    from    表名    where     条件；//删除表所有满足条件的行</p>
<p>2.注意：不加条件会删除所有的数据</p>
<hr>
<h3 id="快速复制表"><a href="#快速复制表" class="headerlink" title="快速复制表"></a>快速复制表</h3><p>create    table    表名1    select     *    from    表名2（已存在）;</p>
<p>这个就是把表2完全复制给表1</p>
<hr>
<h3 id="快速删除表中的数据"><a href="#快速删除表中的数据" class="headerlink" title="快速删除表中的数据"></a>快速删除表中的数据</h3><p>1.delete    from    表名    where    条件;//这种删除的速度较慢</p>
<p>delete语句删除数据的原理：</p>
<p>表中的数据被删除，但数据在硬盘的真实存储空间不会被释放。</p>
<p>缺点：速度慢，效率低</p>
<p>优点：支持回滚，可以回复被删除的数据。</p>
<p>2.truncate语句删除表中的数据</p>
<p>表被一次截断，数据不可以恢复。</p>
<p>优点：速度快，效率高</p>
<p>缺点：被删除的数据不可以恢复，且数据一次性全部删除</p>
<p>格式：truncate    table    表名;(DDL操作)</p>
<p>删除大表的时候truncate速度比delete快很多，但注意一定要注意truncate删除后不能恢复。</p>
<hr>
<h3 id="对表结构的增删改"><a href="#对表结构的增删改" class="headerlink" title="对表结构的增删改"></a>对表结构的增删改</h3><p>1.表结构的修改：增加，修改，删除一个字段。</p>
<p>2.在实际开发过程中，需求一旦确定，表设计好后一般很少进行表结构的修改。</p>
<p>3.使用alter，属于DDL语句</p>
<hr>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>1.概述：约束对应单词：constraint。在创建表的时候，我们可以加上一些约束来保证这个表中数据的完整性和有效性！！！</p>
<p>约束的作用：保证表中的数据的有效性。</p>
<p>2.分类：</p>
<p>非空约束：not    null</p>
<p>唯一性约束：unique</p>
<p>主键约束：primiary    key(简称PK)</p>
<p>外键约束：foreign    key（简称FK）</p>
<p>检查数据：check    (mysql不支持，oracle支持)</p>
<h4 id="非空约束：not-null"><a href="#非空约束：not-null" class="headerlink" title="非空约束：not    null"></a>非空约束：not    null</h4><p>1.概述：非空约束not    null约束的字段不能为NULL；</p>
<p>2.格式：在要约束的字段后面直接加not    null；在create语句中创建table的字段后面使用。</p>
<p>3.只有列级约束，没有表级约束</p>
<h4 id="唯一性约束：unique"><a href="#唯一性约束：unique" class="headerlink" title="唯一性约束：unique"></a>唯一性约束：unique</h4><p>1.概述：唯一性约束unique约束的字段不能重复，但是可以为NULL</p>
<p>2.格式和not    null的位置一样</p>
<p>3.字段1    unique，</p>
<p>   字段2    unique；表示字段1,2各自都是唯一的。//列级约束</p>
<p>   字段1    int ，</p>
<p>   字段2    varchar；</p>
<p>​    unique（字段1，字段2）表示字段1,2的组合是唯一的。//表级约束</p>
<p>4.约束直接添加到列后面的叫列级约束，约束没有直接添加在列后面的称为表级约束。</p>
<p>5.使用的范围：需要给多个字段连个起来添加约束的时候，需要使用表级约束。</p>
<p>6.约束unique和not    null可以连用，被两者同时约束的字段成为主键字段。（mysql有，oracle中不成为主键字段）</p>
<h4 id="主键约束：primary-key-简称PK（非常重要）"><a href="#主键约束：primary-key-简称PK（非常重要）" class="headerlink" title="主键约束：primary    key ,简称PK（非常重要）"></a>主键约束：primary    key ,简称PK（非常重要）</h4><p>1.基础概念（一些废话）</p>
<p>主键约束primary    key：一种约束</p>
<p>主键字段：该字段上添加了主键约束，这样的字段叫做：主键字段</p>
<p>主键值：主键字段中的每一个值都叫做主键值。</p>
<p>2.主键值是每一行记录的唯一标识，是每一行记录的身份证号，任何一张表都应该都主键值，没有主键，表无效！！！</p>
<p>3.主键的特征：not    null+    unique（不能为空，不能重复）</p>
<p>4.</p>
<p>可以使用列级约束：</p>
<p>字段1    int    primar    key; </p>
<p>可以使用表级约束：</p>
<p>字段1，</p>
<p>primary    key（字段1）;</p>
<p>5.一个字段做主键叫做单一主键，两个字段复合起来做和主键叫做复合主键：</p>
<p>此时使用表级约束：</p>
<p>字段1    int，</p>
<p>字段2    varchar，</p>
<p>primary    key（字段1，字段2）；</p>
<p>复合主键要求：组合不能重复，不全为空；</p>
<p>在实际开发中不建议使用复合主键，建议使用单一主键；因为主键存在意义就是记录这行的身份证号，只要意义达到即可，单一主键就可以满足，复合主键较为复杂，不建议使用。</p>
<p>6.一个表中不能有两个主键约束，即不能有两个主键，类比于一个人只能又一个身份证号。</p>
<p>7.主键的建议类型值：</p>
<p>int，bigint，char等类型。不建议使用varchar，主键值一般是数字，定长；</p>
<p>8.主键除了单一主键和复合主键之外，还可以分类成</p>
<p>自然主键：主键值是一个自然数，和业务没关系。</p>
<p>业务主键：主键值和业务紧密关联，例如拿银行卡号做主键。</p>
<p>在实际开发中使用自然主键比较多，因为主键值只要做到不重复就行，不需要有意义，业务主键不好，因为主键一旦和业务挂钩，那么业务发生改变时，相应的主键值就要发生改变，所以主键不建议使用业务主键，尽量使用自然主键。</p>
<p>9.mysql中有一种机制可以自动我们自动维护一个主键值（int或bigint）</p>
<p>字段1    int    primary    key    auto_increment；//auto_increment表示自增，从1开始，以1递增</p>
<h4 id="外键约束（foreign-key，简称PK）非常重要"><a href="#外键约束（foreign-key，简称PK）非常重要" class="headerlink" title="外键约束（foreign    key，简称PK）非常重要"></a>外键约束（foreign    key，简称PK）非常重要</h4><p>1.基础概念</p>
<p>外键约束：一种约束    foreign    key</p>
<p>外键字段：被外键约束的一个字段</p>
<p>外键值：外键字段当中的每一个值</p>
<p>2.当一个字段没有被外键约束时，该字段的数据可能会出现无效值。被外键约束的字段的值只能是被指定的值。被引用值的那张表是父表，引用外键约束的表是字表。</p>
<p>3.</p>
<p>创建表的顺序：先父再子</p>
<p>删除表的顺序：先子再父</p>
<p>插入数据的顺序：先父再子</p>
<p>删除数据的顺序：先子再父</p>
<p>3.格式：</p>
<p>创建：</p>
<p>create    table    父表名（</p>
<p>字段1    int     primary    key，</p>
<p>字段2    char(10)    unique</p>
<p>)；</p>
<p>create    table    字表名（</p>
<p>字段3    int    primary    key，</p>
<p>字段4    char（10），</p>
<p>foreign    key（字段3）    references    父表名（字段2//按需写父表中的字段不一定是主键，但至少有unique约束，且和被外键约束的子表的字段同数据类型）</p>
<p>4.字表中外键引用的父表中的字段，该父表字段不必要是主键，但至少有unique约束，且和被外键约束的子表的字段同数据类型。</p>
<p>5.外键值可以为NULL。</p>
<hr>
<h3 id="SQL文件Tips"><a href="#SQL文件Tips" class="headerlink" title="SQL文件Tips"></a>SQL文件Tips</h3><p>xxxx.sql这种文件被称为SQL脚本文件。脚本文件中编写了大量SQL脚本语句，记事本没那么大的内存，直接用记事本打开很可能会导致死机，所以应该世界用source语句执行脚本文件，把SQL文件拖进mysql命令行直接转换成路径。</p>
<p>在实际工作中，执行SQL文件，电脑上的数据库就都有了。</p>
<hr>
<h3 id="存储引擎（了解）"><a href="#存储引擎（了解）" class="headerlink" title="存储引擎（了解）"></a>存储引擎（了解）</h3><p>1.概述：存储引擎是一个表存储，组织数据的方式。不同的存储引擎，表的存储数据的方式不同。</p>
<p>2.给表指定存储引擎和字符编码方式：可以在建表的时候给表指定搜索引擎。</p>
<p>3.show    create    table    表名；展示创建该表时的SQL语句；</p>
<p>3.在建表的时候可以在小括号后面使用，指定存储引擎和字符编码方式。</p>
<p>4.ENGINE来指定存储引擎，CHARSET来指定这张表的字符编码方式。</p>
<p>5.结论：mysql默认的存储引擎是InnoDB，默认的字符编码方式是utf8</p>
<p>6.格式：ENGING=xxxx    default    CHARSET=xxxx</p>
<p>7.查看mysql支持哪些存储引擎：show    engines    \G;</p>
<hr>
<h3 id="常用的mysql存储引擎介绍"><a href="#常用的mysql存储引擎介绍" class="headerlink" title="常用的mysql存储引擎介绍"></a>常用的mysql存储引擎介绍</h3><h4 id="MyISAM存储引擎："><a href="#MyISAM存储引擎：" class="headerlink" title="MyISAM存储引擎："></a>MyISAM存储引擎：</h4><p>​    他管理的表有以下特征：</p>
<p>​    使用三个文件表示每个表：</p>
<p>​        格式文件：存储表的结构定义（mytable.frm）</p>
<p>​        数据文件：存储表行的内容（mytable.MYD）</p>
<p>​        索引文件：存储表上索引（mytable.MYI）：相当于一本书的目录，减少扫描范围，提高检索效率。</p>
<p>​        优势：可被转换成压缩，只读表来节省空间；</p>
<p>​        缺点：不支持事务，安全性差</p>
<p>提示：对于一张表，只要是主键或者加有unique约束的字段上会自动创建索引。</p>
<h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><p>它是mysql默认的存储引擎，同时也是一个重量级的存储引擎。</p>
<p>特点：</p>
<p>1.支持事务，支持4个事务隔离级别，支持多版本读。//最大特点，支持事务保证了安全性</p>
<p>2.行级锁定（更新时一般是锁定当前行），通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响。</p>
<p>3.读写阻塞与事务隔离级别相关。</p>
<p>4.具有非常高效的缓存特性：能缓存索引，也能缓存数据。</p>
<p>5.整个表和主键以Cluster方式存储，组成一个平衡树。</p>
<p>6.所有Secondary Index都会保存主键信息。</p>
<p>7.支持分区，表空间（逻辑名词），类似oracle数据库。</p>
<p>8.支持外键约束，5.5之前不支持全文索引，5.5之后支持外键索引。</p>
<p>小结：supports transactions，row-level locking。and foreign keys</p>
<p>9.和Myisam引擎比，Innodb对硬件资源要求比较高。</p>
<p>MySQL引擎之innodb引擎应用场景及调优</p>
<p>Innodb引擎适用的生产场景</p>
<p>1、需要事务支持的业务（具有较好的事务特性）</p>
<p>2、行级锁定对高并发有很好的适应能力，但需要确保查询时通过索引完成。</p>
<p>3、数据读写及更新都较为频繁的场景，如：bbs，sns，微博，微信等。</p>
<p>4、数据一致性要求较高的业务，例如：充值转账，银行卡转账。</p>
<p>5、硬件设备内存较大，可以利用Innodb较好的缓存能力来提高内存利用率，尽可能减少磁盘IO。</p>
<p>Innodb 引擎调优</p>
<p>1、主键尽可能小，避免给Secondary index 带来过大的空间负担。</p>
<p>2、建立有效索引避免全表扫描，因为会使用表锁。</p>
<p>3、尽可能缓存所有的索引和数据，提高响应速度，减少产品IO消耗。</p>
<p>4、在大批量小插入的时候，尽量自己控制事务而不要使用autocommit自动提交。有开关可以控制提交方式</p>
<p>5、合理设置innodb_flush_log_at_trx_commit参数值，不要过度追求安全性。</p>
<p>如果innodb_flush_log_at_trx_commit的值为0，log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作。</p>
<p>6、避免主键更新，因为这会带来大量的数据移动。</p>
<h4 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h4><p>特点</p>
<p>1.支持 HASH 索引和 BTree 索引（ MyISAM 与 InnoDB 只支持 BTree 索引）</p>
<p>2.所有字段都为固定长度 varchar(10)=char(10)</p>
<p>3.不支持 BLOB 和 TEXT 等大字段，因为它的数据是存储在内存当中，不宜过大</p>
<p>4.Memory 存储引擎使用 <strong>表级锁</strong></p>
<p>5.查询速度最快，不安全，关机后数据消失，因为数据和索引都存储在内存中。</p>
<hr>
<h3 id="事务（重要）"><a href="#事务（重要）" class="headerlink" title="事务（重要）"></a>事务（重要）</h3><p>1.概述：一个事务其实就是完整的业务逻辑，最小的工作单元，不可再分割。本质上，一个事务就是多条DML语句同时成功，或者同时失败！</p>
<p>2.举例：</p>
<p>将A账户的钱向B账户中转账10000：将A账户的钱减去10000，将B账户的钱增加10000，这就是一个完整的业务逻辑。</p>
<p>以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可在分割。两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。</p>
<p>3.只有DML语句才会有事务这一说，其他都没有关系！！！</p>
<p>insert    delete    update</p>
<p>只有以上的三个语句和事务有关，其他都没有关系，因为只有以上的三个语句 是数据库中数据的增删改。只要你的操作一旦涉及数据的增删改，那么就一定要考虑安全问题，数据安全第一位。</p>
<p>4.事务的必要性：在完成一个业务时，往往需要多条语句才能完成。</p>
<p>5.事务做到多条DML语句同时成功或者同时失败的呢？</p>
<p>InnoDB存储引擎：提供一组用来记录事务性活动的日志文件。</p>
<p>在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。</p>
<p>提交事务：</p>
<p>清空事务性活动的日志文件，将数据全部彻底持久化到数据库中。</p>
<p>提交事务标志事务的结束，并且是一种全部成功的结束。</p>
<p>回滚事务：</p>
<p>将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件。</p>
<p>回滚事务标志着事务的结束，并且是一种全部失败的结束。</p>
<p>6.格式</p>
<p>提交事务语句：commit；</p>
<p>回滚事务语句：rollback；</p>
<p>事务对应的英语单词：transaction</p>
<p>7.mysql默认情况下是支持自动提交事务的，每执行一条DML语句，则提交一次。</p>
<p>8.关闭mysql自动提交：start    transaction；</p>
<p>9.回滚只能回到上一次的提交点。</p>
<hr>
<h3 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h3><p>A：原子性</p>
<p>事务是最小的工作单元，不可再分。</p>
<p>C：一致性</p>
<p>所有的事务要求，在同一个事务当中，所有的操作必须同时成功，或者说同时失败。</p>
<p>I：隔离性</p>
<p>A事务和B事务之间有一定的隔离。</p>
<p>D：持久性</p>
<p>事务最后结束的一个保障，事务提交，就相当于将没有保存到硬盘上的数据保存在硬盘上。</p>
<hr>
<h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p>1.读未提交：read    uncommitted（最低的隔离级别）</p>
<p>事务A可以读取到事务B未提交的数据。存在问题：脏读现象（Dirty    Read），未提交的数据就是脏数据。大多数数据库都是第二隔离级别起步。</p>
<p>2.读已提交：read    committed（oracle中默认级别）</p>
<p>事务A只能读到事务B已经提交的数据。这种隔离级别解决了脏读现象，但不可重复读取数据。不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p>
<p>这种隔离级别是比较真实的数据，每一次读到的数据都是绝对真实的。</p>
<p>oracle数据库默认的隔离级别就是：read    committed</p>
<p>3.可重复读：repeatable read（mysql中默认级别）</p>
<p>事务A开始后，不管是多久，每一次在事务A中读取到的数据都是一致的。及时事务B将数据已经修改，并且提交了，这就是可重复读。</p>
<p>问题：可能出现幻影读，即每次读的数据都是幻想，真实数据已经改变了。</p>
<p>4.序列化/串行化：serializable（最高隔离级别）</p>
<p>效率最低，但解决了所有问题，表示事务排队，不能并发，每一次读到的数据都是真实的。</p>
<p>5.设置全局隔离级别格式：set    global    transaction    isolation    level    read    uncommited;</p>
<p>6.查看隔离级别格式：select    @@tx_isolation;</p>
<hr>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>1.概述：索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。索引相当于一本书的目录，是为了缩小扫描范围的而存在的一机制。</p>
<p>2.扫描方式：</p>
<p>全字典扫描：一页页查找，直到找到为止。</p>
<p>索引查找扫描：先通过索引找到一个大概的位置，然后直接定位到这个位置，做局域性扫描，缩小扫描的范围，快速的查找，效率较高。</p>
<p>上面两个也是mysql的主要两种查找方式。</p>
<p>3.当select某个字段时，如果该字段没有添加索引，mysql就会进行全局扫描。会将该字段的所有值都和条件比对，效率较低。 </p>
<p>4.在mysql数据库中索引也是需要排序的，并且这个索引的排序和TreeSet数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树，在mysql当中索引是一个B-Tree数据结构。</p>
<p>遵循左小右大的原则存放，采用中序遍历的方式遍历取数据。</p>
<p> 5.实现原理：</p>
<p>6.在mysql数据库中主键上面都会自动添加索引，如果字段上有unique限制，也会创建索引对象。</p>
<p>7.在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的存储编号。</p>
<p>8.在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在.MYI文件中。在InnoDB存储引擎中，索引存储在一个tablesspace的当中。在MEMORY存储引擎中，索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。（自平衡二叉树：B-Tree）</p>
<p>9.添加字段索引的合适场所：</p>
<p>9.1数据量庞大</p>
<p>9.2该字段经常出现在where后面，以条件的形式存在，也就是说该字段经常被扫描</p>
<p>9.3该字段很少的使用DML（insert    delete    update）操作，因为对字段进行改变时，索引二叉树要重新排列。</p>
<p>建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能，建议通过主键或者unique约束字段查询，效率是比较高的。</p>
<p>10.格式：</p>
<p>创建索引    create    index    索引名    on    表名（要添加索引的字段名);    </p>
<p>复合索引    create    index    索引名    on    表名（字段1，字段2….);</p>
<p>删除索引    drop    index    索引名    index    on    表名；</p>
<p>查看索引    explain    selet    *    from    表名；//看type项，ref是添加了索引，all是没有添加索引。</p>
<hr>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>情况1：模糊查询时，如果形式是’%…’，即以%开头，就不会走索引，此时索引失效。尽量避免模糊查询时以%开头，这是一种优化策略。</p>
<p>情况2：使用or的时候可能会失效。如果使用or两边的条件字段有一个没索引，那么即使另一个字段上有索引，这个索引也会失效。因此就建议少使用or，这也是一个优化策略。</p>
<p>情况3：使用复合索引的时候，没有使用复合索引左侧的字段查找，索引失效。</p>
<p>复合索引：两个字段或者多个字段联合起来添加一个索引就是复合索引。</p>
<p>情况4：在where当中索引列添加了运算，索引失效。</p>
<p>例：select    *    from    表名    where    字段名+1=990；</p>
<p>情况5：在where当中索引列使用了函数。</p>
<p>例：select    *    from    表名    where    lower(字段)=‘able’；</p>
<hr>
<h3 id="关于索引的优化"><a href="#关于索引的优化" class="headerlink" title="关于索引的优化"></a>关于索引的优化</h3><p>1.概述：索引是数据库进行优化的重要手段，优化时优先考虑的因素就是索引。</p>
<p>2.索引的分类</p>
<p>单一索引：一个字段上添加索引。</p>
<p>复合索引：两个字段或多个字段上添加索引。</p>
<p>主键索引：主键上添加索引。</p>
<p>唯一性索引：具有unique约束的字段上添加索引。</p>
<p>…</p>
<p>注意：唯一性比较弱的字段上添加索引用处不大。</p>
<hr>
<h3 id="视图（view）"><a href="#视图（view）" class="headerlink" title="视图（view）"></a>视图（view）</h3><p>1.概述：站在不同的角度去看待同一份数据。</p>
<p>2.创建和删除视图对象：</p>
<p>create    view    视图名    as    select    …；将查询的结果创建视图</p>
<p>drop    view    视图名;</p>
<p>注意：只有DQL语句才能创建视图</p>
<p>3.视图的作用：创建视图后，就可以面向视图对象进行增删改查，且会导致数据库的改变。</p>
<p>4.视图对象在实际开发中作用：视图是用来简化SQL语句的。即把某个特别长的查询语句当做一个视图对象后，之后就不用重复写这个复杂的SQL语句了，这样也利用后期的维护。</p>
<p>5.视图对象也是一个文件，关机重启也不会消失。</p>
<p>小插曲：</p>
<p>增删改查，又叫做CRUD。</p>
<p>CRUD是在公司开发中程序员之间沟通的术语，一般很少说增删改查。</p>
<p>C：create（增）</p>
<p>R：Retrieve（查，索引）</p>
<p>U：Update（改）</p>
<p>D：Delete（删）</p>
<hr>
<h3 id="DBA常用命令"><a href="#DBA常用命令" class="headerlink" title="DBA常用命令"></a>DBA常用命令</h3><p>重点掌握数据的导入和导出：</p>
<p>数据导出：</p>
<p>前提是windows Dos命令窗口下操作，而不是在数据库mysql里面。</p>
<p>mysqldump    数据库名&gt;自己指定地址(导出成sql文件)     -uroot    -p密码</p>
<p>数据导入：</p>
<p>前提是先进入登录mysql</p>
<p>然后创建数据库：create    database    数据库名；</p>
<p>使用数据库：use    数据库名;</p>
<p>然后初始化数据库：source    要导入的SQL文件。</p>
<p>其他的了解即可。</p>
<hr>
<h3 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h3><p>第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。</p>
<p>第二范式：建立在第一范式的基础上，要求所有的非主键字段完全依赖主键，不要产生部分依赖。</p>
<p>第三范式：建立在第二范式的基础上，要求多有非主键字段直接依赖主键，不要产生传递依赖。</p>
<p>声明：三范式是面试官经常问的，一定要熟记在心。设计数据库表的时候，按照以上的范式进行，可以避免表中的数据冗余，空间的浪费。</p>
<h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>最核心，最重要的一个范式，所有表的设计都要满足，必须有主键，并且每一个字段都是原子不可分的。</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>不要产生主键值和非主键字段多对多的状态</p>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>设计一对多时注意第三范式</p>
<h4 id="总设计表的设计"><a href="#总设计表的设计" class="headerlink" title="总设计表的设计"></a>总设计表的设计</h4><p>一对多：</p>
<p>一对多，两张表，多的表加外键！！！</p>
<p>多对多：</p>
<p>多对多，三张表，关系表两个外键！！！</p>
<p>一对一：</p>
<p>一对一放到一张表中往往字段太多，要拆分表</p>
<p>上面的三范式不是绝对的，最后的设计还需要满足用户设计。</p>
<p>完结撒花~</p>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
</search>
