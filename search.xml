<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构实验——栈和队列</title>
    <url>/2021/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="数据结构第二次实验课——栈和队列"><a href="#数据结构第二次实验课——栈和队列" class="headerlink" title="数据结构第二次实验课——栈和队列"></a>数据结构第二次实验课——栈和队列</h1><h2 id="问题-A-出栈合法性"><a href="#问题-A-出栈合法性" class="headerlink" title="问题 A: 出栈合法性"></a>问题 A: 出栈合法性</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>已知自然数1，2，…，N（1&lt;=N&lt;=100）依次入栈，请问序列C1，C2，…，CN是否为合法的出栈序列。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入包含多组测试数据。<br>每组测试数据的第一行为整数N（1&lt;=N&lt;=100），当N=0时，输入结束。<br>第二行为N个正整数，以空格隔开，为出栈序列。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对于每组输入，输出结果为一行字符串。<br>如给出的序列是合法的出栈序列，则输出Yes，否则输出No。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 1 5</span><br><span class="line">5</span><br><span class="line">3 5 1 4 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>无</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.分析此题可以看出本题要求在入栈情况一定时判断所给的序列是否可能存在的出栈序列。对于每组数据我们分开处理。</p>
<p>2.出栈序列可以依次存放在数组中，新建一个空栈模拟入栈出栈的情况，用current指针指向数组中下一个要出栈的元素。入栈顺序指定为1,2,3,4…..</p>
<p>3.具体思考过程如下：</p>
<p>first：将入栈的第一个数即数字1入栈，将出栈顺序的数组中的current所指的数字和栈顶元素进行比较。current初始指向数组中第一个数。</p>
<p>second:比较的结果有两种，如果两个数字不相等，则下一个数字入栈（即数字2），再次将栈顶元素和出栈顺序中current所指元素作比较；如果两个数字相等，那么栈顶元素出栈（空栈时下一个元素直接入栈），current指针后移。注意：如果两数字相等，此时要做一个循环，判断此时栈中第二个元素是否和下一个要出栈的元素相等，如果相等，继续循环比较，直到不相等或者所有数字遍历完为止。</p>
<p>third:循环结束条件是所有该入栈的数均进入过栈中进行过比较。合法的条件是栈空。</p>
<p>fourth:每处理完一组数据都要把栈清空，指针初始化。</p>
<p>思路图：</p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;              </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::Empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::GetTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> data[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	data[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,num,current=<span class="number">0</span>;       <span class="comment">//current指针指向出栈顺序中下一个将要出栈的数字</span></span><br><span class="line">	Stack A;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">int</span> Chu[n];</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;                                  <span class="comment">//遇到结束符0，就跳出循环 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">		cin&gt;&gt;num;</span><br><span class="line">		Chu[j]=num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;                                <span class="comment">//核心代码行 </span></span><br><span class="line">			A.<span class="built_in">Push</span>(i);                                   <span class="comment">//每进入一个新的循环时，把数字入栈 </span></span><br><span class="line">		<span class="keyword">while</span>(A.<span class="built_in">GetTop</span>()==Chu[current]&amp;&amp;!A.<span class="built_in">Empty</span>())&#123;     <span class="comment">//当发现栈顶元素和出栈顺序current所指一样时，让栈顶元素出栈       </span></span><br><span class="line">			A.<span class="built_in">Pop</span>();                                     <span class="comment">//注意进入while循环的条件是栈非空且栈顶元素和current所指元素相等 </span></span><br><span class="line">			current++;                                   <span class="comment">//current指针后移 </span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">Empty</span>())</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">	A.<span class="built_in">MakeEmpty</span>();              <span class="comment">//完成一组数据的处理后进行初始化，即把栈清空，指针指向第一个该出栈元素的位置 </span></span><br><span class="line">	current=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>







<h2 id="问题-B-算法3-1：八进制数"><a href="#问题-B-算法3-1：八进制数" class="headerlink" title="问题 B: 算法3-1：八进制数"></a>问题 B: 算法3-1：八进制数</h2><p>时间限制:1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>将十进制数转换为八进制，并输出。</p>
<p>图：将十进制数转换为八进制并输出</p>
<h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>输入包含若干十进制正整数。</p>
<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>输出相应的八进制数，每个占一行。</p>
<h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">19</span><br><span class="line">10020345</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">23</span><br><span class="line">46162771</span><br></pre></td></tr></table></figure>

<h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>书上有相应的算法，需要补充缺失的函数。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h4><p>1、数值转换使用到堆栈，但是用函数调用（系统的堆栈）将会更为方便。</p>
<p>2、书中的算法实际上只能处理正整数，你有更好的方法还能够处理0和负整数么？ 可以把负数转化成正数进行如上运算，最后把符号加上即可。</p>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>1.首先这道题是利用栈先进后出的特性进行数据存储，在进制转换的时候要利用好这点。</p>
<p>2.十进制转换成八进制的方法就是：除8倒去余，直到商为零。（倒取余显然就是栈先进后出的特点）。</p>
<h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;data[top];</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	data[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Stack A;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;num)&#123;</span><br><span class="line">	<span class="keyword">while</span>(num)&#123;                <span class="comment">//除8取余，入栈</span></span><br><span class="line">		A.<span class="built_in">Push</span>(num%<span class="number">8</span>);</span><br><span class="line">		num=num/<span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!A.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">		A.<span class="built_in">Pop</span>();             <span class="comment">//弹栈</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="问题-C-算法3-2：行编辑程序"><a href="#问题-C-算法3-2：行编辑程序" class="headerlink" title="问题 C: 算法3-2：行编辑程序"></a>问题 C: 算法3-2：行编辑程序</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<p>​           一个简单的行编辑程序的功能是：接收用户从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输入时，不能保证不出差错，因此，若在编辑程序中，“每接收一个字符即存入用户数据区”的做法显然不是很恰当。较好的做法是，设立一个输入缓冲区，用以接收用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正。例如，当用户发现刚刚键入的一个字符是错的时，可补进一个退格符“#”，以表示前一个字符无效；如果发现当前键入的行内错误较多或难以补救，则可以键入一个退行符“@”，以表示当前行中的字符均无效。例如假设从终端接收了这样的两行字符：<br>whil##ilr#e(s#*s)<br>  outcha@   putchar(*s=#++);<br>则实际有效的是下列两行：<br>while(s)<br>  putchar(s++);</p>
<p>   为此，可设这个输入缓冲区为一个栈结构，每当从终端接收了一个字符之后先作如下判别：如果它不是退格符也不是退行符，则将该字符压入栈顶；如果是一个退格符，则从栈顶删去一个字符；如果它是一个退行符，则将字符栈清为空栈。上述处理过程可用下面算法描述之：</p>
<p>​                                                                   图：行编辑程序算法</p>
<h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>若干行程序或者数据，每行不超过200个字符。</p>
<h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>经过行编辑程序处理过后的输出。</p>
<h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whil##ilr#e(s#*s)</span><br><span class="line">	outcha@	putchar(*s=#++);</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(*s)</span><br><span class="line">	putchar(*s++);</span><br></pre></td></tr></table></figure>

<h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><p>无</p>
<h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>1.这题上面的图片已经给出来思路了，只要注意用getchar()读取带空格的字符串即可。注意处理的单位是一行，换行符的转义字符是‘\n’,文件结束标志是EOF。</p>
<p>2.注意，每组数据处理完记得把栈清空；此外这里除了栈正常的函数之外，要加一个从栈底到栈顶输出的函数。</p>
<h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>; </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=top;i++)</span><br><span class="line">	cout&lt;&lt;data[i];</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">	data[++top]=ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	Stack A;</span><br><span class="line">	ch=<span class="built_in">getchar</span>();                              <span class="comment">//从终端接收第一个字符 </span></span><br><span class="line">	<span class="keyword">while</span>(ch!=EOF)&#123;                            <span class="comment">//EOF为全文结束符 </span></span><br><span class="line">		<span class="keyword">while</span>(ch!=EOF&amp;&amp;ch!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span>(ch)&#123;</span><br><span class="line">				<span class="keyword">case</span><span class="number">&#x27;</span>#<span class="string">&#x27;:A.Pop();break;         //当且仅当栈非空时退栈 </span></span><br><span class="line"><span class="string">				case&#x27;</span>@<span class="string">&#x27;:A.MakeEmpty();break;   //重置栈为空栈 </span></span><br><span class="line"><span class="string">				default:A.Push(ch);break;      //有效字符进栈，未考虑栈满情况 </span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			ch=getchar();                       //从终端接收下一个字符 </span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	A.Show();                               //输出 </span></span><br><span class="line"><span class="string">	cout&lt;&lt;endl;</span></span><br><span class="line"><span class="string">	A.MakeEmpty();                           //重置为空栈 </span></span><br><span class="line"><span class="string">	if(ch!=EOF)&#123;</span></span><br><span class="line"><span class="string">		ch=getchar();                         //读取下一行的第一个字符 </span></span><br><span class="line"><span class="string">	&#125;	</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	&#125;	</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>





<h2 id="问题-D-算法3-7：银行排队"><a href="#问题-D-算法3-7：银行排队" class="headerlink" title="问题 D: 算法3-7：银行排队"></a>问题 D: 算法3-7：银行排队</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们大多都有在银行排队的经历，唉，那坑爹的排队啊！现在就让我们来算算我们这些客户平均需要等多久吧。<br>每天刚开始时银行会开m个窗口来为我们total个客户办理业务，当有客户需要办理业务时，先选择可以办理业务的窗口，如果有多个窗口可以办理业务就选择空闲时间最长的窗口，如果有多个窗口空闲的时间一样长，则选择序号小的窗口办理业务。假设我们每个人来到的时间和办理业务所需要的时间（为了简化问题，采用整数表示时间）都知道了。现在请你算算我们平均需要等待多久呢？</p>
<h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>有多组测试数据，每组数据开始有两个正整数m(&lt;20)和total(&lt;200)，后面有total对整数，对应客户先后到来的时间以及办理业务所需的时间。</p>
<h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>平均等待的时间，保留两位小数。</p>
<h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 6 1 3 4 1 5 3 9 2 13 4 13 3</span><br><span class="line">3 14 0 3 2 2 2 4 5 4 7 2 11 3 12 3 12 4 12 1 13 3 15 4 19 1 22 3 23 2</span><br><span class="line">2 5 0 6 0 5 0 6 7 1 7 2</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.00</span><br><span class="line">0.29</span><br><span class="line">1.20</span><br></pre></td></tr></table></figure>

<h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><p>题目中选择办理的窗口有三个状态，实际上从序号自小到大查找可以最早办理业务的窗口就已经满足上述三个状态了。可以使用数组来模拟列表。</p>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a><strong>总结：</strong></h4><p>实际上数组既可以模拟堆栈又可以模拟队列。</p>
<h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>1.将输入的数据分组进行处理，即一组顾客按一组数据处理 。</p>
<p>2.在每一组数据数据处理中，首先把顾客数据录入，每位顾客进入银行第一件事就是寻找最优柜台（等待时间最短且序号最小）。</p>
<p>3.在找到最优柜台后对柜台的状态进行判断，如果柜台在空闲状态，顾客直接进入服务，柜台结束时间更新；如果<br>柜台处于服务状态，则计算顾客需要等待的时间，然后顾客进入服务，柜台结束时间更新。</p>
<p>4.处理完每一位顾客后输出平均时间 </p>
<h4 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> hour;</span><br><span class="line">	<span class="built_in">Node</span>():<span class="built_in">hour</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;<span class="comment">//hour为柜台的结束时间 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m=<span class="number">0</span>,total;</span><br><span class="line">  <span class="keyword">while</span>(cin&gt;&gt;m)&#123;</span><br><span class="line">  	cin&gt;&gt;total;</span><br><span class="line">  	<span class="keyword">double</span> time=<span class="number">0</span>;</span><br><span class="line">  	Node*count=<span class="keyword">new</span> Node[m];<span class="comment">//m个柜台 </span></span><br><span class="line">  	<span class="keyword">int</span> *come=<span class="keyword">new</span> <span class="keyword">int</span> [total];<span class="comment">//每个顾客到来的时间</span></span><br><span class="line">	<span class="keyword">int</span> *deal=<span class="keyword">new</span> <span class="keyword">int</span> [total];<span class="comment">//处理业务所需要的时间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">		cin&gt;&gt;come[i]&gt;&gt;deal[i];<span class="comment">//顾客信息录入 </span></span><br><span class="line">	&#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> temp=<span class="number">0</span>;<span class="comment">//用来暂存最优柜台号 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123; <span class="comment">//依次处理每一个顾客 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(count[j].hour&lt;count[temp].hour)&#123;<span class="comment">//如果被检索柜台的结束时间小于，第一个柜台的结束时间 </span></span><br><span class="line">  		temp=j;<span class="comment">//按题目要求寻找需要等待时间最短的柜台，并且按序号小者优先 </span></span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(count[temp].hour&lt;=come[i])&#123;</span><br><span class="line">  	count[temp].hour=come[i]+deal[i];<span class="comment">//如果该优先柜台结束时间早于顾客来的时间 </span></span><br><span class="line">  &#125;<span class="comment">//顾客直接进入柜台服务，柜台结束时间更新</span></span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//顾客到来时，该最优柜台正在工作 </span></span><br><span class="line">  	time=time+count[temp].hour-come[i];<span class="comment">//加上等待时间</span></span><br><span class="line">	  count[temp].hour=count[temp].hour+deal[i];<span class="comment">//更新柜台的结束时间 </span></span><br><span class="line">  &#125; </span><br><span class="line">  temp=<span class="number">0</span>;<span class="comment">//最优柜台初始化 </span></span><br><span class="line">&#125;</span><br><span class="line">time=time/total;</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;time&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="问题-E-算法3-4：表达式求值"><a href="#问题-E-算法3-4：表达式求值" class="headerlink" title="问题 E: 算法3-4：表达式求值"></a>问题 E: 算法3-4：表达式求值</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>算数四则运算的规则是1）先乘除，后加减；2）从左算到右；3）先括号内，后括号外。</p>
<p>由此，算式4+2<em>3-10/5的计算顺序为4+2</em>3-10/5=4+6-10/5=4+6-2=8。</p>
<p>给定一个以“#”作为结束符的算式，求出算式的结果。</p>
<p>给出严蔚敏《数据结构（C语言）》中的一段算法描述以作参考：</p>
<p>图1：表达式求值算法</p>
<p>图2：表达式求值算法（续）</p>
<p>图3：表达式求值算法（续）</p>
<h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>以“#”结尾的表达式，运算数为正整数。每个表达式占一行。</p>
<h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><p>输出表达式运算的结果。</p>
<h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4+2*3-10/5#</span><br><span class="line">3*(7-2)#</span><br><span class="line">2*3/2#</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">15</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h4><p>使用栈来解决本题，很多人都会想到。但怎样建栈，却带来了问题。同样，严书上的代码实际上也给大家带来了问题。看过严书光盘中代码的人应该知道，代码中使用了两个栈，一个是存储运算符的，类型为char；另一个存储运算数，类型为float。而操作两个栈的函数都一样。要知道，除非像C++中使用泛型，C语言中却基本不能实现这样的操作。所以在C语言环境中需要将这两个栈结合在一起。由于char与int有种特别的联系，可以使用int来代替char存储运算符。</p>
<h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><p>注意灵活运用栈，要是能够学习C++使用template就更好了。可以模拟STL了。</p>
<h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>这题作者本人也正在学习，等思路整理清晰再上传。</p>
<h4 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> SElemType;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> prior[<span class="number">7</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;=&#x27;</span>&#125;&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> OPSET[<span class="number">7</span>] = &#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;#&#x27;</span>&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack *s)</span><span class="comment">//初始化栈 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;base = (SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span>(!s-&gt;base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    s-&gt;top = s-&gt;base ;</span><br><span class="line">    s-&gt;stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *s,SElemType c)</span><span class="comment">//入栈 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((s-&gt;top - s-&gt;base ) &gt;= s-&gt;stacksize )</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;base = (SElemType*)<span class="built_in">realloc</span>(s-&gt;base ,(s-&gt;stacksize +STACKINCREMENT)*<span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span>(!s-&gt;base )</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        s-&gt;stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *(s-&gt;top)++ = c;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack *s)</span><span class="comment">//取栈顶元素 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SElemType e;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;base == s-&gt;top )</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(s-&gt;top<span class="number">-1</span>)    ;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">In</span><span class="params">(<span class="keyword">char</span> c,<span class="keyword">char</span> str[])</span><span class="comment">//判断是否为运算符 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c != str[i])</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Strcat</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span><span class="comment">//字符串连接函数，把字符串str2连接到str1后 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str1[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(str2[j]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str1[i++] = str2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    str1[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Atoi</span><span class="params">(<span class="keyword">char</span> *c)</span><span class="comment">//把字符串转为数字 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data= <span class="number">0</span>,d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        data = data*<span class="number">10</span> + c[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;    </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">precede</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">char</span> b)</span><span class="comment">//判断优先级函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(OPSET[i] != a)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(OPSET[j] != b)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prior[i][j];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *s)</span><span class="comment">//脱括号函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;base == s-&gt;top )</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--(s-&gt;top);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Opereta</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><span class="comment">//运算函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a+c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a-c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a*c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a/c;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EvaluateExpression</span><span class="params">(<span class="keyword">char</span> *MyExpression)</span><span class="comment">//算法3.4 </span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//算术表达式求值的算符优先算法。</span></span><br><span class="line"><span class="comment">//设OPTR和OPND分别为运算符栈和运算数栈</span></span><br><span class="line">    SqStack OPTR;<span class="comment">//运算符栈，字符元素 </span></span><br><span class="line">    SqStack OPND;<span class="comment">//运算数栈，实数元素 </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">char</span> TempData[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> data,a,b;</span><br><span class="line">    <span class="keyword">char</span> *c,Dr[<span class="number">2</span>],e;</span><br><span class="line">    <span class="keyword">int</span> theta;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">InitStack</span>(&amp;OPTR);</span><br><span class="line">    <span class="built_in">Push</span>(&amp;OPTR,<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="built_in">InitStack</span>(&amp;OPND);</span><br><span class="line">     </span><br><span class="line">    c = MyExpression;</span><br><span class="line">    TempData[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(*c != <span class="string">&#x27;#&#x27;</span>|| <span class="built_in">GetTop</span>(&amp;OPTR) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">In</span>(*c,OPSET))<span class="comment">//不是运算符则进栈 </span></span><br><span class="line">        &#123;</span><br><span class="line">            Dr[<span class="number">0</span>] = *c;</span><br><span class="line">            Dr[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">Strcat</span>(TempData,Dr);</span><br><span class="line">            c++; </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">In</span>(*c,OPSET))<span class="comment">//是运算符时 </span></span><br><span class="line">            &#123;</span><br><span class="line">                data = <span class="built_in">Atoi</span>(TempData);</span><br><span class="line">                <span class="built_in">Push</span>(&amp;OPND,data);</span><br><span class="line">                TempData[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(<span class="built_in">precede</span>(<span class="built_in">GetTop</span>(&amp;OPTR),*c))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                    <span class="built_in">Push</span>(&amp;OPTR,*c);</span><br><span class="line">                    c++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                    <span class="built_in">Pop</span>(&amp;OPTR);</span><br><span class="line">                     </span><br><span class="line">                    c++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                    a = <span class="built_in">Pop</span>(&amp;OPND);</span><br><span class="line">                    b = <span class="built_in">Pop</span>(&amp;OPND);</span><br><span class="line">                    theta = <span class="built_in">Pop</span>(&amp;OPTR);</span><br><span class="line">                    <span class="built_in">Push</span>(&amp;OPND,<span class="built_in">Opereta</span>(b,theta,a));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetTop</span>(&amp;OPND);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">EvaluateExpression</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>竞赛网络预选赛比赛网址变更为：<a href="http://119.3.27.153/">http://119.3.27.153</a></p>
<h2 id="问题-F-算法6-1-6-4：二叉链表存储的二叉树"><a href="#问题-F-算法6-1-6-4：二叉链表存储的二叉树" class="headerlink" title="问题 F: 算法6-1~6-4：二叉链表存储的二叉树"></a>问题 F: 算法6-1~6-4：二叉链表存储的二叉树</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<p>树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构，其形式定义如下：</p>
<p><img src="http://192.168.173.163/JudgeOnline/upload/pimg1341_1.png" alt="img"></p>
<p>而二叉树的前序、中序遍历是非常重要的能够访问二叉树所有结点的算法，下面分别列出一种先序遍历和两种中序遍历的算法。</p>
<p>第一种中序遍历的方法（算法6.3）：</p>
<p>在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。</p>
<h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>输入只有一行，包含一个字符串S，用来建立二叉树。保证S为合法的二叉树先序遍历字符串，节点内容只有大写字母，且S的长度不超过100。</p>
<h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。</p>
<h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABC  DE G  F   </span><br></pre></td></tr></table></figure>

<h4 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A B C D E G F </span><br><span class="line">C B E G D F A </span><br><span class="line">C B E G D F A </span><br></pre></td></tr></table></figure>

<h4 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h4><p>遍历是二叉树各种操作的基础，可以在遍历的过程中对节点进行各种操作。通过二叉树的遍历，可以建立二叉树。而先序、中序和后序遍历分别具有各自的特点，是探索二叉树性质的绝佳“武器”。</p>
<h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>1.此题的难点在于利用树的先序遍历建立一棵树。</p>
<p>2.从我目前学的数据结构来看，一般的数据结构题目如果采用类模板来写十分耗费时间而且容易出错，下面的代码是使用结构体和一些函数来写的，十分简洁便利。</p>
<h4 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree *<span class="title">create</span><span class="params">()</span></span>&#123;                    <span class="comment">//先序递归建立树 </span></span><br><span class="line">	<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	Tree *root=<span class="keyword">new</span> Tree;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			root-&gt;data=ch;</span><br><span class="line">			root-&gt;lchild=<span class="built_in">create</span>();</span><br><span class="line">			root-&gt;rchild=<span class="built_in">create</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(Tree *root)</span></span>&#123;            <span class="comment">//先序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">Preorder</span>(root-&gt;lchild);</span><br><span class="line">	<span class="built_in">Preorder</span>(root-&gt;rchild);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(Tree *root)</span></span>&#123;            <span class="comment">//中序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;lchild);</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;rchild);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder</span><span class="params">(Tree *root)</span></span>&#123;           <span class="comment">//后序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	<span class="built_in">Postorder</span>(root-&gt;lchild);</span><br><span class="line">	<span class="built_in">Postorder</span>(root-&gt;rchild);</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Tree *root=<span class="built_in">create</span>();</span><br><span class="line">	<span class="built_in">Preorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
  </entry>
</search>
