<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>导读--关于图片</title>
    <url>/2021/06/10/%E5%AF%BC%E8%AF%BB-%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>关于文章中的图片，由于hexo的种种技术问题，如果文章中图片看不见，请点击首页中相应的文章，其他页面文章的图片暂时无法正常显示。</p>
]]></content>
      <categories>
        <category>导读</category>
      </categories>
      <tags>
        <tag>导读</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验——栈和队列</title>
    <url>/2021/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="数据结构第二次实验课——栈和队列"><a href="#数据结构第二次实验课——栈和队列" class="headerlink" title="数据结构第二次实验课——栈和队列"></a>数据结构第二次实验课——栈和队列</h1><h2 id="问题-A-出栈合法性"><a href="#问题-A-出栈合法性" class="headerlink" title="问题 A: 出栈合法性"></a>问题 A: 出栈合法性</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>已知自然数1，2，…，N（1&lt;=N&lt;=100）依次入栈，请问序列C1，C2，…，CN是否为合法的出栈序列。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入包含多组测试数据。<br>每组测试数据的第一行为整数N（1&lt;=N&lt;=100），当N=0时，输入结束。<br>第二行为N个正整数，以空格隔开，为出栈序列。</p>
<span id="more"></span>

<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对于每组输入，输出结果为一行字符串。<br>如给出的序列是合法的出栈序列，则输出Yes，否则输出No。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 1 5</span><br><span class="line">5</span><br><span class="line">3 5 1 4 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>无</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.分析此题可以看出本题要求在入栈情况一定时判断所给的序列是否可能存在的出栈序列。对于每组数据我们分开处理。</p>
<p>2.出栈序列可以依次存放在数组中，新建一个空栈模拟入栈出栈的情况，用current指针指向数组中下一个要出栈的元素。入栈顺序指定为1,2,3,4…..</p>
<p>3.具体思考过程如下：</p>
<p>first：将入栈的第一个数即数字1入栈，将出栈顺序的数组中的current所指的数字和栈顶元素进行比较。current初始指向数组中第一个数。</p>
<p>second:比较的结果有两种，如果两个数字不相等，则下一个数字入栈（即数字2），再次将栈顶元素和出栈顺序中current所指元素作比较；如果两个数字相等，那么栈顶元素出栈（空栈时下一个元素直接入栈），current指针后移。注意：如果两数字相等，此时要做一个循环，判断此时栈中第二个元素是否和下一个要出栈的元素相等，如果相等，继续循环比较，直到不相等或者所有数字遍历完为止。</p>
<p>third:循环结束条件是所有该入栈的数均进入过栈中进行过比较。合法的条件是栈空。</p>
<p>fourth:每处理完一组数据都要把栈清空，指针初始化。</p>
<p>思路图：</p>
<p><img src="../images/1.jpg" alt="header"></p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;              </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::Empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::GetTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> data[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	data[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,num,current=<span class="number">0</span>;       <span class="comment">//current指针指向出栈顺序中下一个将要出栈的数字</span></span><br><span class="line">	Stack A;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">int</span> Chu[n];</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;                                  <span class="comment">//遇到结束符0，就跳出循环 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">		cin&gt;&gt;num;</span><br><span class="line">		Chu[j]=num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;                                <span class="comment">//核心代码行 </span></span><br><span class="line">			A.<span class="built_in">Push</span>(i);                                   <span class="comment">//每进入一个新的循环时，把数字入栈 </span></span><br><span class="line">		<span class="keyword">while</span>(A.<span class="built_in">GetTop</span>()==Chu[current]&amp;&amp;!A.<span class="built_in">Empty</span>())&#123;     <span class="comment">//当发现栈顶元素和出栈顺序current所指一样时，让栈顶元素出栈       </span></span><br><span class="line">			A.<span class="built_in">Pop</span>();                                     <span class="comment">//注意进入while循环的条件是栈非空且栈顶元素和current所指元素相等 </span></span><br><span class="line">			current++;                                   <span class="comment">//current指针后移 </span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">Empty</span>())</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">	A.<span class="built_in">MakeEmpty</span>();              <span class="comment">//完成一组数据的处理后进行初始化，即把栈清空，指针指向第一个该出栈元素的位置 </span></span><br><span class="line">	current=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>







<h2 id="问题-B-算法3-1：八进制数"><a href="#问题-B-算法3-1：八进制数" class="headerlink" title="问题 B: 算法3-1：八进制数"></a>问题 B: 算法3-1：八进制数</h2><p>时间限制:1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>将十进制数转换为八进制，并输出。</p>
<p><img src="../images/2.jpg" alt="header"></p>
<p>图：将十进制数转换为八进制并输出</p>
<h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>输入包含若干十进制正整数。</p>
<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>输出相应的八进制数，每个占一行。</p>
<h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">19</span><br><span class="line">10020345</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">23</span><br><span class="line">46162771</span><br></pre></td></tr></table></figure>

<h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>书上有相应的算法，需要补充缺失的函数。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h4><p>1、数值转换使用到堆栈，但是用函数调用（系统的堆栈）将会更为方便。</p>
<p>2、书中的算法实际上只能处理正整数，你有更好的方法还能够处理0和负整数么？ 可以把负数转化成正数进行如上运算，最后把符号加上即可。</p>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>1.首先这道题是利用栈先进后出的特性进行数据存储，在进制转换的时候要利用好这点。</p>
<p>2.十进制转换成八进制的方法就是：除8倒去余，直到商为零。（倒取余显然就是栈先进后出的特点）。</p>
<h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;data[top];</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	data[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Stack A;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;num)&#123;</span><br><span class="line">	<span class="keyword">while</span>(num)&#123;                <span class="comment">//除8取余，入栈</span></span><br><span class="line">		A.<span class="built_in">Push</span>(num%<span class="number">8</span>);</span><br><span class="line">		num=num/<span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!A.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">		A.<span class="built_in">Pop</span>();             <span class="comment">//弹栈</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="问题-C-算法3-2：行编辑程序"><a href="#问题-C-算法3-2：行编辑程序" class="headerlink" title="问题 C: 算法3-2：行编辑程序"></a>问题 C: 算法3-2：行编辑程序</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<p>​           一个简单的行编辑程序的功能是：接收用户从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输入时，不能保证不出差错，因此，若在编辑程序中，“每接收一个字符即存入用户数据区”的做法显然不是很恰当。较好的做法是，设立一个输入缓冲区，用以接收用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正。例如，当用户发现刚刚键入的一个字符是错的时，可补进一个退格符“#”，以表示前一个字符无效；如果发现当前键入的行内错误较多或难以补救，则可以键入一个退行符“@”，以表示当前行中的字符均无效。例如假设从终端接收了这样的两行字符：<br>whil##ilr#e(s#*s)<br>  outcha@   putchar(*s=#++);<br>则实际有效的是下列两行：<br>while(s)<br>  putchar(s++);</p>
<p>   为此，可设这个输入缓冲区为一个栈结构，每当从终端接收了一个字符之后先作如下判别：如果它不是退格符也不是退行符，则将该字符压入栈顶；如果是一个退格符，则从栈顶删去一个字符；如果它是一个退行符，则将字符栈清为空栈。上述处理过程可用下面算法描述之：</p>
<p><img src="../images/3.jpg" alt="header"></p>
<p>​                                                                   图：行编辑程序算法</p>
<h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>若干行程序或者数据，每行不超过200个字符。</p>
<h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>经过行编辑程序处理过后的输出。</p>
<h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whil##ilr#e(s#*s)</span><br><span class="line">	outcha@	putchar(*s=#++);</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(*s)</span><br><span class="line">	putchar(*s++);</span><br></pre></td></tr></table></figure>

<h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><p>无</p>
<h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>1.这题上面的图片已经给出来思路了，只要注意用getchar()读取带空格的字符串即可。注意处理的单位是一行，换行符的转义字符是‘\n’,文件结束标志是EOF。</p>
<p>2.注意，每组数据处理完记得把栈清空；此外这里除了栈正常的函数之外，要加一个从栈底到栈顶输出的函数。</p>
<h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>; </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=top;i++)</span><br><span class="line">	cout&lt;&lt;data[i];</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">	data[++top]=ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	Stack A;</span><br><span class="line">	ch=<span class="built_in">getchar</span>();                              <span class="comment">//从终端接收第一个字符 </span></span><br><span class="line">	<span class="keyword">while</span>(ch!=EOF)&#123;                            <span class="comment">//EOF为全文结束符 </span></span><br><span class="line">		<span class="keyword">while</span>(ch!=EOF&amp;&amp;ch!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span>(ch)&#123;</span><br><span class="line">				<span class="keyword">case</span><span class="number">&#x27;</span>#<span class="string">&#x27;:A.Pop();break;         //当且仅当栈非空时退栈 </span></span><br><span class="line"><span class="string">				case&#x27;</span>@<span class="string">&#x27;:A.MakeEmpty();break;   //重置栈为空栈 </span></span><br><span class="line"><span class="string">				default:A.Push(ch);break;      //有效字符进栈，未考虑栈满情况 </span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			ch=getchar();                       //从终端接收下一个字符 </span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	A.Show();                               //输出 </span></span><br><span class="line"><span class="string">	cout&lt;&lt;endl;</span></span><br><span class="line"><span class="string">	A.MakeEmpty();                           //重置为空栈 </span></span><br><span class="line"><span class="string">	if(ch!=EOF)&#123;</span></span><br><span class="line"><span class="string">		ch=getchar();                         //读取下一行的第一个字符 </span></span><br><span class="line"><span class="string">	&#125;	</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	&#125;	</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>





<h2 id="问题-D-算法3-7：银行排队"><a href="#问题-D-算法3-7：银行排队" class="headerlink" title="问题 D: 算法3-7：银行排队"></a>问题 D: 算法3-7：银行排队</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们大多都有在银行排队的经历，唉，那坑爹的排队啊！现在就让我们来算算我们这些客户平均需要等多久吧。<br>每天刚开始时银行会开m个窗口来为我们total个客户办理业务，当有客户需要办理业务时，先选择可以办理业务的窗口，如果有多个窗口可以办理业务就选择空闲时间最长的窗口，如果有多个窗口空闲的时间一样长，则选择序号小的窗口办理业务。假设我们每个人来到的时间和办理业务所需要的时间（为了简化问题，采用整数表示时间）都知道了。现在请你算算我们平均需要等待多久呢？</p>
<h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>有多组测试数据，每组数据开始有两个正整数m(&lt;20)和total(&lt;200)，后面有total对整数，对应客户先后到来的时间以及办理业务所需的时间。</p>
<h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>平均等待的时间，保留两位小数。</p>
<h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 6 1 3 4 1 5 3 9 2 13 4 13 3</span><br><span class="line">3 14 0 3 2 2 2 4 5 4 7 2 11 3 12 3 12 4 12 1 13 3 15 4 19 1 22 3 23 2</span><br><span class="line">2 5 0 6 0 5 0 6 7 1 7 2</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.00</span><br><span class="line">0.29</span><br><span class="line">1.20</span><br></pre></td></tr></table></figure>

<h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><p>题目中选择办理的窗口有三个状态，实际上从序号自小到大查找可以最早办理业务的窗口就已经满足上述三个状态了。可以使用数组来模拟列表。</p>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a><strong>总结：</strong></h4><p>实际上数组既可以模拟堆栈又可以模拟队列。</p>
<h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>1.将输入的数据分组进行处理，即一组顾客按一组数据处理 。</p>
<p>2.在每一组数据数据处理中，首先把顾客数据录入，每位顾客进入银行第一件事就是寻找最优柜台（等待时间最短且序号最小）。</p>
<p>3.在找到最优柜台后对柜台的状态进行判断，如果柜台在空闲状态，顾客直接进入服务，柜台结束时间更新；如果<br>柜台处于服务状态，则计算顾客需要等待的时间，然后顾客进入服务，柜台结束时间更新。</p>
<p>4.处理完每一位顾客后输出平均时间 </p>
<h4 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> hour;</span><br><span class="line">	<span class="built_in">Node</span>():<span class="built_in">hour</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;<span class="comment">//hour为柜台的结束时间 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m=<span class="number">0</span>,total;</span><br><span class="line">  <span class="keyword">while</span>(cin&gt;&gt;m)&#123;</span><br><span class="line">  	cin&gt;&gt;total;</span><br><span class="line">  	<span class="keyword">double</span> time=<span class="number">0</span>;</span><br><span class="line">  	Node*count=<span class="keyword">new</span> Node[m];<span class="comment">//m个柜台 </span></span><br><span class="line">  	<span class="keyword">int</span> *come=<span class="keyword">new</span> <span class="keyword">int</span> [total];<span class="comment">//每个顾客到来的时间</span></span><br><span class="line">	<span class="keyword">int</span> *deal=<span class="keyword">new</span> <span class="keyword">int</span> [total];<span class="comment">//处理业务所需要的时间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">		cin&gt;&gt;come[i]&gt;&gt;deal[i];<span class="comment">//顾客信息录入 </span></span><br><span class="line">	&#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> temp=<span class="number">0</span>;<span class="comment">//用来暂存最优柜台号 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123; <span class="comment">//依次处理每一个顾客 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(count[j].hour&lt;count[temp].hour)&#123;<span class="comment">//如果被检索柜台的结束时间小于，第一个柜台的结束时间 </span></span><br><span class="line">  		temp=j;<span class="comment">//按题目要求寻找需要等待时间最短的柜台，并且按序号小者优先 </span></span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(count[temp].hour&lt;=come[i])&#123;</span><br><span class="line">  	count[temp].hour=come[i]+deal[i];<span class="comment">//如果该优先柜台结束时间早于顾客来的时间 </span></span><br><span class="line">  &#125;<span class="comment">//顾客直接进入柜台服务，柜台结束时间更新</span></span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//顾客到来时，该最优柜台正在工作 </span></span><br><span class="line">  	time=time+count[temp].hour-come[i];<span class="comment">//加上等待时间</span></span><br><span class="line">	  count[temp].hour=count[temp].hour+deal[i];<span class="comment">//更新柜台的结束时间 </span></span><br><span class="line">  &#125; </span><br><span class="line">  temp=<span class="number">0</span>;<span class="comment">//最优柜台初始化 </span></span><br><span class="line">&#125;</span><br><span class="line">time=time/total;</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;time&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="问题-E-算法3-4：表达式求值"><a href="#问题-E-算法3-4：表达式求值" class="headerlink" title="问题 E: 算法3-4：表达式求值"></a>问题 E: 算法3-4：表达式求值</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>算数四则运算的规则是1）先乘除，后加减；2）从左算到右；3）先括号内，后括号外。</p>
<p>由此，算式4+2<em>3-10/5的计算顺序为4+2</em>3-10/5=4+6-10/5=4+6-2=8。</p>
<p>给定一个以“#”作为结束符的算式，求出算式的结果。</p>
<p>给出严蔚敏《数据结构（C语言）》中的一段算法描述以作参考：</p>
<p>图1：表达式求值算法</p>
<p><img src="../images/4.jpg" alt="header"></p>
<p>图2：表达式求值算法（续）</p>
<p><img src="../images/5.jpg" alt="header"></p>
<p>图3：表达式求值算法（续）</p>
<p><img src="../images/6.jpg" alt="header"></p>
<h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>以“#”结尾的表达式，运算数为正整数。每个表达式占一行。</p>
<h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><p>输出表达式运算的结果。</p>
<h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4+2*3-10/5#</span><br><span class="line">3*(7-2)#</span><br><span class="line">2*3/2#</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">15</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h4><p>使用栈来解决本题，很多人都会想到。但怎样建栈，却带来了问题。同样，严书上的代码实际上也给大家带来了问题。看过严书光盘中代码的人应该知道，代码中使用了两个栈，一个是存储运算符的，类型为char；另一个存储运算数，类型为float。而操作两个栈的函数都一样。要知道，除非像C++中使用泛型，C语言中却基本不能实现这样的操作。所以在C语言环境中需要将这两个栈结合在一起。由于char与int有种特别的联系，可以使用int来代替char存储运算符。</p>
<h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><p>注意灵活运用栈，要是能够学习C++使用template就更好了。可以模拟STL了。</p>
<h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>这题作者本人也正在学习，等思路整理清晰再上传。</p>
<h4 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> SElemType;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> prior[<span class="number">7</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;=&#x27;</span>&#125;&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> OPSET[<span class="number">7</span>] = &#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;#&#x27;</span>&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack *s)</span><span class="comment">//初始化栈 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;base = (SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span>(!s-&gt;base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    s-&gt;top = s-&gt;base ;</span><br><span class="line">    s-&gt;stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *s,SElemType c)</span><span class="comment">//入栈 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((s-&gt;top - s-&gt;base ) &gt;= s-&gt;stacksize )</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;base = (SElemType*)<span class="built_in">realloc</span>(s-&gt;base ,(s-&gt;stacksize +STACKINCREMENT)*<span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span>(!s-&gt;base )</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        s-&gt;stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *(s-&gt;top)++ = c;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack *s)</span><span class="comment">//取栈顶元素 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SElemType e;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;base == s-&gt;top )</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(s-&gt;top<span class="number">-1</span>)    ;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">In</span><span class="params">(<span class="keyword">char</span> c,<span class="keyword">char</span> str[])</span><span class="comment">//判断是否为运算符 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c != str[i])</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Strcat</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span><span class="comment">//字符串连接函数，把字符串str2连接到str1后 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str1[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(str2[j]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str1[i++] = str2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    str1[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Atoi</span><span class="params">(<span class="keyword">char</span> *c)</span><span class="comment">//把字符串转为数字 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data= <span class="number">0</span>,d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        data = data*<span class="number">10</span> + c[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;    </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">precede</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">char</span> b)</span><span class="comment">//判断优先级函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(OPSET[i] != a)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(OPSET[j] != b)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prior[i][j];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *s)</span><span class="comment">//脱括号函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;base == s-&gt;top )</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--(s-&gt;top);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Opereta</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><span class="comment">//运算函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a+c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a-c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a*c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a/c;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EvaluateExpression</span><span class="params">(<span class="keyword">char</span> *MyExpression)</span><span class="comment">//算法3.4 </span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//算术表达式求值的算符优先算法。</span></span><br><span class="line"><span class="comment">//设OPTR和OPND分别为运算符栈和运算数栈</span></span><br><span class="line">    SqStack OPTR;<span class="comment">//运算符栈，字符元素 </span></span><br><span class="line">    SqStack OPND;<span class="comment">//运算数栈，实数元素 </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">char</span> TempData[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> data,a,b;</span><br><span class="line">    <span class="keyword">char</span> *c,Dr[<span class="number">2</span>],e;</span><br><span class="line">    <span class="keyword">int</span> theta;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">InitStack</span>(&amp;OPTR);</span><br><span class="line">    <span class="built_in">Push</span>(&amp;OPTR,<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="built_in">InitStack</span>(&amp;OPND);</span><br><span class="line">     </span><br><span class="line">    c = MyExpression;</span><br><span class="line">    TempData[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(*c != <span class="string">&#x27;#&#x27;</span>|| <span class="built_in">GetTop</span>(&amp;OPTR) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">In</span>(*c,OPSET))<span class="comment">//不是运算符则进栈 </span></span><br><span class="line">        &#123;</span><br><span class="line">            Dr[<span class="number">0</span>] = *c;</span><br><span class="line">            Dr[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">Strcat</span>(TempData,Dr);</span><br><span class="line">            c++; </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">In</span>(*c,OPSET))<span class="comment">//是运算符时 </span></span><br><span class="line">            &#123;</span><br><span class="line">                data = <span class="built_in">Atoi</span>(TempData);</span><br><span class="line">                <span class="built_in">Push</span>(&amp;OPND,data);</span><br><span class="line">                TempData[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(<span class="built_in">precede</span>(<span class="built_in">GetTop</span>(&amp;OPTR),*c))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                    <span class="built_in">Push</span>(&amp;OPTR,*c);</span><br><span class="line">                    c++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                    <span class="built_in">Pop</span>(&amp;OPTR);</span><br><span class="line">                     </span><br><span class="line">                    c++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                    a = <span class="built_in">Pop</span>(&amp;OPND);</span><br><span class="line">                    b = <span class="built_in">Pop</span>(&amp;OPND);</span><br><span class="line">                    theta = <span class="built_in">Pop</span>(&amp;OPTR);</span><br><span class="line">                    <span class="built_in">Push</span>(&amp;OPND,<span class="built_in">Opereta</span>(b,theta,a));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetTop</span>(&amp;OPND);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">EvaluateExpression</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<h2 id="问题-F-算法6-1-6-4：二叉链表存储的二叉树"><a href="#问题-F-算法6-1-6-4：二叉链表存储的二叉树" class="headerlink" title="问题 F: 算法6-1~6-4：二叉链表存储的二叉树"></a>问题 F: 算法6-1~6-4：二叉链表存储的二叉树</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<p>树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构，其形式定义如下：</p>
<p><img src="../images/7.jpg" alt="header"></p>
<p>而二叉树的前序、中序遍历是非常重要的能够访问二叉树所有结点的算法，下面分别列出一种先序遍历和两种中序遍历的算法</p>
<p><img src="../images/8.jpg" alt="header"></p>
<p>第一种中序遍历的方法（算法6.3）：</p>
<p><img src="../images/9.jpg"></p>
<p>  第二种中序遍历的方法（算法6.2）：</p>
<p><img src="../images/10.jpg" alt="header"></p>
<p>通过一个字符串，建立二叉树的算法如下：</p>
<p><img src="../images/11.jpg" alt="header"></p>
<p>  在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。</p>
<h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>输入只有一行，包含一个字符串S，用来建立二叉树。保证S为合法的二叉树先序遍历字符串，节点内容只有大写字母，且S的长度不超过100。</p>
<h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。</p>
<h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABC  DE G  F   </span><br></pre></td></tr></table></figure>

<h4 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A B C D E G F </span><br><span class="line">C B E G D F A </span><br><span class="line">C B E G D F A </span><br></pre></td></tr></table></figure>

<h4 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h4><p>遍历是二叉树各种操作的基础，可以在遍历的过程中对节点进行各种操作。通过二叉树的遍历，可以建立二叉树。而先序、中序和后序遍历分别具有各自的特点，是探索二叉树性质的绝佳“武器”。</p>
<h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>1.此题的难点在于利用树的先序遍历建立一棵树。</p>
<p>2.从我目前学的数据结构来看，一般的数据结构题目如果采用类模板来写十分耗费时间而且容易出错，下面的代码是使用结构体和一些函数来写的，十分简洁便利。</p>
<h4 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree *<span class="title">create</span><span class="params">()</span></span>&#123;                    <span class="comment">//先序递归建立树 </span></span><br><span class="line">	<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	Tree *root=<span class="keyword">new</span> Tree;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			root-&gt;data=ch;</span><br><span class="line">			root-&gt;lchild=<span class="built_in">create</span>();</span><br><span class="line">			root-&gt;rchild=<span class="built_in">create</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(Tree *root)</span></span>&#123;            <span class="comment">//先序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">Preorder</span>(root-&gt;lchild);</span><br><span class="line">	<span class="built_in">Preorder</span>(root-&gt;rchild);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(Tree *root)</span></span>&#123;            <span class="comment">//中序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;lchild);</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;rchild);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder</span><span class="params">(Tree *root)</span></span>&#123;           <span class="comment">//后序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	<span class="built_in">Postorder</span>(root-&gt;lchild);</span><br><span class="line">	<span class="built_in">Postorder</span>(root-&gt;rchild);</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Tree *root=<span class="built_in">create</span>();</span><br><span class="line">	<span class="built_in">Preorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验——树和图</title>
    <url>/2021/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E6%A0%91%E5%92%8C%E5%9B%BE/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="问题-A-图的遍历"><a href="#问题-A-图的遍历" class="headerlink" title="问题 A: 图的遍历"></a>问题 A: 图的遍历</h1><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>深度优先搜索遍历类似于树的先根遍历，是树的先根遍历的推广。其过程为：假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可以从图中的某个顶点v出发，访问此顶点，然后依次从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止。<span id="more"></span><br>其算法可以描述如下：</p>
<p>在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法遍历所有顶点，输出遍历顶点的顺序。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。<br>以后的n行中每行有n个用空格隔开的整数0或1，对于第i行的第j个0或1，1表示第i个顶点和第j个顶点有直接连接，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。<br>输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>只有一行，包含n个整数，表示按照题目描述中的深度优先遍历算法遍历整个图的访问顶点顺序。每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 0 1</span><br><span class="line">1 0 0 0</span><br><span class="line">0 0 0 1</span><br><span class="line">1 0 1 0</span><br></pre></td></tr></table></figure>



<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 3 2 </span><br></pre></td></tr></table></figure>



<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要熟练掌握图的邻接矩阵存储方式。在建立完成无向图之后，需要严格按照题目描述的遍历顺序对图进行遍历。另外，算法中描述的FirstAdjVex函数和NextAdjVex函数，需要认真的自行探索并完成。<br>通过这道题目，应该能够对图的深度优先搜索建立更加直观和清晰的概念。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.首先要学会利用邻接矩阵构造图，第二学会深度优先遍历对图进行搜索，每访问完一个节点就给该节点做标记，并且按题目要求输出结点序号。</p>
<p>2.此题中的深度优先遍历算法只能访问到连通图的每一个结点，对于非联通图如果要访问每一个极大连通分量，就要添加一个循环，判断是否每个有边存在的结点都被访问过。</p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">55</span>; <span class="comment">//图中最多顶点个数</span></span><br><span class="line"><span class="keyword">int</span> visited[MaxSize] = &#123;<span class="number">0</span>&#125;; <span class="comment">//全局数组变量visited初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MGraph</span>(<span class="keyword">int</span> n); <span class="comment">//构造函数，建立具有n个顶点e条边的图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFTraverse</span><span class="params">(<span class="keyword">int</span> v)</span></span>; <span class="comment">//深度优先遍历图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> edge[MaxSize][MaxSize]; <span class="comment">//存放图中边的数组</span></span><br><span class="line"><span class="keyword">int</span> vertexNum; <span class="comment">//图的顶点数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MGraph::<span class="built_in">MGraph</span>(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">vertexNum=n; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">cin&gt;&gt;edge[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::DFTraverse</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;v&lt;&lt;<span class="string">&#x27; &#x27;</span>; </span><br><span class="line">visited[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexNum; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (edge[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) <span class="built_in">DFTraverse</span>( j );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="function">MGraph <span class="title">MG</span><span class="params">(n)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">MG.<span class="built_in">DFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="问题B"><a href="#问题B" class="headerlink" title="问题B:"></a>问题B:</h1><h1 id="算法7-7-7-8：无向图的连通分量和生成树"><a href="#算法7-7-7-8：无向图的连通分量和生成树" class="headerlink" title="算法7-7,7-8：无向图的连通分量和生成树"></a>算法7-7,7-8：无向图的连通分量和生成树</h1><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先搜索或广度优先搜索，便可访问到图中所有顶点。对于非连通图，则需从多个顶点出发进行搜索，而每一次从一个新的起始点出发进行搜索的过程中得到的顶点访问序列恰为其各个连通分量中的顶点集。</p>
<p>对于非连通图，每个连通分量中的顶点集，和遍历时走过的边一起构成若干棵生成树，这些连通分量的生成树组成非连通图的生成森林。</p>
<p>假设以孩子兄弟链表作为生成森林的存储结构，则生成非连通图的深度优先生成森林的算法可以描述如下</p>
<p> 而建立以p为根的深度优先生成树的算法可以描述如下</p>
<p>在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立无向图的生成森林。对于森林中的每一棵生成树，遍历所有顶点，并输出遍历顶点的顺序。</p>
<h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。</p>
<p>以后的n行中每行有n个用空格隔开的整数0或1，对于第i行的第j个0或1，1表示第i个顶点和第j个顶点有直接连接，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。</p>
<p>输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图。</p>
<h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>每一行输出无向图中的一棵生成树，表示按照题目描述中的深度优先遍历算法遍历相应的连通分量的访问顶点顺序。每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">0 0 1 1 0 0</span><br><span class="line">0 1 0 1 0 0</span><br><span class="line">1 1 1 0 0 0</span><br><span class="line">0 0 0 0 0 1</span><br><span class="line">0 0 0 0 1 0</span><br></pre></td></tr></table></figure>



<h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 3 1 2 </span><br><span class="line">4 5 </span><br></pre></td></tr></table></figure>



<h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要掌握图的深度优先遍历的方法，并需要掌握无向图的连通性问题的本质。通过求出无向图的连通分量和对应的生成树，应该能够对图的连通性建立更加直观和清晰的概念。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1.这一题和上一题大同小异都是要去利用邻接矩阵来建立图。但这题要对深度优先遍历进行优化，使其能够对每一个极大连通分量遍历输出，这个深度优先遍历方法要学会。</p>
<p>2.添加了去领接顶点和某顶点后的下一个邻接顶点的函数（关键部分仔细研究）</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">55</span>; <span class="comment">//图中最多顶点个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MGraph</span>(<span class="keyword">int</span> n); <span class="comment">//构造函数，建立具有n个顶点e条边的图</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSC</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> *visited)</span></span>;</span><br><span class="line"><span class="keyword">int</span> visited[MaxSize] ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> edge[MaxSize][MaxSize]; <span class="comment">//存放图中边的数组</span></span><br><span class="line"><span class="keyword">int</span> vertexNum; <span class="comment">//图的顶点数</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MGraph::getFirst</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//取第一个邻接顶点</span></span><br><span class="line">	<span class="keyword">if</span>(v!=<span class="number">-1</span>)&#123;<span class="comment">//当顶点存在时</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vertexNum;j++)&#123;<span class="comment">//从第v行开始，第一个不为0或无穷大的边就是第一个邻接顶点</span></span><br><span class="line">			<span class="keyword">if</span>(edge[v][j]&gt;<span class="number">0</span>&amp;&amp;edge[v][j]&lt;MaxSize)<span class="comment">/*这里就是邻接矩阵的好处，直接在第v行找和v相连的顶点就行*/</span></span><br><span class="line">		&#123;</span><br><span class="line">				edge[v][j]=<span class="number">0</span>;<span class="comment">//无向邻接矩阵在找到对应邻接顶点后要把这两条边都做上标记</span></span><br><span class="line">				edge[j][v]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> j;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MGraph::getNext</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;<span class="comment">//取第v个节点的w顶点后的邻接顶点</span></span><br><span class="line">	<span class="keyword">if</span>(v!=<span class="number">-1</span>&amp;&amp;w!=<span class="number">-1</span>)&#123;<span class="comment">//当v和w结点均存在</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=w+<span class="number">1</span>;j&lt;vertexNum;j++)&#123;<span class="comment">//循环从w+1开始</span></span><br><span class="line">			<span class="keyword">if</span>(edge[v][j]&gt;<span class="number">0</span>&amp;&amp;edge[v][j]&lt;MaxSize)</span><br><span class="line">			&#123;</span><br><span class="line">				edge[v][j]=<span class="number">0</span>;<span class="comment">//双向边都要做上标记</span></span><br><span class="line">				edge[j][v]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> j;<span class="comment">//返回顶点序号</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MGraph::<span class="built_in">MGraph</span>(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">vertexNum=n; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">cin&gt;&gt;edge[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::DFSC</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span>  *visited)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;v&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	visited[v]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> w=G.<span class="built_in">getFirst</span>(v);</span><br><span class="line">	<span class="keyword">while</span>(w!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visited[w]==<span class="number">0</span>) <span class="built_in">DFSC</span>(G,w,visited);</span><br><span class="line">		w=G.<span class="built_in">getNext</span>(v,w);</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::DFS</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	visited[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vertexNum;v++)</span><br><span class="line"><span class="keyword">if</span> (!visited[v]) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DFSC</span>(G,v,visited);</span><br><span class="line">	cout&lt;&lt;endl;<span class="comment">//这里补上一个换行，对于不通的连通分量中的点换行输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="function">MGraph <span class="title">MG</span><span class="params">(n)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">MG.visited[i] = <span class="number">0</span>;</span><br><span class="line">MG.<span class="built_in">DFS</span>(MG,<span class="number">0</span>,n); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="问题-C-算法9-2：有序表的折半查找"><a href="#问题-C-算法9-2：有序表的折半查找" class="headerlink" title="问题 C: 算法9-2：有序表的折半查找"></a>问题 C: 算法9-2：有序表的折半查找</h1><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>用有序表表示静态查找表时，通常检索函数可以用折半查找来实现。</p>
<p>折半查找的查找过程是：首先确定待查记录所在的范围，然后逐步缩小范围直到找到或者确定找不到相应的记录为止。而每次需要缩小的范围均为上一次的一半，这样的查找过程可以被称为折半查找。</p>
<p>其查找过程可以描述如下：</p>
<p>在本题中，读入一串有序的整数，另外给定多次查询，判断每一次查询是否找到了相应的整数，如果找到则输出整数相应的位置。</p>
<h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含2个正整数n和k，分别表示共有n个整数和k次查询。其中n不超过1000，k同样不超过1000。</p>
<p>第二行包含n个用空格隔开的正整数，表示n个有序的整数。输入保证这n个整数是从小到大递增的。</p>
<p>第三行包含k个用空格隔开的正整数，表示k次查询的目标。</p>
<h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>只有1行，包含k个整数，分别表示每一次的查询结果。如果在查询中找到了对应的整数，则输出其相应的位置，否则输出-1。</p>
<p>请在每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 5 7 8 9 10 15</span><br><span class="line">9 2 5</span><br></pre></td></tr></table></figure>



<h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 -1 2 </span><br></pre></td></tr></table></figure>



<h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要按照题目描述中的算法完成折半查找过程。通过将需要查询的值与当前区间中央的整数进行比较，不断缩小区间的范围，直到确定被查询的值是否存在。</p>
<p>通过课本中的性能分析部分，不难发现折半查找的时间复杂度为O(log2n)，这是一种非常高效的查找方法。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这题只有25%的通过率，坑就在oj中对于相等的数值查找要输出以一个找到的位置。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> obj,<span class="keyword">int</span> num,<span class="keyword">int</span> *List)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low=<span class="number">0</span>,high=num<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> mid=num/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">		mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(obj&gt;List[mid]) low=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (obj&lt;List[mid]) high=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (obj==List[mid]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(List[mid<span class="number">-1</span>]==obj)&#123;<span class="comment">//仔细思考，找第一个符合条件的值 </span></span><br><span class="line">				high=mid;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,sum,obj;</span><br><span class="line">	cin&gt;&gt;num&gt;&gt;sum;</span><br><span class="line">	<span class="keyword">int</span> List[num];<span class="comment">//表中数字已经由小到大拍排好序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">			cin&gt;&gt;List[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum;i++)&#123;</span><br><span class="line">		cin&gt;&gt;obj;        </span><br><span class="line">		cout&lt;&lt;<span class="built_in">Search</span>(obj,num,List)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//传统的二分查找法，oj上要注意多个同样的值要找第一次出现的时候</span></span><br></pre></td></tr></table></figure>

<h1 id="问题-D-算法9-5-9-8：二叉排序树的基本操作"><a href="#问题-D-算法9-5-9-8：二叉排序树的基本操作" class="headerlink" title="问题 D: 算法9-5~9-8：二叉排序树的基本操作"></a>问题 D: 算法9-5~9-8：二叉排序树的基本操作</h1><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>二叉排序树或者是一棵空树，或者是具有以下几条性质的二叉树：</p>
<ol>
<li><pre><code>  若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；
</code></pre>
</li>
<li><pre><code>  若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值；
</code></pre>
</li>
<li><pre><code>  它的左右子树也分别为二叉排序树。
</code></pre>
</li>
</ol>
<p>二叉排序树又可以被称为二叉查找树，根据上述定义的结构不难知道，它的查找过程十分简单，只需要通过不断的将当前结点的值与需要查找的值进行比较，如果相等则直接输出，如果要查找的值更小则深入至左子树进行比较，否则就深入右子树进行比较，直到找到相应的值或者进入了一棵不存在的子树为止。</p>
<p>其查找过程可以描述如下：</p>
<p>而其插入过程同样也十分简洁，可以描述如下</p>
<p>而删除操作可以描述为如下的两个算法</p>
<p>在本题中，读入一串整数，首先利用这些整数构造一棵二叉排序树。另外给定多次查询，利用构造出的二叉排序树，判断每一次查询是否成功。</p>
<h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含2个正整数n和k，分别表示共有n个整数和k次查询。其中n不超过500，k同样不超过500。</p>
<p>第二行包含n个用空格隔开的正整数，表示n个整数。</p>
<p>第三行包含k个用空格隔开的正整数，表示k次查询的目标。</p>
<h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>只有1行，包含k个整数，分别表示每一次的查询结果。如果在查询中找到了对应的整数，则输出1，否则输出0。</p>
<p>请在每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 5 7 8 9 10 15</span><br><span class="line">9 2 5</span><br></pre></td></tr></table></figure>



<h4 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 1 </span><br></pre></td></tr></table></figure>



<h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><p>在本题中，首先需要按照题目描述中的算法完成二叉排序树的构造过程，之后需要通过在二叉排序树中的不断向下查找，将需要查询的值与当前节点的值进行比较，直到确定被查询的值是否存在。</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>1.学会构造二排序（搜索）树，利用二叉排序树左子树结点&lt;根&lt;右子树结点的特性进行搜索，本质上就是一种折半查找。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">	E data;</span><br><span class="line">	BSTNode&lt;E,K&gt; *left,*right;</span><br><span class="line">	<span class="built_in">BSTNode</span>():<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">BSTNode</span>(<span class="keyword">const</span> E d,BSTNode&lt;E,K&gt; *L=<span class="literal">NULL</span>,BSTNode&lt;E,K&gt; *R=<span class="literal">NULL</span>):<span class="built_in">data</span>(d),<span class="built_in">left</span>(L),<span class="built_in">right</span>(R)&#123;&#125;</span><br><span class="line">	~<span class="built_in">BSTNode</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(E d)</span></span>&#123;data=d;&#125;</span><br><span class="line">	<span class="function">E <span class="title">getData</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> data;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">BST</span>():<span class="built_in">root</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">		<span class="built_in">BST</span>(K value);</span><br><span class="line">		~<span class="built_in">BST</span>()&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		BSTNode&lt;E,K&gt; *root;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		</span><br><span class="line">		K RefValue; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Search</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *ptr)&#123;<span class="comment">//搜索函数，类似于折半查找</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Insert</span>(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//核心，插入函数</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		ptr=<span class="keyword">new</span> BSTNode&lt;E,K&gt;(el);</span><br><span class="line">		<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&lt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&gt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line">BST&lt;E,K&gt;::<span class="built_in">BST</span>(K value)&#123;<span class="comment">//构造函数，利用插入函数进行</span></span><br><span class="line">	E x;root=<span class="literal">NULL</span>;RefValue=value;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="keyword">while</span>(x.key!=RefValue)&#123;</span><br><span class="line">		<span class="built_in">Insert</span>(x,root);cin&gt;&gt;x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Remove</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//删除结点</span></span><br><span class="line">	BSTNode&lt;E,K&gt; *temp;</span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">if</span>(x&lt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;right);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ptr-&gt;left!=<span class="literal">NULL</span>&amp;&amp;ptr-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			temp=ptr-&gt;right;</span><br><span class="line">			<span class="keyword">while</span>(temp-&gt;left!=<span class="literal">NULL</span>) temp=temp-&gt;left;</span><br><span class="line">			ptr-&gt;data=temp-&gt;data;</span><br><span class="line">			<span class="built_in">Remove</span>(ptr-&gt;data,ptr-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				temp=ptr;</span><br><span class="line">				<span class="keyword">if</span>(ptr-&gt;left==<span class="literal">NULL</span>) ptr=ptr-&gt;right;</span><br><span class="line">				<span class="keyword">else</span> ptr=ptr-&gt;left;</span><br><span class="line">				<span class="keyword">delete</span> temp; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k,j,q;</span><br><span class="line">	BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Tree;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;j;</span><br><span class="line">		Tree.<span class="built_in">Insert</span>(j,Tree.root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">		cin&gt;&gt;q;</span><br><span class="line">	cout&lt;&lt;Tree.<span class="built_in">Search</span>(q,Tree.root)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;Tree.root-&gt;data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="问题-E-二叉排序树"><a href="#问题-E-二叉排序树" class="headerlink" title="问题 E: 二叉排序树"></a>问题 E: 二叉排序树</h1><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一系列整数，建立二叉排序树，并进行前序，中序，后序遍历。</p>
<h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>输入第一行包括一个整数n(1&lt;=n&lt;=100)。接下来的一行包括n个整数。</p>
<h4 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h4><p>可能有多组测试数据，对于每组数据，将题目所给数据建立一个二叉排序树，并对二叉排序树进行前序、中序和后序遍历。每种遍历结果输出一行。每行最后一个数据之后有一个空格。</p>
<h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2 </span><br><span class="line">2</span><br><span class="line">8 15 </span><br><span class="line">4</span><br><span class="line">21 10 5 39 </span><br></pre></td></tr></table></figure>



<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 </span><br><span class="line">2 </span><br><span class="line">2 </span><br><span class="line">8 15 </span><br><span class="line">8 15 </span><br><span class="line">15 8 </span><br><span class="line">21 10 5 39 </span><br><span class="line">5 10 21 39 </span><br><span class="line">5 10 39 21 </span><br></pre></td></tr></table></figure>



<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>二叉排序树构建好了，添加前中后序遍历就行。每处理完一组数据后都要把树清空。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">	E data;</span><br><span class="line">	BSTNode&lt;E,K&gt; *left,*right;</span><br><span class="line">	<span class="built_in">BSTNode</span>():<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">BSTNode</span>(<span class="keyword">const</span> E d,BSTNode&lt;E,K&gt; *L=<span class="literal">NULL</span>,BSTNode&lt;E,K&gt; *R=<span class="literal">NULL</span>):<span class="built_in">data</span>(d),<span class="built_in">left</span>(L),<span class="built_in">right</span>(R)&#123;&#125;</span><br><span class="line">	~<span class="built_in">BSTNode</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(E d)</span></span>&#123;data=d;&#125;</span><br><span class="line">	<span class="function">E <span class="title">getData</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> data;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">BST</span>():<span class="built_in">root</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">		<span class="built_in">BST</span>(K value);</span><br><span class="line">		~<span class="built_in">BST</span>()&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Pre</span><span class="params">(BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">In</span><span class="params">(BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Post</span><span class="params">(BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		BSTNode&lt;E,K&gt; *root;<span class="comment">//偷个懒，正常要写个返回根节点的函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		</span><br><span class="line">		K RefValue; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BST&lt;E,K&gt;::<span class="built_in">MakeEmpty</span>()<span class="comment">//把树清空</span></span><br><span class="line">&#123;</span><br><span class="line">	root=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Pre</span>(BSTNode&lt;E,K&gt; *ptr)&#123;<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		cout&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">Pre</span>(ptr-&gt;left);</span><br><span class="line">		<span class="built_in">Pre</span>(ptr-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">In</span>(BSTNode&lt;E,K&gt; *ptr)&#123;<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">In</span>(ptr-&gt;left);</span><br><span class="line">		cout&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">In</span>(ptr-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Post</span>(BSTNode&lt;E,K&gt; *ptr)&#123;<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">Post</span>(ptr-&gt;left);</span><br><span class="line">		<span class="built_in">Post</span>(ptr-&gt;right);</span><br><span class="line">		cout&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Search</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *ptr)&#123;<span class="comment">//搜索</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Insert</span>(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//插入</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		ptr=<span class="keyword">new</span> BSTNode&lt;E,K&gt;(el);</span><br><span class="line">		<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&lt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&gt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line">BST&lt;E,K&gt;::<span class="built_in">BST</span>(K value)&#123;<span class="comment">//构造函数</span></span><br><span class="line">	E x;root=<span class="literal">NULL</span>;RefValue=value;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="keyword">while</span>(x.key!=RefValue)&#123;</span><br><span class="line">		<span class="built_in">Insert</span>(x,root);cin&gt;&gt;x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Remove</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//删除函数</span></span><br><span class="line">	BSTNode&lt;E,K&gt; *temp;</span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">if</span>(x&lt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;right);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ptr-&gt;left!=<span class="literal">NULL</span>&amp;&amp;ptr-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			temp=ptr-&gt;right;</span><br><span class="line">			<span class="keyword">while</span>(temp-&gt;left!=<span class="literal">NULL</span>) temp=temp-&gt;left;</span><br><span class="line">			ptr-&gt;data=temp-&gt;data;</span><br><span class="line">			<span class="built_in">Remove</span>(ptr-&gt;data,ptr-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				temp=ptr;</span><br><span class="line">				<span class="keyword">if</span>(ptr-&gt;left==<span class="literal">NULL</span>) ptr=ptr-&gt;right;</span><br><span class="line">				<span class="keyword">else</span> ptr=ptr-&gt;left;</span><br><span class="line">				<span class="keyword">delete</span> temp; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,temp;</span><br><span class="line">BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Tree;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		Tree.<span class="built_in">Insert</span>(temp,Tree.root);</span><br><span class="line">	&#125;</span><br><span class="line">	Tree.<span class="built_in">Pre</span>(Tree.root);cout&lt;&lt;endl;</span><br><span class="line">	Tree.<span class="built_in">In</span>(Tree.root);cout&lt;&lt;endl;</span><br><span class="line">	Tree.<span class="built_in">Post</span>(Tree.root);cout&lt;&lt;endl;</span><br><span class="line">	Tree.<span class="built_in">MakeEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="问题-F-算法6-12：自底向上的赫夫曼编码"><a href="#问题-F-算法6-12：自底向上的赫夫曼编码" class="headerlink" title="问题 F: 算法6-12：自底向上的赫夫曼编码"></a>问题 F: 算法6-12：自底向上的赫夫曼编码</h1><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>在通讯领域，经常需要将需要传送的文字转换成由二进制字符组成的字符串。在实际应用中，由于总是希望被传送的内容总长尽可能的短，如果对每个字符设计长度不等的编码，且让内容中出现次数较多的字符采用尽可能短的编码，则整个内容的总长便可以减少。另外，需要保证任何一个字符的编码都不是另一个字符的编码前缀，这种编码成为前缀编码。</p>
<p>而赫夫曼编码就是一种二进制前缀编码，其从叶子到根（自底向上）逆向求出每个字符的算法可以表示如下：</p>
<p><img src="http://192.168.173.163/JudgeOnline/upload/pimg1344_1.png" alt="img"></p>
<p>在本题中，读入n个字符所对应的权值，生成赫夫曼编码，并依次输出计算出的每一个赫夫曼编码。</p>
<h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含一个正整数n，表示共有n个字符需要编码。其中n不超过100。</p>
<p>第二行中有n个用空格隔开的正整数，分别表示n个字符的权值。</p>
<h4 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h4><p>共n行，每行一个字符串，表示对应字符的赫夫曼编码。</p>
<h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">5 29 7 8 14 23 3 11</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0110</span><br><span class="line">10</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">110</span><br><span class="line">00</span><br><span class="line">0111</span><br><span class="line">010</span><br></pre></td></tr></table></figure>

<h4 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h4><p>赫夫曼树又名最优二叉树，它是一类带权路径长度最小的二叉树。通过构造赫夫曼树，我们可以得到赫夫曼编码，从而使得通信能够得到更高的效率。在本题中，构造赫夫曼树的过程使用了从叶子到根的逆向顺序，另外，还有一种从根出发直到叶子的赫夫曼编码构造算法，这将在下一题中进行讨论。</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>cv战士只想看懂大佬们的解法</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span><span class="comment">//最小堆要用的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> w[MaxN];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;<span class="comment">//权值</span></span><br><span class="line">    <span class="keyword">int</span> parent, lchild, rchild;</span><br><span class="line">&#125;HuffmanNode, *HuffmanTree;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *HuffmanCode;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seletTMin</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n, <span class="keyword">int</span> &amp;m1, <span class="keyword">int</span> &amp;m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = INT32_MAX;<span class="comment">//int32_t.max=2147483647</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; min &gt; HT[i].weight)</span><br><span class="line">        &#123;</span><br><span class="line">            min = HT[i].weight;</span><br><span class="line">            m1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    min = INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; min &gt; HT[i].weight &amp;&amp; i != m1)</span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            min = HT[i].weight;</span><br><span class="line">            m2 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (m1 &gt; m2)</span><br><span class="line">        <span class="built_in">swap</span>(m1, m2); <span class="comment">//交换，这一段必不可少，不然构造出来的编码是不唯一的</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree &amp;HT, HuffmanCode *&amp;HC,<span class="keyword">int</span> w[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    HT = <span class="keyword">new</span> HuffmanNode[m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        HT[i].weight = w[i];</span><br><span class="line">        HT[i].lchild = HT[i].rchild = HT[i].parent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        HT[i].lchild = HT[i].rchild = HT[i].parent = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m1, m2;</span><br><span class="line">        <span class="built_in">seletTMin</span>(HT, i - <span class="number">1</span>, m1, m2);</span><br><span class="line">        HT[i].lchild = m1;</span><br><span class="line">        HT[i].rchild = m2;</span><br><span class="line">        HT[m1].parent = HT[m2].parent = i;</span><br><span class="line">        HT[i].weight = HT[m1].weight + HT[m2].weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    HC = <span class="keyword">new</span> HuffmanCode[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> * cd = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = i, f = HT[i].parent; f != <span class="number">0</span>; c = f, f = HT[f].parent)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c)</span><br><span class="line">                cd[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        HC[i] = <span class="keyword">new</span> <span class="keyword">char</span>[n - start];</span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], cd + start);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> cd;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"> </span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">    HuffmanTree HT;</span><br><span class="line">    HuffmanCode *HC;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> data[MaxN];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            cin &gt;&gt; data[i];</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">HuffmanCoding</span>(HT, HC, data, n);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            cout &lt;&lt;  HC[i] &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">delete</span> HC;</span><br><span class="line">        <span class="keyword">delete</span> HT;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h1 id="问题-E-算法7-15：迪杰斯特拉最短路径算法"><a href="#问题-E-算法7-15：迪杰斯特拉最短路径算法" class="headerlink" title="问题 E: 算法7-15：迪杰斯特拉最短路径算法"></a>问题 E: 算法7-15：迪杰斯特拉最短路径算法</h1><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>在带权有向图G中，给定一个源点v，求从v到G中的其余各顶点的最短路径问题，叫做单源点的最短路径问题。</p>
<p>在常用的单源点最短路径算法中，迪杰斯特拉算法是最为常用的一种，是一种按照路径长度递增的次序产生最短路径的算法。</p>
<p>可将迪杰斯特拉算法描述如下：</p>
<p><img src="http://192.168.173.163/JudgeOnline/upload/pimg1352_1.png" alt="img"></p>
<p>在本题中，读入一个有向图的带权邻接矩阵（即数组表示），建立有向图并按照以上描述中的算法求出源点至每一个其它顶点的最短路径长度。</p>
<h4 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含2个正整数n和s，表示图中共有n个顶点，且源点为s。其中n不超过50，s小于n。</p>
<p>以后的n行中每行有n个用空格隔开的整数。对于第i行的第j个整数，如果大于0，则表示第i个顶点有指向第j个顶点的有向边，且权值为对应的整数值；如果这个整数为0，则表示没有i指向j的有向边。当i和j相等的时候，保证对应的整数为0。</p>
<h4 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h4><p>只有一行，共有n-1个整数，表示源点至其它每一个顶点的最短路径长度。如果不存在从源点至相应顶点的路径，输出-1。</p>
<p>请注意行尾输出换行。</p>
<h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">0 3 0 1</span><br><span class="line">0 0 4 0</span><br><span class="line">2 0 0 0</span><br><span class="line">0 0 1 0</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4 7 </span><br></pre></td></tr></table></figure>

<h4 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要按照题目描述中的算法完成迪杰斯特拉算法，并在计算最短路径的过程中将每个顶点是否可达记录下来，直到求出每个可达顶点的最短路径之后，算法才能够结束。</p>
<p>迪杰斯特拉算法的特点是按照路径长度递增的顺序，依次添加下一条长度最短的边，从而不断构造出相应顶点的最短路径。</p>
<p>另外需要注意的是，在本题中为了更方便的表示顶点间的不可达状态，可以使用一个十分大的值作为标记。</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>cv战士不做挣扎</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3fffffff</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = inf;<span class="comment">//距离为最大 </span></span><br><span class="line">        vis[i] = <span class="number">0</span>; <span class="comment">//未访问过 </span></span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span> &amp;&amp; dis[j] &lt; min)<span class="comment">//找到未访问中最小的点 </span></span><br><span class="line">            &#123;</span><br><span class="line">                k = j;</span><br><span class="line">                min = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = <span class="number">1</span>;<span class="comment">//加入访问后的集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;dis[k]+a[k][j] &lt; dis[j])<span class="comment">//没访问过 </span></span><br><span class="line">                dis[j] = dis[k] + a[k][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=s &amp;&amp; dis[i]!=inf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=s &amp;&amp; dis[i] == inf)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;s)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</span><br><span class="line">                    a[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        dijstra(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>第三届全国大学生算法设计与编程挑战赛</title>
    <url>/2021/10/26/%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="Problem-A-分组"><a href="#Problem-A-分组" class="headerlink" title="Problem A    分组"></a>Problem A    分组</h2><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p><strong>本题共 10 个测试点，每个测试点有 4s 的测试时间,可用内存为512MB</strong></p>
<p>小A是个热爱学习又心怀热忱的好孩子，于是他参加了今年的支教活动。</p>
<p>在希望小学一个平凡的下午，小A带着同学们做课外活动，活动十分丰富，有跷跷板和跷跷板，甚至还有跷跷板！但器材有限，这里只有K个跷跷板，因此小A决定对孩子们进行分组。</p>
<span id="more"></span>

<p>小A支教的班级一共有N名同学，站成了一排等待分组，从左到右依次为第1～N名同学。</p>
<p>小A需要将这N名同学分为K组，<strong>每组可以有1或2名同学，但不可以为空</strong>。同时，这些同学<strong>很有个性</strong>，只愿和相邻的同学一起玩。因此，对于任意一组，如果这一组有2名同学，那么他们必须相邻。</p>
<p>当然这样分组很可能会导致某些同学不属于任何一组，此时，小A会安排这些同学去玩别的游戏。因此<strong>允许某些同学不在任何组内</strong>。</p>
<p>小A最近也在准备大厂面试的算法题，于是很快就想出了最佳方案。勇于挑战自我的小A提升了上面问题的难度，开始计算起<strong>将这些同学分为i组(1\leq i\leq K)(1≤*i*≤*K*)的方案数</strong>。聪明的你能帮帮小A吗？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入共一行，为两个正整数N和K（1≤N≤10^91≤<em>N</em>≤109,1≤K≤2^{18}1≤<em>K</em>≤218），含义如题所述。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出为一行，共 K<em>K</em>个整数，以空格分开。</p>
<p>第i个(1≤i≤K1≤<em>i</em>≤<em>K</em>)整数表示将这N<em>N</em>名同学分为i<em>i</em>组的方案数。由于答案可能会很大，只需要输出方案数对998244353</p>
<hr>
<p>取模的结果。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 13 7 1 0 0 0 0 </span><br></pre></td></tr></table></figure>

<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Problem-B-二进制"><a href="#Problem-B-二进制" class="headerlink" title="Problem B 二进制"></a>Problem B 二进制</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>你是一个算法爱好者，在努力学习计算机知识。你知道，计算机最优美的地方在于二进制，这一点你在状压dp里面深有体会，当然二进制用在xor,and,or时也非常巧妙，更不用说nim游戏都能跟xor扯上关系了，而今天你又遇到了一道二进制的题目，对于爱思考的你，决定一直要把这道二进制题给切掉。</p>
<p>你遇到了很多十进制的数，对于这些数，它们都管理着它们对应的分层，比如数字6，它的二进制是110，则它管理着4(100),2(10)4(100),2(10)，两个分段，当数字6在[2,4][2,4]区间上增加3时，则代表二进制(100)(100)和(10)(10)两层在[2,4][2,4]区间增加3。</p>
<p>本道题有两种操作，读入一个opt<em>o<strong>p</strong>t</em></p>
<p>opt<em>o<strong>p</strong>t</em>为11时 :读入一个数a_i<em>a**i</em>，一个区间l_i,r_i<em>l**i</em>,<em>r**i</em>和一个增加的值k_i<em>k**i</em>，表示在这个数管理的分层中的每一个区间增加k_i<em>k**i</em>值。</p>
<p>opt<em>o<strong>p</strong>t</em>为22时:读入一个数a_i<em>a**i</em>，一个区间l_i,r_i<em>l**i</em>,<em>r**i</em>，表示询问这个数管理的分层中每一个区间的值的总和。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数n,q<em>n</em>,<em>q</em>，表示n<em>n</em>表示区间长度(1 \leq l_i \leq r_i \leq n \leq 100000)(1≤<em>l**i</em>≤<em>r**i</em>≤<em>n</em>≤100000)，q<em>q</em>表示有q(1 \leq q \leq 100000)<em>q</em>(1≤<em>q</em>≤100000)次操作。</p>
<p>数据保证(1\leq a_i \leq1024)(1≤<em>a**i</em>≤1024),k_i<em>k**i</em>在int范围内</p>
<p>后面q<em>q</em>行，每行首先一个数opt<em>o<strong>p</strong>t</em>表示进行的操作</p>
<p>opt=1<em>o<strong>p</strong>t</em>=1时后接整数a_i<em>a**i</em>表示管理分层，l_i,r_i<em>l**i</em>,<em>r**i</em>表示区间，k_i<em>k**i</em>表示增加的值</p>
<p>opt=2<em>o<strong>p</strong>t</em>=2时后接整数a_i<em>a**i</em>表示管理分层，l_i,r_i<em>l**i</em>,<em>r**i</em>表示区间</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>对于每个第二个操作，输出一行表示询问的答案。</p>
<h3 id="Sample-Input-1-1"><a href="#Sample-Input-1-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 3 1 5 2</span><br><span class="line">2 1 1 2</span><br><span class="line">2 3 1 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1-1"><a href="#Sample-Output-1-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>第一次进行1操作，3(11)管理(10)和(1)两个分层，(10)层的[1,5]区间加上2，(1)层的[1,5]区间加上2</p>
<p>第二次进行2操作，1管理(1)一个分层，(1)层的[1,2]区间和为4，所以答案是4</p>
<p>第三次进行2操作，3(11)管理(10)和(1)两个分层，(10)层的[1,2]区间和为4，(1)层的[1,2]区间和为4，所以答案为8</p>
<h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Problem-C-不正方形"><a href="#Problem-C-不正方形" class="headerlink" title="Problem C 不正方形"></a>Problem C 不正方形</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>今天是数学课！小A发现同学们上课很消极，于是给大家出了一个数学小游戏。</p>
<p>小A在黑板上画了一个很大很大的平面直角坐标系，然后给出了若干个红点和黄点，现在同学们需要回答，这些点能否构成一个<strong>不正方形</strong>。</p>
<p><strong>不正方形的定义为：四个点构成一个凸四边形，且相对顶点颜色相同，相邻顶点颜色不同。</strong></p>
<p>为了降低难度，认真的小A保证不会有重点（即不会有两个点坐标相同），也不会有三个点共线的情况。</p>
<p>同学们觉得很有趣，但这个问题对于小朋友们还太难了，聪明的你能帮帮他们吗？</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>第一行两个正整数，n、m。</p>
<p>接下来n行，每行两个整数x和y，表示红点的坐标。</p>
<p>接下来m行，每行两个整数x和y，表示黄点的坐标。</p>
<p>1&lt;n,m&lt;=250,\ 1&lt;=x,y&lt;=10^71&lt;<em>n</em>,<em>m</em>&lt;=250, 1&lt;=<em>x</em>,<em>y</em>&lt;=107</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>如果能构成，输出“YES”；否则，输出“NO”。（不含双引号）</p>
<h3 id="Sample-Input-1-2"><a href="#Sample-Input-1-2" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1-2"><a href="#Sample-Output-1-2" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>

<h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>蒻苟水分日记</category>
      </categories>
      <tags>
        <tag>算法 竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>java知识点总结</title>
    <url>/2021/10/23/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1.单行注释"></a>1.单行注释</h3><p>格式：//注释信息</p>
<h3 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2.多行注释"></a>2.多行注释</h3><p>格式：/*  注释信息  */</p>
<h3 id="3-文档注释"><a href="#3-文档注释" class="headerlink" title="3.文档注释"></a>3.文档注释</h3><p>格式：/**    注释信息  */</p>
<span id="more"></span>

<hr>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="1-关键字描述"><a href="#1-关键字描述" class="headerlink" title="1.关键字描述"></a>1.关键字描述</h3><p>关键字：就是被java语言赋予了特定含义的单词</p>
<h3 id="2-关键字的特点"><a href="#2-关键字的特点" class="headerlink" title="2.关键字的特点"></a>2.关键字的特点</h3><p>2.1关键字全部小写</p>
<p>2.2常用的代码编辑器，针对关键字有特殊的颜色标记，非常直观</p>
<hr>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="1-常量概述"><a href="#1-常量概述" class="headerlink" title="1.常量概述"></a>1.常量概述</h3><p>在程序运行过程中，其值不能发生改变的量。</p>
<h3 id="2-常量分类"><a href="#2-常量分类" class="headerlink" title="2.常量分类"></a>2.常量分类</h3><p>字符串常量 ：用双引号括起来的内容</p>
<p>整数常量：不带小数点的数字</p>
<p>小数常量：带小数的数字</p>
<p>字符常量：用单引号括起来的内容</p>
<p>布尔常量：布尔值，表示真假，true，false</p>
<p>空常量：一个特殊的值，空值null</p>
<hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型包括基本数据类型和引用数据类型。基本数据类型包含数值型{整数（byte,short,int,long）,浮点数（float，double），字符（char）}和非数值型{布尔（boolean）}。引用数据类型包括类（class），接口（interface），数组（[]）。</p>
<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="1-变量概述"><a href="#1-变量概述" class="headerlink" title="1.变量概述"></a>1.变量概述</h3><p>变量是指在程序运行过程中，其值可以发生改变的量。</p>
<h3 id="2-变量定义"><a href="#2-变量定义" class="headerlink" title="2.变量定义"></a>2.变量定义</h3><p>格式：数据类型 变量名 =变量值；</p>
<h3 id="3-变量的使用"><a href="#3-变量的使用" class="headerlink" title="3.变量的使用"></a>3.变量的使用</h3><p>取值和修改</p>
<h3 id="4-变量使用的注意事项"><a href="#4-变量使用的注意事项" class="headerlink" title="4.变量使用的注意事项"></a>4.变量使用的注意事项</h3><p>变量名不能重复</p>
<p>变量为赋值不能使用</p>
<p>long类型的变量定义时，为了防止整数过大，后面要加L</p>
<p>float类型的变量定义时，为了防止类型不兼容，后面要加F</p>
<hr>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><h3 id="1-标识符概述"><a href="#1-标识符概述" class="headerlink" title="1.标识符概述"></a>1.标识符概述</h3><p>标识符就是给类，方法，变量等起名字的符号。</p>
<h3 id="2-标识符的定义规则"><a href="#2-标识符的定义规则" class="headerlink" title="2.标识符的定义规则"></a>2.标识符的定义规则</h3><p>标识符由数字，字母，下划线___,美元$组成</p>
<p>不能由数字开头，不能是关键字，区分大小写</p>
<h3 id="3-常见命名约定"><a href="#3-常见命名约定" class="headerlink" title="3.常见命名约定"></a>3.常见命名约定</h3><p>小驼峰命名法：<br>1.标识符是一个单词时，首字母小写</p>
<p>2.标识符有多个单词组成时，第一个字母单词首字母小写，其他单词字母大写</p>
<p>大驼峰命名法：</p>
<p>1.标识符是一个单词时，首字母大写</p>
<p>2.标识符由多个单词组成时，每个单词首字母大写</p>
<hr>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="1-自动类型转换"><a href="#1-自动类型转换" class="headerlink" title="1.自动类型转换"></a>1.自动类型转换</h3><p>把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量</p>
<p>​                                             数据范围由小到大</p>
<p>byte -&gt; short -&gt;int -&gt;long -&gt;float -&gt;double</p>
<p>char-&gt;(指向short)</p>
<h3 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="2.强制类型转换"></a>2.强制类型转换</h3><p>把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量</p>
<p> 格式：目标数据类型 变量名=（目标数据类型） 值或变量</p>
<p>范例：int k=（int）88.88；</p>
<hr>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
