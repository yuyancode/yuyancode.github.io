<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>导读--关于图片</title>
    <url>/2021/06/10/%E5%AF%BC%E8%AF%BB-%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>关于文章中的图片，由于hexo的种种技术问题，如果文章中图片看不见，请点击首页中相应的文章，其他页面文章的图片暂时无法正常显示。</p>
]]></content>
      <categories>
        <category>导读</category>
      </categories>
      <tags>
        <tag>导读</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验——栈和队列</title>
    <url>/2021/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="数据结构第二次实验课——栈和队列"><a href="#数据结构第二次实验课——栈和队列" class="headerlink" title="数据结构第二次实验课——栈和队列"></a>数据结构第二次实验课——栈和队列</h1><h2 id="问题-A-出栈合法性"><a href="#问题-A-出栈合法性" class="headerlink" title="问题 A: 出栈合法性"></a>问题 A: 出栈合法性</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>已知自然数1，2，…，N（1&lt;=N&lt;=100）依次入栈，请问序列C1，C2，…，CN是否为合法的出栈序列。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入包含多组测试数据。<br>每组测试数据的第一行为整数N（1&lt;=N&lt;=100），当N=0时，输入结束。<br>第二行为N个正整数，以空格隔开，为出栈序列。</p>
<span id="more"></span>

<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对于每组输入，输出结果为一行字符串。<br>如给出的序列是合法的出栈序列，则输出Yes，否则输出No。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 1 5</span><br><span class="line">5</span><br><span class="line">3 5 1 4 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>无</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.分析此题可以看出本题要求在入栈情况一定时判断所给的序列是否可能存在的出栈序列。对于每组数据我们分开处理。</p>
<p>2.出栈序列可以依次存放在数组中，新建一个空栈模拟入栈出栈的情况，用current指针指向数组中下一个要出栈的元素。入栈顺序指定为1,2,3,4…..</p>
<p>3.具体思考过程如下：</p>
<p>first：将入栈的第一个数即数字1入栈，将出栈顺序的数组中的current所指的数字和栈顶元素进行比较。current初始指向数组中第一个数。</p>
<p>second:比较的结果有两种，如果两个数字不相等，则下一个数字入栈（即数字2），再次将栈顶元素和出栈顺序中current所指元素作比较；如果两个数字相等，那么栈顶元素出栈（空栈时下一个元素直接入栈），current指针后移。注意：如果两数字相等，此时要做一个循环，判断此时栈中第二个元素是否和下一个要出栈的元素相等，如果相等，继续循环比较，直到不相等或者所有数字遍历完为止。</p>
<p>third:循环结束条件是所有该入栈的数均进入过栈中进行过比较。合法的条件是栈空。</p>
<p>fourth:每处理完一组数据都要把栈清空，指针初始化。</p>
<p>思路图：</p>
<p><img src="../images/1.jpg" alt="header"></p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;              </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::Empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::GetTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> data[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	data[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,num,current=<span class="number">0</span>;       <span class="comment">//current指针指向出栈顺序中下一个将要出栈的数字</span></span><br><span class="line">	Stack A;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">int</span> Chu[n];</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;                                  <span class="comment">//遇到结束符0，就跳出循环 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">		cin&gt;&gt;num;</span><br><span class="line">		Chu[j]=num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;                                <span class="comment">//核心代码行 </span></span><br><span class="line">			A.<span class="built_in">Push</span>(i);                                   <span class="comment">//每进入一个新的循环时，把数字入栈 </span></span><br><span class="line">		<span class="keyword">while</span>(A.<span class="built_in">GetTop</span>()==Chu[current]&amp;&amp;!A.<span class="built_in">Empty</span>())&#123;     <span class="comment">//当发现栈顶元素和出栈顺序current所指一样时，让栈顶元素出栈       </span></span><br><span class="line">			A.<span class="built_in">Pop</span>();                                     <span class="comment">//注意进入while循环的条件是栈非空且栈顶元素和current所指元素相等 </span></span><br><span class="line">			current++;                                   <span class="comment">//current指针后移 </span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">Empty</span>())</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">	A.<span class="built_in">MakeEmpty</span>();              <span class="comment">//完成一组数据的处理后进行初始化，即把栈清空，指针指向第一个该出栈元素的位置 </span></span><br><span class="line">	current=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>







<h2 id="问题-B-算法3-1：八进制数"><a href="#问题-B-算法3-1：八进制数" class="headerlink" title="问题 B: 算法3-1：八进制数"></a>问题 B: 算法3-1：八进制数</h2><p>时间限制:1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>将十进制数转换为八进制，并输出。</p>
<p><img src="../images/2.jpg" alt="header"></p>
<p>图：将十进制数转换为八进制并输出</p>
<h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>输入包含若干十进制正整数。</p>
<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>输出相应的八进制数，每个占一行。</p>
<h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">19</span><br><span class="line">10020345</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">23</span><br><span class="line">46162771</span><br></pre></td></tr></table></figure>

<h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>书上有相应的算法，需要补充缺失的函数。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h4><p>1、数值转换使用到堆栈，但是用函数调用（系统的堆栈）将会更为方便。</p>
<p>2、书中的算法实际上只能处理正整数，你有更好的方法还能够处理0和负整数么？ 可以把负数转化成正数进行如上运算，最后把符号加上即可。</p>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>1.首先这道题是利用栈先进后出的特性进行数据存储，在进制转换的时候要利用好这点。</p>
<p>2.十进制转换成八进制的方法就是：除8倒去余，直到商为零。（倒取余显然就是栈先进后出的特点）。</p>
<h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;data[top];</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	data[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Stack A;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;num)&#123;</span><br><span class="line">	<span class="keyword">while</span>(num)&#123;                <span class="comment">//除8取余，入栈</span></span><br><span class="line">		A.<span class="built_in">Push</span>(num%<span class="number">8</span>);</span><br><span class="line">		num=num/<span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!A.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">		A.<span class="built_in">Pop</span>();             <span class="comment">//弹栈</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="问题-C-算法3-2：行编辑程序"><a href="#问题-C-算法3-2：行编辑程序" class="headerlink" title="问题 C: 算法3-2：行编辑程序"></a>问题 C: 算法3-2：行编辑程序</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<p>​           一个简单的行编辑程序的功能是：接收用户从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输入时，不能保证不出差错，因此，若在编辑程序中，“每接收一个字符即存入用户数据区”的做法显然不是很恰当。较好的做法是，设立一个输入缓冲区，用以接收用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正。例如，当用户发现刚刚键入的一个字符是错的时，可补进一个退格符“#”，以表示前一个字符无效；如果发现当前键入的行内错误较多或难以补救，则可以键入一个退行符“@”，以表示当前行中的字符均无效。例如假设从终端接收了这样的两行字符：<br>whil##ilr#e(s#*s)<br>  outcha@   putchar(*s=#++);<br>则实际有效的是下列两行：<br>while(s)<br>  putchar(s++);</p>
<p>   为此，可设这个输入缓冲区为一个栈结构，每当从终端接收了一个字符之后先作如下判别：如果它不是退格符也不是退行符，则将该字符压入栈顶；如果是一个退格符，则从栈顶删去一个字符；如果它是一个退行符，则将字符栈清为空栈。上述处理过程可用下面算法描述之：</p>
<p><img src="../images/3.jpg" alt="header"></p>
<p>​                                                                   图：行编辑程序算法</p>
<h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>若干行程序或者数据，每行不超过200个字符。</p>
<h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>经过行编辑程序处理过后的输出。</p>
<h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whil##ilr#e(s#*s)</span><br><span class="line">	outcha@	putchar(*s=#++);</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(*s)</span><br><span class="line">	putchar(*s++);</span><br></pre></td></tr></table></figure>

<h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><p>无</p>
<h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>1.这题上面的图片已经给出来思路了，只要注意用getchar()读取带空格的字符串即可。注意处理的单位是一行，换行符的转义字符是‘\n’,文件结束标志是EOF。</p>
<p>2.注意，每组数据处理完记得把栈清空；此外这里除了栈正常的函数之外，要加一个从栈底到栈顶输出的函数。</p>
<h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>; </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> data[MaxSize];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=top;i++)</span><br><span class="line">	cout&lt;&lt;data[i];</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">	data[++top]=ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	Stack A;</span><br><span class="line">	ch=<span class="built_in">getchar</span>();                              <span class="comment">//从终端接收第一个字符 </span></span><br><span class="line">	<span class="keyword">while</span>(ch!=EOF)&#123;                            <span class="comment">//EOF为全文结束符 </span></span><br><span class="line">		<span class="keyword">while</span>(ch!=EOF&amp;&amp;ch!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span>(ch)&#123;</span><br><span class="line">				<span class="keyword">case</span><span class="number">&#x27;</span>#<span class="string">&#x27;:A.Pop();break;         //当且仅当栈非空时退栈 </span></span><br><span class="line"><span class="string">				case&#x27;</span>@<span class="string">&#x27;:A.MakeEmpty();break;   //重置栈为空栈 </span></span><br><span class="line"><span class="string">				default:A.Push(ch);break;      //有效字符进栈，未考虑栈满情况 </span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			ch=getchar();                       //从终端接收下一个字符 </span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	A.Show();                               //输出 </span></span><br><span class="line"><span class="string">	cout&lt;&lt;endl;</span></span><br><span class="line"><span class="string">	A.MakeEmpty();                           //重置为空栈 </span></span><br><span class="line"><span class="string">	if(ch!=EOF)&#123;</span></span><br><span class="line"><span class="string">		ch=getchar();                         //读取下一行的第一个字符 </span></span><br><span class="line"><span class="string">	&#125;	</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	&#125;	</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>





<h2 id="问题-D-算法3-7：银行排队"><a href="#问题-D-算法3-7：银行排队" class="headerlink" title="问题 D: 算法3-7：银行排队"></a>问题 D: 算法3-7：银行排队</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们大多都有在银行排队的经历，唉，那坑爹的排队啊！现在就让我们来算算我们这些客户平均需要等多久吧。<br>每天刚开始时银行会开m个窗口来为我们total个客户办理业务，当有客户需要办理业务时，先选择可以办理业务的窗口，如果有多个窗口可以办理业务就选择空闲时间最长的窗口，如果有多个窗口空闲的时间一样长，则选择序号小的窗口办理业务。假设我们每个人来到的时间和办理业务所需要的时间（为了简化问题，采用整数表示时间）都知道了。现在请你算算我们平均需要等待多久呢？</p>
<h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>有多组测试数据，每组数据开始有两个正整数m(&lt;20)和total(&lt;200)，后面有total对整数，对应客户先后到来的时间以及办理业务所需的时间。</p>
<h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>平均等待的时间，保留两位小数。</p>
<h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 6 1 3 4 1 5 3 9 2 13 4 13 3</span><br><span class="line">3 14 0 3 2 2 2 4 5 4 7 2 11 3 12 3 12 4 12 1 13 3 15 4 19 1 22 3 23 2</span><br><span class="line">2 5 0 6 0 5 0 6 7 1 7 2</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.00</span><br><span class="line">0.29</span><br><span class="line">1.20</span><br></pre></td></tr></table></figure>

<h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><p>题目中选择办理的窗口有三个状态，实际上从序号自小到大查找可以最早办理业务的窗口就已经满足上述三个状态了。可以使用数组来模拟列表。</p>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a><strong>总结：</strong></h4><p>实际上数组既可以模拟堆栈又可以模拟队列。</p>
<h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>1.将输入的数据分组进行处理，即一组顾客按一组数据处理 。</p>
<p>2.在每一组数据数据处理中，首先把顾客数据录入，每位顾客进入银行第一件事就是寻找最优柜台（等待时间最短且序号最小）。</p>
<p>3.在找到最优柜台后对柜台的状态进行判断，如果柜台在空闲状态，顾客直接进入服务，柜台结束时间更新；如果<br>柜台处于服务状态，则计算顾客需要等待的时间，然后顾客进入服务，柜台结束时间更新。</p>
<p>4.处理完每一位顾客后输出平均时间 </p>
<h4 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> hour;</span><br><span class="line">	<span class="built_in">Node</span>():<span class="built_in">hour</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;<span class="comment">//hour为柜台的结束时间 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m=<span class="number">0</span>,total;</span><br><span class="line">  <span class="keyword">while</span>(cin&gt;&gt;m)&#123;</span><br><span class="line">  	cin&gt;&gt;total;</span><br><span class="line">  	<span class="keyword">double</span> time=<span class="number">0</span>;</span><br><span class="line">  	Node*count=<span class="keyword">new</span> Node[m];<span class="comment">//m个柜台 </span></span><br><span class="line">  	<span class="keyword">int</span> *come=<span class="keyword">new</span> <span class="keyword">int</span> [total];<span class="comment">//每个顾客到来的时间</span></span><br><span class="line">	<span class="keyword">int</span> *deal=<span class="keyword">new</span> <span class="keyword">int</span> [total];<span class="comment">//处理业务所需要的时间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">		cin&gt;&gt;come[i]&gt;&gt;deal[i];<span class="comment">//顾客信息录入 </span></span><br><span class="line">	&#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> temp=<span class="number">0</span>;<span class="comment">//用来暂存最优柜台号 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123; <span class="comment">//依次处理每一个顾客 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(count[j].hour&lt;count[temp].hour)&#123;<span class="comment">//如果被检索柜台的结束时间小于，第一个柜台的结束时间 </span></span><br><span class="line">  		temp=j;<span class="comment">//按题目要求寻找需要等待时间最短的柜台，并且按序号小者优先 </span></span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(count[temp].hour&lt;=come[i])&#123;</span><br><span class="line">  	count[temp].hour=come[i]+deal[i];<span class="comment">//如果该优先柜台结束时间早于顾客来的时间 </span></span><br><span class="line">  &#125;<span class="comment">//顾客直接进入柜台服务，柜台结束时间更新</span></span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//顾客到来时，该最优柜台正在工作 </span></span><br><span class="line">  	time=time+count[temp].hour-come[i];<span class="comment">//加上等待时间</span></span><br><span class="line">	  count[temp].hour=count[temp].hour+deal[i];<span class="comment">//更新柜台的结束时间 </span></span><br><span class="line">  &#125; </span><br><span class="line">  temp=<span class="number">0</span>;<span class="comment">//最优柜台初始化 </span></span><br><span class="line">&#125;</span><br><span class="line">time=time/total;</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;time&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="问题-E-算法3-4：表达式求值"><a href="#问题-E-算法3-4：表达式求值" class="headerlink" title="问题 E: 算法3-4：表达式求值"></a>问题 E: 算法3-4：表达式求值</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>算数四则运算的规则是1）先乘除，后加减；2）从左算到右；3）先括号内，后括号外。</p>
<p>由此，算式4+2<em>3-10/5的计算顺序为4+2</em>3-10/5=4+6-10/5=4+6-2=8。</p>
<p>给定一个以“#”作为结束符的算式，求出算式的结果。</p>
<p>给出严蔚敏《数据结构（C语言）》中的一段算法描述以作参考：</p>
<p>图1：表达式求值算法</p>
<p><img src="../images/4.jpg" alt="header"></p>
<p>图2：表达式求值算法（续）</p>
<p><img src="../images/5.jpg" alt="header"></p>
<p>图3：表达式求值算法（续）</p>
<p><img src="../images/6.jpg" alt="header"></p>
<h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>以“#”结尾的表达式，运算数为正整数。每个表达式占一行。</p>
<h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><p>输出表达式运算的结果。</p>
<h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4+2*3-10/5#</span><br><span class="line">3*(7-2)#</span><br><span class="line">2*3/2#</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">15</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h4><p>使用栈来解决本题，很多人都会想到。但怎样建栈，却带来了问题。同样，严书上的代码实际上也给大家带来了问题。看过严书光盘中代码的人应该知道，代码中使用了两个栈，一个是存储运算符的，类型为char；另一个存储运算数，类型为float。而操作两个栈的函数都一样。要知道，除非像C++中使用泛型，C语言中却基本不能实现这样的操作。所以在C语言环境中需要将这两个栈结合在一起。由于char与int有种特别的联系，可以使用int来代替char存储运算符。</p>
<h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><p>注意灵活运用栈，要是能够学习C++使用template就更好了。可以模拟STL了。</p>
<h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>这题作者本人也正在学习，等思路整理清晰再上传。</p>
<h4 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> SElemType;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> prior[<span class="number">7</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;=&#x27;</span>&#125;&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> OPSET[<span class="number">7</span>] = &#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;#&#x27;</span>&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack *s)</span><span class="comment">//初始化栈 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;base = (SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span>(!s-&gt;base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    s-&gt;top = s-&gt;base ;</span><br><span class="line">    s-&gt;stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *s,SElemType c)</span><span class="comment">//入栈 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((s-&gt;top - s-&gt;base ) &gt;= s-&gt;stacksize )</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;base = (SElemType*)<span class="built_in">realloc</span>(s-&gt;base ,(s-&gt;stacksize +STACKINCREMENT)*<span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span>(!s-&gt;base )</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        s-&gt;stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *(s-&gt;top)++ = c;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack *s)</span><span class="comment">//取栈顶元素 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SElemType e;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;base == s-&gt;top )</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(s-&gt;top<span class="number">-1</span>)    ;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">In</span><span class="params">(<span class="keyword">char</span> c,<span class="keyword">char</span> str[])</span><span class="comment">//判断是否为运算符 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c != str[i])</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Strcat</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span><span class="comment">//字符串连接函数，把字符串str2连接到str1后 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str1[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(str2[j]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str1[i++] = str2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    str1[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Atoi</span><span class="params">(<span class="keyword">char</span> *c)</span><span class="comment">//把字符串转为数字 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data= <span class="number">0</span>,d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        data = data*<span class="number">10</span> + c[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;    </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">precede</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">char</span> b)</span><span class="comment">//判断优先级函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(OPSET[i] != a)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(OPSET[j] != b)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prior[i][j];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *s)</span><span class="comment">//脱括号函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;base == s-&gt;top )</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--(s-&gt;top);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">Status <span class="title">Opereta</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><span class="comment">//运算函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a+c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a-c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a*c;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a/c;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EvaluateExpression</span><span class="params">(<span class="keyword">char</span> *MyExpression)</span><span class="comment">//算法3.4 </span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//算术表达式求值的算符优先算法。</span></span><br><span class="line"><span class="comment">//设OPTR和OPND分别为运算符栈和运算数栈</span></span><br><span class="line">    SqStack OPTR;<span class="comment">//运算符栈，字符元素 </span></span><br><span class="line">    SqStack OPND;<span class="comment">//运算数栈，实数元素 </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">char</span> TempData[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> data,a,b;</span><br><span class="line">    <span class="keyword">char</span> *c,Dr[<span class="number">2</span>],e;</span><br><span class="line">    <span class="keyword">int</span> theta;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">InitStack</span>(&amp;OPTR);</span><br><span class="line">    <span class="built_in">Push</span>(&amp;OPTR,<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="built_in">InitStack</span>(&amp;OPND);</span><br><span class="line">     </span><br><span class="line">    c = MyExpression;</span><br><span class="line">    TempData[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(*c != <span class="string">&#x27;#&#x27;</span>|| <span class="built_in">GetTop</span>(&amp;OPTR) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">In</span>(*c,OPSET))<span class="comment">//不是运算符则进栈 </span></span><br><span class="line">        &#123;</span><br><span class="line">            Dr[<span class="number">0</span>] = *c;</span><br><span class="line">            Dr[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">Strcat</span>(TempData,Dr);</span><br><span class="line">            c++; </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">In</span>(*c,OPSET))<span class="comment">//是运算符时 </span></span><br><span class="line">            &#123;</span><br><span class="line">                data = <span class="built_in">Atoi</span>(TempData);</span><br><span class="line">                <span class="built_in">Push</span>(&amp;OPND,data);</span><br><span class="line">                TempData[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(<span class="built_in">precede</span>(<span class="built_in">GetTop</span>(&amp;OPTR),*c))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                    <span class="built_in">Push</span>(&amp;OPTR,*c);</span><br><span class="line">                    c++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                    <span class="built_in">Pop</span>(&amp;OPTR);</span><br><span class="line">                     </span><br><span class="line">                    c++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                    a = <span class="built_in">Pop</span>(&amp;OPND);</span><br><span class="line">                    b = <span class="built_in">Pop</span>(&amp;OPND);</span><br><span class="line">                    theta = <span class="built_in">Pop</span>(&amp;OPTR);</span><br><span class="line">                    <span class="built_in">Push</span>(&amp;OPND,<span class="built_in">Opereta</span>(b,theta,a));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetTop</span>(&amp;OPND);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">EvaluateExpression</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<h2 id="问题-F-算法6-1-6-4：二叉链表存储的二叉树"><a href="#问题-F-算法6-1-6-4：二叉链表存储的二叉树" class="headerlink" title="问题 F: 算法6-1~6-4：二叉链表存储的二叉树"></a>问题 F: 算法6-1~6-4：二叉链表存储的二叉树</h2><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<p>树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构，其形式定义如下：</p>
<p><img src="../images/7.jpg" alt="header"></p>
<p>而二叉树的前序、中序遍历是非常重要的能够访问二叉树所有结点的算法，下面分别列出一种先序遍历和两种中序遍历的算法</p>
<p><img src="../images/8.jpg" alt="header"></p>
<p>第一种中序遍历的方法（算法6.3）：</p>
<p><img src="../images/9.jpg"></p>
<p>  第二种中序遍历的方法（算法6.2）：</p>
<p><img src="../images/10.jpg" alt="header"></p>
<p>通过一个字符串，建立二叉树的算法如下：</p>
<p><img src="../images/11.jpg" alt="header"></p>
<p>  在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。</p>
<h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>输入只有一行，包含一个字符串S，用来建立二叉树。保证S为合法的二叉树先序遍历字符串，节点内容只有大写字母，且S的长度不超过100。</p>
<h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。</p>
<h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABC  DE G  F   </span><br></pre></td></tr></table></figure>

<h4 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A B C D E G F </span><br><span class="line">C B E G D F A </span><br><span class="line">C B E G D F A </span><br></pre></td></tr></table></figure>

<h4 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h4><p>遍历是二叉树各种操作的基础，可以在遍历的过程中对节点进行各种操作。通过二叉树的遍历，可以建立二叉树。而先序、中序和后序遍历分别具有各自的特点，是探索二叉树性质的绝佳“武器”。</p>
<h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>1.此题的难点在于利用树的先序遍历建立一棵树。</p>
<p>2.从我目前学的数据结构来看，一般的数据结构题目如果采用类模板来写十分耗费时间而且容易出错，下面的代码是使用结构体和一些函数来写的，十分简洁便利。</p>
<h4 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree *<span class="title">create</span><span class="params">()</span></span>&#123;                    <span class="comment">//先序递归建立树 </span></span><br><span class="line">	<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	Tree *root=<span class="keyword">new</span> Tree;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			root-&gt;data=ch;</span><br><span class="line">			root-&gt;lchild=<span class="built_in">create</span>();</span><br><span class="line">			root-&gt;rchild=<span class="built_in">create</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(Tree *root)</span></span>&#123;            <span class="comment">//先序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">Preorder</span>(root-&gt;lchild);</span><br><span class="line">	<span class="built_in">Preorder</span>(root-&gt;rchild);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(Tree *root)</span></span>&#123;            <span class="comment">//中序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;lchild);</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;rchild);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder</span><span class="params">(Tree *root)</span></span>&#123;           <span class="comment">//后序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">	<span class="built_in">Postorder</span>(root-&gt;lchild);</span><br><span class="line">	<span class="built_in">Postorder</span>(root-&gt;rchild);</span><br><span class="line">	cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Tree *root=<span class="built_in">create</span>();</span><br><span class="line">	<span class="built_in">Preorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验——树和图</title>
    <url>/2021/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E6%A0%91%E5%92%8C%E5%9B%BE/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="问题-A-图的遍历"><a href="#问题-A-图的遍历" class="headerlink" title="问题 A: 图的遍历"></a>问题 A: 图的遍历</h1><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>深度优先搜索遍历类似于树的先根遍历，是树的先根遍历的推广。其过程为：假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可以从图中的某个顶点v出发，访问此顶点，然后依次从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止。<span id="more"></span><br>其算法可以描述如下：</p>
<p>在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法遍历所有顶点，输出遍历顶点的顺序。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。<br>以后的n行中每行有n个用空格隔开的整数0或1，对于第i行的第j个0或1，1表示第i个顶点和第j个顶点有直接连接，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。<br>输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>只有一行，包含n个整数，表示按照题目描述中的深度优先遍历算法遍历整个图的访问顶点顺序。每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 0 1</span><br><span class="line">1 0 0 0</span><br><span class="line">0 0 0 1</span><br><span class="line">1 0 1 0</span><br></pre></td></tr></table></figure>



<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 3 2 </span><br></pre></td></tr></table></figure>



<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要熟练掌握图的邻接矩阵存储方式。在建立完成无向图之后，需要严格按照题目描述的遍历顺序对图进行遍历。另外，算法中描述的FirstAdjVex函数和NextAdjVex函数，需要认真的自行探索并完成。<br>通过这道题目，应该能够对图的深度优先搜索建立更加直观和清晰的概念。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.首先要学会利用邻接矩阵构造图，第二学会深度优先遍历对图进行搜索，每访问完一个节点就给该节点做标记，并且按题目要求输出结点序号。</p>
<p>2.此题中的深度优先遍历算法只能访问到连通图的每一个结点，对于非联通图如果要访问每一个极大连通分量，就要添加一个循环，判断是否每个有边存在的结点都被访问过。</p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">55</span>; <span class="comment">//图中最多顶点个数</span></span><br><span class="line"><span class="keyword">int</span> visited[MaxSize] = &#123;<span class="number">0</span>&#125;; <span class="comment">//全局数组变量visited初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MGraph</span>(<span class="keyword">int</span> n); <span class="comment">//构造函数，建立具有n个顶点e条边的图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFTraverse</span><span class="params">(<span class="keyword">int</span> v)</span></span>; <span class="comment">//深度优先遍历图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> edge[MaxSize][MaxSize]; <span class="comment">//存放图中边的数组</span></span><br><span class="line"><span class="keyword">int</span> vertexNum; <span class="comment">//图的顶点数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MGraph::<span class="built_in">MGraph</span>(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">vertexNum=n; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">cin&gt;&gt;edge[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::DFTraverse</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;v&lt;&lt;<span class="string">&#x27; &#x27;</span>; </span><br><span class="line">visited[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexNum; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (edge[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) <span class="built_in">DFTraverse</span>( j );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="function">MGraph <span class="title">MG</span><span class="params">(n)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">MG.<span class="built_in">DFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="问题B"><a href="#问题B" class="headerlink" title="问题B:"></a>问题B:</h1><h1 id="算法7-7-7-8：无向图的连通分量和生成树"><a href="#算法7-7-7-8：无向图的连通分量和生成树" class="headerlink" title="算法7-7,7-8：无向图的连通分量和生成树"></a>算法7-7,7-8：无向图的连通分量和生成树</h1><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先搜索或广度优先搜索，便可访问到图中所有顶点。对于非连通图，则需从多个顶点出发进行搜索，而每一次从一个新的起始点出发进行搜索的过程中得到的顶点访问序列恰为其各个连通分量中的顶点集。</p>
<p>对于非连通图，每个连通分量中的顶点集，和遍历时走过的边一起构成若干棵生成树，这些连通分量的生成树组成非连通图的生成森林。</p>
<p>假设以孩子兄弟链表作为生成森林的存储结构，则生成非连通图的深度优先生成森林的算法可以描述如下</p>
<p> 而建立以p为根的深度优先生成树的算法可以描述如下</p>
<p>在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立无向图的生成森林。对于森林中的每一棵生成树，遍历所有顶点，并输出遍历顶点的顺序。</p>
<h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。</p>
<p>以后的n行中每行有n个用空格隔开的整数0或1，对于第i行的第j个0或1，1表示第i个顶点和第j个顶点有直接连接，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。</p>
<p>输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图。</p>
<h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>每一行输出无向图中的一棵生成树，表示按照题目描述中的深度优先遍历算法遍历相应的连通分量的访问顶点顺序。每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">0 0 1 1 0 0</span><br><span class="line">0 1 0 1 0 0</span><br><span class="line">1 1 1 0 0 0</span><br><span class="line">0 0 0 0 0 1</span><br><span class="line">0 0 0 0 1 0</span><br></pre></td></tr></table></figure>



<h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 3 1 2 </span><br><span class="line">4 5 </span><br></pre></td></tr></table></figure>



<h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要掌握图的深度优先遍历的方法，并需要掌握无向图的连通性问题的本质。通过求出无向图的连通分量和对应的生成树，应该能够对图的连通性建立更加直观和清晰的概念。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1.这一题和上一题大同小异都是要去利用邻接矩阵来建立图。但这题要对深度优先遍历进行优化，使其能够对每一个极大连通分量遍历输出，这个深度优先遍历方法要学会。</p>
<p>2.添加了去领接顶点和某顶点后的下一个邻接顶点的函数（关键部分仔细研究）</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">55</span>; <span class="comment">//图中最多顶点个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MGraph</span>(<span class="keyword">int</span> n); <span class="comment">//构造函数，建立具有n个顶点e条边的图</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSC</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> *visited)</span></span>;</span><br><span class="line"><span class="keyword">int</span> visited[MaxSize] ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> edge[MaxSize][MaxSize]; <span class="comment">//存放图中边的数组</span></span><br><span class="line"><span class="keyword">int</span> vertexNum; <span class="comment">//图的顶点数</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MGraph::getFirst</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//取第一个邻接顶点</span></span><br><span class="line">	<span class="keyword">if</span>(v!=<span class="number">-1</span>)&#123;<span class="comment">//当顶点存在时</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vertexNum;j++)&#123;<span class="comment">//从第v行开始，第一个不为0或无穷大的边就是第一个邻接顶点</span></span><br><span class="line">			<span class="keyword">if</span>(edge[v][j]&gt;<span class="number">0</span>&amp;&amp;edge[v][j]&lt;MaxSize)<span class="comment">/*这里就是邻接矩阵的好处，直接在第v行找和v相连的顶点就行*/</span></span><br><span class="line">		&#123;</span><br><span class="line">				edge[v][j]=<span class="number">0</span>;<span class="comment">//无向邻接矩阵在找到对应邻接顶点后要把这两条边都做上标记</span></span><br><span class="line">				edge[j][v]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> j;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MGraph::getNext</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;<span class="comment">//取第v个节点的w顶点后的邻接顶点</span></span><br><span class="line">	<span class="keyword">if</span>(v!=<span class="number">-1</span>&amp;&amp;w!=<span class="number">-1</span>)&#123;<span class="comment">//当v和w结点均存在</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=w+<span class="number">1</span>;j&lt;vertexNum;j++)&#123;<span class="comment">//循环从w+1开始</span></span><br><span class="line">			<span class="keyword">if</span>(edge[v][j]&gt;<span class="number">0</span>&amp;&amp;edge[v][j]&lt;MaxSize)</span><br><span class="line">			&#123;</span><br><span class="line">				edge[v][j]=<span class="number">0</span>;<span class="comment">//双向边都要做上标记</span></span><br><span class="line">				edge[j][v]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> j;<span class="comment">//返回顶点序号</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MGraph::<span class="built_in">MGraph</span>(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">vertexNum=n; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">cin&gt;&gt;edge[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::DFSC</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span>  *visited)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;v&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	visited[v]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> w=G.<span class="built_in">getFirst</span>(v);</span><br><span class="line">	<span class="keyword">while</span>(w!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visited[w]==<span class="number">0</span>) <span class="built_in">DFSC</span>(G,w,visited);</span><br><span class="line">		w=G.<span class="built_in">getNext</span>(v,w);</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::DFS</span><span class="params">(MGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	visited[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vertexNum;v++)</span><br><span class="line"><span class="keyword">if</span> (!visited[v]) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DFSC</span>(G,v,visited);</span><br><span class="line">	cout&lt;&lt;endl;<span class="comment">//这里补上一个换行，对于不通的连通分量中的点换行输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="function">MGraph <span class="title">MG</span><span class="params">(n)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">MG.visited[i] = <span class="number">0</span>;</span><br><span class="line">MG.<span class="built_in">DFS</span>(MG,<span class="number">0</span>,n); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="问题-C-算法9-2：有序表的折半查找"><a href="#问题-C-算法9-2：有序表的折半查找" class="headerlink" title="问题 C: 算法9-2：有序表的折半查找"></a>问题 C: 算法9-2：有序表的折半查找</h1><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>用有序表表示静态查找表时，通常检索函数可以用折半查找来实现。</p>
<p>折半查找的查找过程是：首先确定待查记录所在的范围，然后逐步缩小范围直到找到或者确定找不到相应的记录为止。而每次需要缩小的范围均为上一次的一半，这样的查找过程可以被称为折半查找。</p>
<p>其查找过程可以描述如下：</p>
<p>在本题中，读入一串有序的整数，另外给定多次查询，判断每一次查询是否找到了相应的整数，如果找到则输出整数相应的位置。</p>
<h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含2个正整数n和k，分别表示共有n个整数和k次查询。其中n不超过1000，k同样不超过1000。</p>
<p>第二行包含n个用空格隔开的正整数，表示n个有序的整数。输入保证这n个整数是从小到大递增的。</p>
<p>第三行包含k个用空格隔开的正整数，表示k次查询的目标。</p>
<h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>只有1行，包含k个整数，分别表示每一次的查询结果。如果在查询中找到了对应的整数，则输出其相应的位置，否则输出-1。</p>
<p>请在每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 5 7 8 9 10 15</span><br><span class="line">9 2 5</span><br></pre></td></tr></table></figure>



<h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 -1 2 </span><br></pre></td></tr></table></figure>



<h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要按照题目描述中的算法完成折半查找过程。通过将需要查询的值与当前区间中央的整数进行比较，不断缩小区间的范围，直到确定被查询的值是否存在。</p>
<p>通过课本中的性能分析部分，不难发现折半查找的时间复杂度为O(log2n)，这是一种非常高效的查找方法。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这题只有25%的通过率，坑就在oj中对于相等的数值查找要输出以一个找到的位置。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> obj,<span class="keyword">int</span> num,<span class="keyword">int</span> *List)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low=<span class="number">0</span>,high=num<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> mid=num/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">		mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(obj&gt;List[mid]) low=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (obj&lt;List[mid]) high=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (obj==List[mid]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(List[mid<span class="number">-1</span>]==obj)&#123;<span class="comment">//仔细思考，找第一个符合条件的值 </span></span><br><span class="line">				high=mid;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,sum,obj;</span><br><span class="line">	cin&gt;&gt;num&gt;&gt;sum;</span><br><span class="line">	<span class="keyword">int</span> List[num];<span class="comment">//表中数字已经由小到大拍排好序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">			cin&gt;&gt;List[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum;i++)&#123;</span><br><span class="line">		cin&gt;&gt;obj;        </span><br><span class="line">		cout&lt;&lt;<span class="built_in">Search</span>(obj,num,List)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//传统的二分查找法，oj上要注意多个同样的值要找第一次出现的时候</span></span><br></pre></td></tr></table></figure>

<h1 id="问题-D-算法9-5-9-8：二叉排序树的基本操作"><a href="#问题-D-算法9-5-9-8：二叉排序树的基本操作" class="headerlink" title="问题 D: 算法9-5~9-8：二叉排序树的基本操作"></a>问题 D: 算法9-5~9-8：二叉排序树的基本操作</h1><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>二叉排序树或者是一棵空树，或者是具有以下几条性质的二叉树：</p>
<ol>
<li><pre><code>  若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；
</code></pre>
</li>
<li><pre><code>  若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值；
</code></pre>
</li>
<li><pre><code>  它的左右子树也分别为二叉排序树。
</code></pre>
</li>
</ol>
<p>二叉排序树又可以被称为二叉查找树，根据上述定义的结构不难知道，它的查找过程十分简单，只需要通过不断的将当前结点的值与需要查找的值进行比较，如果相等则直接输出，如果要查找的值更小则深入至左子树进行比较，否则就深入右子树进行比较，直到找到相应的值或者进入了一棵不存在的子树为止。</p>
<p>其查找过程可以描述如下：</p>
<p>而其插入过程同样也十分简洁，可以描述如下</p>
<p>而删除操作可以描述为如下的两个算法</p>
<p>在本题中，读入一串整数，首先利用这些整数构造一棵二叉排序树。另外给定多次查询，利用构造出的二叉排序树，判断每一次查询是否成功。</p>
<h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含2个正整数n和k，分别表示共有n个整数和k次查询。其中n不超过500，k同样不超过500。</p>
<p>第二行包含n个用空格隔开的正整数，表示n个整数。</p>
<p>第三行包含k个用空格隔开的正整数，表示k次查询的目标。</p>
<h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>只有1行，包含k个整数，分别表示每一次的查询结果。如果在查询中找到了对应的整数，则输出1，否则输出0。</p>
<p>请在每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 5 7 8 9 10 15</span><br><span class="line">9 2 5</span><br></pre></td></tr></table></figure>



<h4 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 1 </span><br></pre></td></tr></table></figure>



<h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><p>在本题中，首先需要按照题目描述中的算法完成二叉排序树的构造过程，之后需要通过在二叉排序树中的不断向下查找，将需要查询的值与当前节点的值进行比较，直到确定被查询的值是否存在。</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>1.学会构造二排序（搜索）树，利用二叉排序树左子树结点&lt;根&lt;右子树结点的特性进行搜索，本质上就是一种折半查找。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">	E data;</span><br><span class="line">	BSTNode&lt;E,K&gt; *left,*right;</span><br><span class="line">	<span class="built_in">BSTNode</span>():<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">BSTNode</span>(<span class="keyword">const</span> E d,BSTNode&lt;E,K&gt; *L=<span class="literal">NULL</span>,BSTNode&lt;E,K&gt; *R=<span class="literal">NULL</span>):<span class="built_in">data</span>(d),<span class="built_in">left</span>(L),<span class="built_in">right</span>(R)&#123;&#125;</span><br><span class="line">	~<span class="built_in">BSTNode</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(E d)</span></span>&#123;data=d;&#125;</span><br><span class="line">	<span class="function">E <span class="title">getData</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> data;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">BST</span>():<span class="built_in">root</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">		<span class="built_in">BST</span>(K value);</span><br><span class="line">		~<span class="built_in">BST</span>()&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		BSTNode&lt;E,K&gt; *root;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		</span><br><span class="line">		K RefValue; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Search</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *ptr)&#123;<span class="comment">//搜索函数，类似于折半查找</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Insert</span>(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//核心，插入函数</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		ptr=<span class="keyword">new</span> BSTNode&lt;E,K&gt;(el);</span><br><span class="line">		<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&lt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&gt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line">BST&lt;E,K&gt;::<span class="built_in">BST</span>(K value)&#123;<span class="comment">//构造函数，利用插入函数进行</span></span><br><span class="line">	E x;root=<span class="literal">NULL</span>;RefValue=value;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="keyword">while</span>(x.key!=RefValue)&#123;</span><br><span class="line">		<span class="built_in">Insert</span>(x,root);cin&gt;&gt;x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Remove</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//删除结点</span></span><br><span class="line">	BSTNode&lt;E,K&gt; *temp;</span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">if</span>(x&lt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;right);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ptr-&gt;left!=<span class="literal">NULL</span>&amp;&amp;ptr-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			temp=ptr-&gt;right;</span><br><span class="line">			<span class="keyword">while</span>(temp-&gt;left!=<span class="literal">NULL</span>) temp=temp-&gt;left;</span><br><span class="line">			ptr-&gt;data=temp-&gt;data;</span><br><span class="line">			<span class="built_in">Remove</span>(ptr-&gt;data,ptr-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				temp=ptr;</span><br><span class="line">				<span class="keyword">if</span>(ptr-&gt;left==<span class="literal">NULL</span>) ptr=ptr-&gt;right;</span><br><span class="line">				<span class="keyword">else</span> ptr=ptr-&gt;left;</span><br><span class="line">				<span class="keyword">delete</span> temp; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k,j,q;</span><br><span class="line">	BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Tree;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;j;</span><br><span class="line">		Tree.<span class="built_in">Insert</span>(j,Tree.root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">		cin&gt;&gt;q;</span><br><span class="line">	cout&lt;&lt;Tree.<span class="built_in">Search</span>(q,Tree.root)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;Tree.root-&gt;data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="问题-E-二叉排序树"><a href="#问题-E-二叉排序树" class="headerlink" title="问题 E: 二叉排序树"></a>问题 E: 二叉排序树</h1><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一系列整数，建立二叉排序树，并进行前序，中序，后序遍历。</p>
<h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>输入第一行包括一个整数n(1&lt;=n&lt;=100)。接下来的一行包括n个整数。</p>
<h4 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h4><p>可能有多组测试数据，对于每组数据，将题目所给数据建立一个二叉排序树，并对二叉排序树进行前序、中序和后序遍历。每种遍历结果输出一行。每行最后一个数据之后有一个空格。</p>
<h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2 </span><br><span class="line">2</span><br><span class="line">8 15 </span><br><span class="line">4</span><br><span class="line">21 10 5 39 </span><br></pre></td></tr></table></figure>



<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 </span><br><span class="line">2 </span><br><span class="line">2 </span><br><span class="line">8 15 </span><br><span class="line">8 15 </span><br><span class="line">15 8 </span><br><span class="line">21 10 5 39 </span><br><span class="line">5 10 21 39 </span><br><span class="line">5 10 39 21 </span><br></pre></td></tr></table></figure>



<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>二叉排序树构建好了，添加前中后序遍历就行。每处理完一组数据后都要把树清空。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">	E data;</span><br><span class="line">	BSTNode&lt;E,K&gt; *left,*right;</span><br><span class="line">	<span class="built_in">BSTNode</span>():<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">BSTNode</span>(<span class="keyword">const</span> E d,BSTNode&lt;E,K&gt; *L=<span class="literal">NULL</span>,BSTNode&lt;E,K&gt; *R=<span class="literal">NULL</span>):<span class="built_in">data</span>(d),<span class="built_in">left</span>(L),<span class="built_in">right</span>(R)&#123;&#125;</span><br><span class="line">	~<span class="built_in">BSTNode</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(E d)</span></span>&#123;data=d;&#125;</span><br><span class="line">	<span class="function">E <span class="title">getData</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> data;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">BST</span>():<span class="built_in">root</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">		<span class="built_in">BST</span>(K value);</span><br><span class="line">		~<span class="built_in">BST</span>()&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Pre</span><span class="params">(BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">In</span><span class="params">(BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Post</span><span class="params">(BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> K x,BSTNode&lt;E,K&gt; *&amp;ptr)</span></span>;</span><br><span class="line">		BSTNode&lt;E,K&gt; *root;<span class="comment">//偷个懒，正常要写个返回根节点的函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		</span><br><span class="line">		K RefValue; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BST&lt;E,K&gt;::<span class="built_in">MakeEmpty</span>()<span class="comment">//把树清空</span></span><br><span class="line">&#123;</span><br><span class="line">	root=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Pre</span>(BSTNode&lt;E,K&gt; *ptr)&#123;<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		cout&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">Pre</span>(ptr-&gt;left);</span><br><span class="line">		<span class="built_in">Pre</span>(ptr-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">In</span>(BSTNode&lt;E,K&gt; *ptr)&#123;<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">In</span>(ptr-&gt;left);</span><br><span class="line">		cout&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">In</span>(ptr-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Post</span>(BSTNode&lt;E,K&gt; *ptr)&#123;<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">Post</span>(ptr-&gt;left);</span><br><span class="line">		<span class="built_in">Post</span>(ptr-&gt;right);</span><br><span class="line">		cout&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span>  BST&lt;E,K&gt;::<span class="built_in">Search</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *ptr)&#123;<span class="comment">//搜索</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(x,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Insert</span>(<span class="keyword">const</span> E&amp;el,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//插入</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		ptr=<span class="keyword">new</span> BSTNode&lt;E,K&gt;(el);</span><br><span class="line">		<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&lt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(el&gt;ptr-&gt;data) <span class="built_in">Insert</span>(el,ptr-&gt;right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line">BST&lt;E,K&gt;::<span class="built_in">BST</span>(K value)&#123;<span class="comment">//构造函数</span></span><br><span class="line">	E x;root=<span class="literal">NULL</span>;RefValue=value;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="keyword">while</span>(x.key!=RefValue)&#123;</span><br><span class="line">		<span class="built_in">Insert</span>(x,root);cin&gt;&gt;x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BST&lt;E,K&gt;::<span class="built_in">Remove</span>(<span class="keyword">const</span> K x,BSTNode &lt;E,K&gt; *&amp;ptr)&#123;<span class="comment">//删除函数</span></span><br><span class="line">	BSTNode&lt;E,K&gt; *temp;</span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">if</span>(x&lt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr-&gt;data) <span class="built_in">Remove</span>(x,ptr-&gt;right);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ptr-&gt;left!=<span class="literal">NULL</span>&amp;&amp;ptr-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			temp=ptr-&gt;right;</span><br><span class="line">			<span class="keyword">while</span>(temp-&gt;left!=<span class="literal">NULL</span>) temp=temp-&gt;left;</span><br><span class="line">			ptr-&gt;data=temp-&gt;data;</span><br><span class="line">			<span class="built_in">Remove</span>(ptr-&gt;data,ptr-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				temp=ptr;</span><br><span class="line">				<span class="keyword">if</span>(ptr-&gt;left==<span class="literal">NULL</span>) ptr=ptr-&gt;right;</span><br><span class="line">				<span class="keyword">else</span> ptr=ptr-&gt;left;</span><br><span class="line">				<span class="keyword">delete</span> temp; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,temp;</span><br><span class="line">BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Tree;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		Tree.<span class="built_in">Insert</span>(temp,Tree.root);</span><br><span class="line">	&#125;</span><br><span class="line">	Tree.<span class="built_in">Pre</span>(Tree.root);cout&lt;&lt;endl;</span><br><span class="line">	Tree.<span class="built_in">In</span>(Tree.root);cout&lt;&lt;endl;</span><br><span class="line">	Tree.<span class="built_in">Post</span>(Tree.root);cout&lt;&lt;endl;</span><br><span class="line">	Tree.<span class="built_in">MakeEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="问题-F-算法6-12：自底向上的赫夫曼编码"><a href="#问题-F-算法6-12：自底向上的赫夫曼编码" class="headerlink" title="问题 F: 算法6-12：自底向上的赫夫曼编码"></a>问题 F: 算法6-12：自底向上的赫夫曼编码</h1><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>在通讯领域，经常需要将需要传送的文字转换成由二进制字符组成的字符串。在实际应用中，由于总是希望被传送的内容总长尽可能的短，如果对每个字符设计长度不等的编码，且让内容中出现次数较多的字符采用尽可能短的编码，则整个内容的总长便可以减少。另外，需要保证任何一个字符的编码都不是另一个字符的编码前缀，这种编码成为前缀编码。</p>
<p>而赫夫曼编码就是一种二进制前缀编码，其从叶子到根（自底向上）逆向求出每个字符的算法可以表示如下：</p>
<p><img src="http://192.168.173.163/JudgeOnline/upload/pimg1344_1.png" alt="img"></p>
<p>在本题中，读入n个字符所对应的权值，生成赫夫曼编码，并依次输出计算出的每一个赫夫曼编码。</p>
<h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含一个正整数n，表示共有n个字符需要编码。其中n不超过100。</p>
<p>第二行中有n个用空格隔开的正整数，分别表示n个字符的权值。</p>
<h4 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h4><p>共n行，每行一个字符串，表示对应字符的赫夫曼编码。</p>
<h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">5 29 7 8 14 23 3 11</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0110</span><br><span class="line">10</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">110</span><br><span class="line">00</span><br><span class="line">0111</span><br><span class="line">010</span><br></pre></td></tr></table></figure>

<h4 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h4><p>赫夫曼树又名最优二叉树，它是一类带权路径长度最小的二叉树。通过构造赫夫曼树，我们可以得到赫夫曼编码，从而使得通信能够得到更高的效率。在本题中，构造赫夫曼树的过程使用了从叶子到根的逆向顺序，另外，还有一种从根出发直到叶子的赫夫曼编码构造算法，这将在下一题中进行讨论。</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>cv战士只想看懂大佬们的解法</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span><span class="comment">//最小堆要用的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> w[MaxN];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;<span class="comment">//权值</span></span><br><span class="line">    <span class="keyword">int</span> parent, lchild, rchild;</span><br><span class="line">&#125;HuffmanNode, *HuffmanTree;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *HuffmanCode;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seletTMin</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n, <span class="keyword">int</span> &amp;m1, <span class="keyword">int</span> &amp;m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = INT32_MAX;<span class="comment">//int32_t.max=2147483647</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; min &gt; HT[i].weight)</span><br><span class="line">        &#123;</span><br><span class="line">            min = HT[i].weight;</span><br><span class="line">            m1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    min = INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; min &gt; HT[i].weight &amp;&amp; i != m1)</span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            min = HT[i].weight;</span><br><span class="line">            m2 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (m1 &gt; m2)</span><br><span class="line">        <span class="built_in">swap</span>(m1, m2); <span class="comment">//交换，这一段必不可少，不然构造出来的编码是不唯一的</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree &amp;HT, HuffmanCode *&amp;HC,<span class="keyword">int</span> w[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    HT = <span class="keyword">new</span> HuffmanNode[m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        HT[i].weight = w[i];</span><br><span class="line">        HT[i].lchild = HT[i].rchild = HT[i].parent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        HT[i].lchild = HT[i].rchild = HT[i].parent = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m1, m2;</span><br><span class="line">        <span class="built_in">seletTMin</span>(HT, i - <span class="number">1</span>, m1, m2);</span><br><span class="line">        HT[i].lchild = m1;</span><br><span class="line">        HT[i].rchild = m2;</span><br><span class="line">        HT[m1].parent = HT[m2].parent = i;</span><br><span class="line">        HT[i].weight = HT[m1].weight + HT[m2].weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    HC = <span class="keyword">new</span> HuffmanCode[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> * cd = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = i, f = HT[i].parent; f != <span class="number">0</span>; c = f, f = HT[f].parent)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c)</span><br><span class="line">                cd[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        HC[i] = <span class="keyword">new</span> <span class="keyword">char</span>[n - start];</span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], cd + start);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> cd;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"> </span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">    HuffmanTree HT;</span><br><span class="line">    HuffmanCode *HC;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> data[MaxN];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            cin &gt;&gt; data[i];</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">HuffmanCoding</span>(HT, HC, data, n);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            cout &lt;&lt;  HC[i] &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">delete</span> HC;</span><br><span class="line">        <span class="keyword">delete</span> HT;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h1 id="问题-E-算法7-15：迪杰斯特拉最短路径算法"><a href="#问题-E-算法7-15：迪杰斯特拉最短路径算法" class="headerlink" title="问题 E: 算法7-15：迪杰斯特拉最短路径算法"></a>问题 E: 算法7-15：迪杰斯特拉最短路径算法</h1><p>时间限制: 1 Sec 内存限制: 32 MB</p>
<h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>在带权有向图G中，给定一个源点v，求从v到G中的其余各顶点的最短路径问题，叫做单源点的最短路径问题。</p>
<p>在常用的单源点最短路径算法中，迪杰斯特拉算法是最为常用的一种，是一种按照路径长度递增的次序产生最短路径的算法。</p>
<p>可将迪杰斯特拉算法描述如下：</p>
<p><img src="http://192.168.173.163/JudgeOnline/upload/pimg1352_1.png" alt="img"></p>
<p>在本题中，读入一个有向图的带权邻接矩阵（即数组表示），建立有向图并按照以上描述中的算法求出源点至每一个其它顶点的最短路径长度。</p>
<h4 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含2个正整数n和s，表示图中共有n个顶点，且源点为s。其中n不超过50，s小于n。</p>
<p>以后的n行中每行有n个用空格隔开的整数。对于第i行的第j个整数，如果大于0，则表示第i个顶点有指向第j个顶点的有向边，且权值为对应的整数值；如果这个整数为0，则表示没有i指向j的有向边。当i和j相等的时候，保证对应的整数为0。</p>
<h4 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h4><p>只有一行，共有n-1个整数，表示源点至其它每一个顶点的最短路径长度。如果不存在从源点至相应顶点的路径，输出-1。</p>
<p>请注意行尾输出换行。</p>
<h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">0 3 0 1</span><br><span class="line">0 0 4 0</span><br><span class="line">2 0 0 0</span><br><span class="line">0 0 1 0</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4 7 </span><br></pre></td></tr></table></figure>

<h4 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h4><p>在本题中，需要按照题目描述中的算法完成迪杰斯特拉算法，并在计算最短路径的过程中将每个顶点是否可达记录下来，直到求出每个可达顶点的最短路径之后，算法才能够结束。</p>
<p>迪杰斯特拉算法的特点是按照路径长度递增的顺序，依次添加下一条长度最短的边，从而不断构造出相应顶点的最短路径。</p>
<p>另外需要注意的是，在本题中为了更方便的表示顶点间的不可达状态，可以使用一个十分大的值作为标记。</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>cv战士不做挣扎</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3fffffff</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = inf;<span class="comment">//距离为最大 </span></span><br><span class="line">        vis[i] = <span class="number">0</span>; <span class="comment">//未访问过 </span></span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span> &amp;&amp; dis[j] &lt; min)<span class="comment">//找到未访问中最小的点 </span></span><br><span class="line">            &#123;</span><br><span class="line">                k = j;</span><br><span class="line">                min = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = <span class="number">1</span>;<span class="comment">//加入访问后的集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;dis[k]+a[k][j] &lt; dis[j])<span class="comment">//没访问过 </span></span><br><span class="line">                dis[j] = dis[k] + a[k][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=s &amp;&amp; dis[i]!=inf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=s &amp;&amp; dis[i] == inf)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;s)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</span><br><span class="line">                    a[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        dijstra(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>第三届全国大学生算法设计与编程挑战赛</title>
    <url>/2021/10/26/%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="Problem-A-分组"><a href="#Problem-A-分组" class="headerlink" title="Problem A    分组"></a>Problem A    分组</h2><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p><strong>本题共 10 个测试点，每个测试点有 4s 的测试时间,可用内存为512MB</strong></p>
<p>小A是个热爱学习又心怀热忱的好孩子，于是他参加了今年的支教活动。</p>
<p>在希望小学一个平凡的下午，小A带着同学们做课外活动，活动十分丰富，有跷跷板和跷跷板，甚至还有跷跷板！但器材有限，这里只有K个跷跷板，因此小A决定对孩子们进行分组。</p>
<span id="more"></span>

<p>小A支教的班级一共有N名同学，站成了一排等待分组，从左到右依次为第1～N名同学。</p>
<p>小A需要将这N名同学分为K组，<strong>每组可以有1或2名同学，但不可以为空</strong>。同时，这些同学<strong>很有个性</strong>，只愿和相邻的同学一起玩。因此，对于任意一组，如果这一组有2名同学，那么他们必须相邻。</p>
<p>当然这样分组很可能会导致某些同学不属于任何一组，此时，小A会安排这些同学去玩别的游戏。因此<strong>允许某些同学不在任何组内</strong>。</p>
<p>小A最近也在准备大厂面试的算法题，于是很快就想出了最佳方案。勇于挑战自我的小A提升了上面问题的难度，开始计算起<strong>将这些同学分为i组(1\leq i\leq K)(1≤*i*≤*K*)的方案数</strong>。聪明的你能帮帮小A吗？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入共一行，为两个正整数N和K（1≤N≤10^91≤<em>N</em>≤109,1≤K≤2^{18}1≤<em>K</em>≤218），含义如题所述。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出为一行，共 K<em>K</em>个整数，以空格分开。</p>
<p>第i个(1≤i≤K1≤<em>i</em>≤<em>K</em>)整数表示将这N<em>N</em>名同学分为i<em>i</em>组的方案数。由于答案可能会很大，只需要输出方案数对998244353</p>
<hr>
<p>取模的结果。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 13 7 1 0 0 0 0 </span><br></pre></td></tr></table></figure>

<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Problem-B-二进制"><a href="#Problem-B-二进制" class="headerlink" title="Problem B 二进制"></a>Problem B 二进制</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>你是一个算法爱好者，在努力学习计算机知识。你知道，计算机最优美的地方在于二进制，这一点你在状压dp里面深有体会，当然二进制用在xor,and,or时也非常巧妙，更不用说nim游戏都能跟xor扯上关系了，而今天你又遇到了一道二进制的题目，对于爱思考的你，决定一直要把这道二进制题给切掉。</p>
<p>你遇到了很多十进制的数，对于这些数，它们都管理着它们对应的分层，比如数字6，它的二进制是110，则它管理着4(100),2(10)4(100),2(10)，两个分段，当数字6在[2,4][2,4]区间上增加3时，则代表二进制(100)(100)和(10)(10)两层在[2,4][2,4]区间增加3。</p>
<p>本道题有两种操作，读入一个opt<em>o<strong>p</strong>t</em></p>
<p>opt<em>o<strong>p</strong>t</em>为11时 :读入一个数a_i<em>a**i</em>，一个区间l_i,r_i<em>l**i</em>,<em>r**i</em>和一个增加的值k_i<em>k**i</em>，表示在这个数管理的分层中的每一个区间增加k_i<em>k**i</em>值。</p>
<p>opt<em>o<strong>p</strong>t</em>为22时:读入一个数a_i<em>a**i</em>，一个区间l_i,r_i<em>l**i</em>,<em>r**i</em>，表示询问这个数管理的分层中每一个区间的值的总和。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数n,q<em>n</em>,<em>q</em>，表示n<em>n</em>表示区间长度(1 \leq l_i \leq r_i \leq n \leq 100000)(1≤<em>l**i</em>≤<em>r**i</em>≤<em>n</em>≤100000)，q<em>q</em>表示有q(1 \leq q \leq 100000)<em>q</em>(1≤<em>q</em>≤100000)次操作。</p>
<p>数据保证(1\leq a_i \leq1024)(1≤<em>a**i</em>≤1024),k_i<em>k**i</em>在int范围内</p>
<p>后面q<em>q</em>行，每行首先一个数opt<em>o<strong>p</strong>t</em>表示进行的操作</p>
<p>opt=1<em>o<strong>p</strong>t</em>=1时后接整数a_i<em>a**i</em>表示管理分层，l_i,r_i<em>l**i</em>,<em>r**i</em>表示区间，k_i<em>k**i</em>表示增加的值</p>
<p>opt=2<em>o<strong>p</strong>t</em>=2时后接整数a_i<em>a**i</em>表示管理分层，l_i,r_i<em>l**i</em>,<em>r**i</em>表示区间</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>对于每个第二个操作，输出一行表示询问的答案。</p>
<h3 id="Sample-Input-1-1"><a href="#Sample-Input-1-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 3 1 5 2</span><br><span class="line">2 1 1 2</span><br><span class="line">2 3 1 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1-1"><a href="#Sample-Output-1-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>第一次进行1操作，3(11)管理(10)和(1)两个分层，(10)层的[1,5]区间加上2，(1)层的[1,5]区间加上2</p>
<p>第二次进行2操作，1管理(1)一个分层，(1)层的[1,2]区间和为4，所以答案是4</p>
<p>第三次进行2操作，3(11)管理(10)和(1)两个分层，(10)层的[1,2]区间和为4，(1)层的[1,2]区间和为4，所以答案为8</p>
<h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Problem-C-不正方形"><a href="#Problem-C-不正方形" class="headerlink" title="Problem C 不正方形"></a>Problem C 不正方形</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>今天是数学课！小A发现同学们上课很消极，于是给大家出了一个数学小游戏。</p>
<p>小A在黑板上画了一个很大很大的平面直角坐标系，然后给出了若干个红点和黄点，现在同学们需要回答，这些点能否构成一个<strong>不正方形</strong>。</p>
<p><strong>不正方形的定义为：四个点构成一个凸四边形，且相对顶点颜色相同，相邻顶点颜色不同。</strong></p>
<p>为了降低难度，认真的小A保证不会有重点（即不会有两个点坐标相同），也不会有三个点共线的情况。</p>
<p>同学们觉得很有趣，但这个问题对于小朋友们还太难了，聪明的你能帮帮他们吗？</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>第一行两个正整数，n、m。</p>
<p>接下来n行，每行两个整数x和y，表示红点的坐标。</p>
<p>接下来m行，每行两个整数x和y，表示黄点的坐标。</p>
<p>1&lt;n,m&lt;=250,\ 1&lt;=x,y&lt;=10^71&lt;<em>n</em>,<em>m</em>&lt;=250, 1&lt;=<em>x</em>,<em>y</em>&lt;=107</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>如果能构成，输出“YES”；否则，输出“NO”。（不含双引号）</p>
<h3 id="Sample-Input-1-2"><a href="#Sample-Input-1-2" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1-2"><a href="#Sample-Output-1-2" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>

<h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>蒻苟水分日记</category>
      </categories>
      <tags>
        <tag>算法 竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>java知识点总结</title>
    <url>/2021/10/23/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1.单行注释"></a>1.单行注释</h3><p>格式：//注释信息</p>
<h3 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2.多行注释"></a>2.多行注释</h3><p>格式：/*  注释信息  */</p>
<h3 id="3-文档注释"><a href="#3-文档注释" class="headerlink" title="3.文档注释"></a>3.文档注释</h3><p>格式：/**    注释信息  */</p>
<span id="more"></span>

<hr>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="1-关键字描述"><a href="#1-关键字描述" class="headerlink" title="1.关键字描述"></a>1.关键字描述</h3><p>关键字：就是被java语言赋予了特定含义的单词</p>
<h3 id="2-关键字的特点"><a href="#2-关键字的特点" class="headerlink" title="2.关键字的特点"></a>2.关键字的特点</h3><p>2.1关键字全部小写</p>
<p>2.2常用的代码编辑器，针对关键字有特殊的颜色标记，非常直观</p>
<hr>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="1-常量概述"><a href="#1-常量概述" class="headerlink" title="1.常量概述"></a>1.常量概述</h3><p>在程序运行过程中，其值不能发生改变的量。</p>
<h3 id="2-常量分类"><a href="#2-常量分类" class="headerlink" title="2.常量分类"></a>2.常量分类</h3><p>字符串常量 ：用双引号括起来的内容</p>
<p>整数常量：不带小数点的数字</p>
<p>小数常量：带小数的数字</p>
<p>字符常量：用单引号括起来的内容</p>
<p>布尔常量：布尔值，表示真假，true，false</p>
<p>空常量：一个特殊的值，空值null</p>
<hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型包括基本数据类型和引用数据类型。基本数据类型包含数值型{整数（byte,short,int,long）,浮点数（float，double），字符（char）}和非数值型{布尔（boolean）}。引用数据类型包括类（class），接口（interface），数组（[]）。</p>
<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="1-变量概述"><a href="#1-变量概述" class="headerlink" title="1.变量概述"></a>1.变量概述</h3><p>变量是指在程序运行过程中，其值可以发生改变的量。</p>
<h3 id="2-变量定义"><a href="#2-变量定义" class="headerlink" title="2.变量定义"></a>2.变量定义</h3><p>格式：数据类型 变量名 =变量值；</p>
<h3 id="3-变量的使用"><a href="#3-变量的使用" class="headerlink" title="3.变量的使用"></a>3.变量的使用</h3><p>取值和修改</p>
<h3 id="4-变量使用的注意事项"><a href="#4-变量使用的注意事项" class="headerlink" title="4.变量使用的注意事项"></a>4.变量使用的注意事项</h3><p>变量名不能重复</p>
<p>变量为赋值不能使用</p>
<p>long类型的变量定义时，为了防止整数过大，后面要加L</p>
<p>float类型的变量定义时，为了防止类型不兼容，后面要加F</p>
<hr>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><h3 id="1-标识符概述"><a href="#1-标识符概述" class="headerlink" title="1.标识符概述"></a>1.标识符概述</h3><p>标识符就是给类，方法，变量等起名字的符号。</p>
<h3 id="2-标识符的定义规则"><a href="#2-标识符的定义规则" class="headerlink" title="2.标识符的定义规则"></a>2.标识符的定义规则</h3><p>标识符由数字，字母，下划线___,美元$组成</p>
<p>不能由数字开头，不能是关键字，区分大小写</p>
<h3 id="3-常见命名约定"><a href="#3-常见命名约定" class="headerlink" title="3.常见命名约定"></a>3.常见命名约定</h3><p>小驼峰命名法：<br>1.标识符是一个单词时，首字母小写</p>
<p>2.标识符有多个单词组成时，第一个字母单词首字母小写，其他单词字母大写</p>
<p>大驼峰命名法：</p>
<p>1.标识符是一个单词时，首字母大写</p>
<p>2.标识符由多个单词组成时，每个单词首字母大写</p>
<hr>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="1-自动类型转换"><a href="#1-自动类型转换" class="headerlink" title="1.自动类型转换"></a>1.自动类型转换</h3><p>把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量</p>
<p>​                                             数据范围由小到大</p>
<p>byte -&gt; short -&gt;int -&gt;long -&gt;float -&gt;double</p>
<p>char-&gt;(指向short)</p>
<h3 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="2.强制类型转换"></a>2.强制类型转换</h3><p>把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量</p>
<p> 格式：目标数据类型 变量名=（目标数据类型） 值或变量</p>
<p>范例：int k=（int）88.88；</p>
<hr>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>随手记</title>
    <url>/2021/10/27/%E5%B0%8F%E7%A7%98%E5%AF%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="傻瓜不知道密码还想看我的秘密？" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="dbbc4143de9deea4d05df0402971c2fd753bfce9ab4830e87bea2f6a199a17a2">4630436162ade97ba2718b7d0c4b3b63501b8b0e90dd70c68cacef77fafaa69c73d49a7156173c422d6734de366dde9d5fecd900b2df01a8c98b7476333a840598dee0dfe1bfba9f459fd97d4287d9cc42d6cec2cef86ed0c53d1caca01938c63454e314b09f8bd28b0404acb69b00633346c197b926c957c4991dbab9a73e1480414b31272b423d970840e8318460bc6ff61c3d49965abb139361ffb0f95007f9a372dfb98d038952f6bee686e8d52185c055103f0679c799d3b07336a1bbecf03372524ee865886dc52ad8e7e88f243394d99bd7653c4a4e19f486d12026b43e9d1e36105a4eda1781da2c1c55a896ebafd9c43b1ad29f9836784ef67270aac781c414b6d7c7deee5e5d4e9847105ece31aef684a74289130a15728af0bb58ab14f2c1e4ba482a811e49a12e8ae912270bbc17f9359fde974d42b5fd40c79984b0b23dcbba0d2803e9be3033aa149f906eb33bc07ed46f0c8c1ce52e4547849a814b7afb778f6e19d781076739e9a7554ecf8667690ce0170d524d5c516c9896fc57904ae3b6dc135d66673e238a951f884fac72371351d6c23b5f08b0bbe2b60811e0d41a5ab5c5e5f4a9f78a5c5329386e815ebb3200c52a8aef556bef0658b8a7ecc084ccb1a1713de800c2650a5265e0dbc3add4c373377787df33ae7550014a36a71d56a1ac8851dde177789c38dbae6e2d48c3053bfb1b998ebc18e886213934426b1f603230f19a102d70af95210a8400bc3dbe3301ed0c621287fded2743b0a74e1916dca5dba16417223cadf0101f8a8926f01d51abd6abc4797470bd360d07223b0e81b12c1197dfd0dc38f68312a2d3622b7adecb5922f67e0ab54a6180aae4c8a36c710cd717c8dcc1387b06499a8bea3499dd4beb7143ee976110e6a81f56ed58e75e2d64317d0889290b94493e219caad98fbf2f62490eada79e3e442c2cf3c28a73264f19059c975232322ef13df8cddd6cd83482e057567f7fc6b8e7daa5870a745320b563306f1dec2b3895383f9c078db96ac5350e6df4d13e7435f49564f733530004fa6b03f125a4fafca75cabd450f61077a5d4ad9b2d402fc624f151f033a16bb8d3f5ebb5037fe613650ac18eaf9696cc6640b8614797d28b3b23bb7aa2afbbfd22eb587ef4d3525f35b05463993a5e5495f3fcfa16a970561cbcdbb95efa99652d15633ef8f0b91ec3d901f84636f6bffa902bfebbfe486b104ad6e8d0195edee959ba60d568d3350938c2710aa1a865116711c2c9e654b3cb4fd72bec6dffc105a9454c9b927189d0cfe4960d052d04663cc84a6a316cbfbc5f8fcbe76b64f0854ae3dccdeb95a8303df385699f984756af6e67b99583a7b222096fa77a4fa104dae4734bb9390aab64b288a780928f3a274c746edb6fa9c92a36c4b34c1cd941717e6be71b8e0a4f92210be0faf43c7758b1a65944ff2c9d8c18950a120ec4157a4e0b3661fa3d904a95b52784a58100b6ee31223284b1550b54cb41fa0ffdd96450330d0cf34300ab8fef2b819fb7f6fc88961813b2340969fc1c2444282cfe28ab6fd84ce996dfb63f2cf0b48e7f5215b26ea8208274d1a22f1bab279ac9c78cec82a09b582ea6e2ccd0d03df25bb11361508ed30f36ac5756c2ce9304325ceeac0b20844aa7c47fdd083849107a1fbd5e43c529eb80757203ac99e395f1586cef3c46455cf365222c6b78f5bbc6b3d2e4e45f108249f89ddf964efea6b3d57e0891789b4522fcc3f92e3823d8300dc505ff9aa98485a8ed74e8b7b178f5b42bd154d9f1aa1ccf20a128e57e4467c584a7522c65d944455ff506a23fbe45e54d7a67bcedad5b57ff540f94c5c689c5f032b721b1c429fc0f9ec09197f873214f9ce9de6c88215d40a3d6b4707306481af58c8a1ec304f1a56dc0c1a347cc4d7210820676ce0356a7eae308bd299c92649790c1cd81f82cbb9a4019d3a90f5efa88638775020ef5f886bebf51aaf7981ec18d916be38099fecf52982e457c34baf68331e45e565dd5c1cd3a2f63edaa2cba3a38c72947dc8149d298305a8fbf1e373430924345822378c2bc111e29f970f85f5ec7d639095f6f041460fa33927309ad8272a75faa672c67f875dfcd639a4e06ec51701c8c24ec715cd931445129d9765dcd460a9430abbe74e39db86e2693477e4cdeea858bcc7587844c9a4fda846e0987c08ada906998375e238c8154148e7a89fae0a390b69d3689176504a89ec08fff23dc6d3439419d973a8c7670e64172d45b87eafb160d84418d9003a1c322ae1a0270b777c20b4ef79709c6049b6f9b53f441f44b407ac25cff1d6657b043a9486498ce66e8b57fcc6126cd8cc9356635f16005885ed477ae8dddf73c7b105db6f10ec3ebe822ff0396cc113c6c72a976fe805a589d902c99da60875b15d91616834b6c370c5ef9be29a7fde44b8887c39b44c12bc4648cd45f15ae0aa913fe4417b1c536b978c7e881bdf3d700c7cb4ec0c3a52f82bc50e14e18c4f6e5c8f32926d0c818a8de0187382d469208750a5710b0cab5a98ac562ff24662cc87a58e5ad1e45ad1f27339b0f1f7b396aaf09b1c38a68551919e1ae755849a76752bfcc638c507406c88b1820beb8dc7091c9271586c119fbe1685d1159ddd1dbbb4099fbe21c3ae8a94c9a35359ffb5d6a1b6e06779d248477e43aa1f0801a0d40e29ba122f566dc82853543d95313c75b90961e5522072abd3ac9b1246d14c643a3e9c9146fcb3f5114886402b5c12b0df81863bd76834e8a27686699203295ba5dd079189726b56af079285b2cf8ff1486b4a9ebc5d1fcac82ab30cb44a420b4a818dcbaecf8b26ec3ee10bc5624cd4a13cf55b3af65e61d62220550949d4e9af8d3d807efec0de4a1f15c4748a1fe34b9792d538bc90919dfc54d0bdbef8669c0c907475afe3f5aff3634ad02997abf4c13656e41128e7d767d6d1f8effd417aa0feefdf3e74e6fb0fc60da3e0d18b55ccbd4a529c37fb7d4d9334275a95cf32dd765c0cc4b481661327e4dfd00d093ff7c18591ed782a8608581aae5e1d3f61ae91555472c26a89f6c01ba321fca050914ea84174dad96c5e56d45ffc33bbec23c9dd83fb0e3b29e54ca4e4ae2ad519f84d10bd28abd24b10cdacba1c7701ba3dbeed02b2dc8d2071a1d1d4c7ed459990a376107b843bbddad8f42479a5aff27b972d70dcfee738352ba1e3b42d3f3ba49654bca8a9a0c9de859281cc6b82d3f030db5cdddbf774bc7418e8f6e999e2b80ba9627cd765e5a3354be4dbef32f4baf8085b21eb94cb44ea1dc7fcd28b355e911703ea0c7bd8b128465ce504f54eee6b9f73b423ee238d28c9c1e4d09482d0ee470483a8aa06d323a10bbd3f4cabcd21efac416517169b603d7ef93d53d31a229b11b582809a1f768bfa4a10082f5d2d37c31d72e6107a89f62158e203282f2c9a5c40ddda02d5496abf5a9fc3bea65fa69dc6f6847168bb87ae380e1fffdcc1fdbe2d96ac6b9546c3fcb722db605e789925d483585a5af56a2b4e52761bb1d95ab2eaed44c8b35f5794fc0610cf7863debfc16ad26341583adb61f6f2b1598a5fb0478c26c092ec2accc0725041f42d505a378b0a82e73efa032b065dc607573c0a0e8a3b4448b4c934857d257ea23dd102d2d53eb67ad50721bf7e3bd790142df5794eef17dd6111f7f6d41c6e14da0d37e43bc898d812a1ef304cfd1cd8998e2e09299a4e174303759273dc2aeb107423e04f81a3691d676e6fe1e944872be7a2cc8bf2d2f2dbb7b035cf2ff524e7105a9f4fca043baabf6dce707e40094f0ee7877ac03a8f02a4120281835569fec938d68dfa3a8210d66aa1cbf399f2093375ba12c318a3386cb61c06c44a43b6bce521ad86c0dd0ca05808a519c0c4d0c01a4f82483f310d6775178abcf31385a92cfc55f771d5936cf5b89162d9d9768f9fbaacc15996725d282eed88dd1fd1c8877fafc79dcf50df836c30d912f8e673aad499f3c687eb5cd28e0950c02dd3c076931672f81169d9d8b664f800be31835bafa2d02842d0ba4e8d70f8afa489887032a36890987d661f95cb8328e9ad5bfd805e0519236377f5895d4176e7b37ff9290120ac2109ec4f8a7d5c1c10dc8f48c7f800b9411085a236c4e0dca9d2d0d89368afb62570747b726c160c840a4c63fd380a074017f5c9e214c04e9caa19bb4f50c71977c792faaea0bbc86622cead4379abf3087fa8664f1d45604f033b22e4bbc394422d50bd4b48f110f0e80763fa64d32cbb822e76c743ec7192b1a0aac3ab4315d8db799dcc26e6a93ad4c29686e7da93b7611d590b5fd20e8dd0ce390f68e0dd72594480612d3a3b1d2c3c2e31f663d97b6321d4f1b33bb5e281fbae444b4d931eb33d8c5ada45409f9efbf41d94ccc48f5f3520a3f0798ef4f9786ac16123ce1eec6b07947bceb38b4475c758431000a91963cbd2ad4483c9e84e09d9f681c28381906a005183abf5912d735fea694144c5bd61c254f442024df89347446592885ef985bd8f7710a902bc1d01ec6aeb5dc8305cf56c572f87fa792b8c17dffd06dd534deb9cf17c053eacbb6e0957719e10f50d6aa986e7a903c945dc03750c4e5a184aeb94e670c63170eb9523af18414080d062b303dedb99bd11eaadaf79a6732963488a3bb674278cd85783f3ba0040d0e41972978dd4fdad3a42b1055ad430533c5d88701279ce84b2364922e766dfe905d47017ce39a3623aa44c959e17a9ca562b20b7753957855fea3d86cffc305162904e0a6b5332cf7ecf2373d0925c958cfd31ffeca5c33bc7e2ffab982a8310acabecbbc5cce3c70e67b8a69330937e0ddeda42be1ff527b57812da9e1dd2e3de051c06ce46d73a78f60dea137bed172ec86623476e16016392b15c21227aa1e53b9543264611f3fdab13e010917bf5f01ee2f07fdf58d7e90600013f0267a0d54cbb58a72b7f0848e39c2f5336c8d5f9f76996d71cfc15a7c1352d003238cd8155f11d9051a81659645442d8a92e4a0e3d123347dbedf71cbe1ed715cdff816f7d3628a57f0e70d66133eef304fda96e3f72bff884ea0acee04ab7616bb7e740c9e9d3819965961e5b6296acc084d2fbadc3653b3d7fa977d329282bb16360fe3030322c5122f6eeaabcc24c9053b345e8ba325f4fe130a2a34d2a520f066ee3ca7d85bbfad74f9ee2eed6f2a5f6f978d9982bcb866e81a34ac5cb4eb7ac80c2e7d0fef75deef3f6e136582e8e2886ba0eb988b0825be459f56d25115e86cedad33ac78251cb5a71be7a7911ba789865ac8a4e1327f1e717a1fe797393b546e43a0658a292847c5f6c586ee5a950473c253df022d83899ce9b82ddff6fbd05350e0dc12c845ec8bc41660e8b8fec4101cf04085a5e8d92eb744e1407decb1f003b3978f5c71fbd40cb4d02a37b80330fa2cb0b36143e595082fb4ef1c7ebcc2c480b7323d0d79ddb33526d0f359b0ad9da22abd54d19cdfd289f5a716eb8fe6c3110a5a96b805b4d3ca98d2d6bfd1fc116e6e4ae0a08907ae37c6547d19131bb22d95d14470a8c4aff73b1497a7412fbbd673709faa62264b109909c91d2dcabd8a94c537e5ffa9731aff7cbd647d59521cfc3b50520da460bf7da48c28de9a03e4c034a0d23f52a982451032dfe6d1b50256fdd7354d73f4c51a9bcb6c12809c8ffc6f04e2c48e708afe545b9595fc4b890b1bd9a64ef8c86a4053a5594dbb23e02983676820155de871766c3e8c4ef6a1d35f54decc15779fcafb488b7ac783bb36dc31bbda4364197a539a6dec29e5e63e57c6197ca58b0c6d141a67e68a9dc75cacde0adb53f609d545641830805448b07ba7c6623fadaea7bf72f5035ec6c12b39954e7493108b91c487d82abeeb1f6819e9766905553fb856d964ea47dfac411de6bb51fb6e53c6ad8236acc06e9aaae550aab4f13b7e6c9799ac1117fe870a2eb7fa3e9f42e4f3d933297352248cdcba58b971471db667df9a3afee28134b157037ed7ace34c3fa16dd5b930b27027566280d4dc598470cd0e84f0cc71cd048cf9203c316552f1360b01603d79e186427e2498431316925a6b43472131b1c266131a708ff936e96a95b86f2304edf27713f9f071e293f66876c81eb79956a41b30263df91e777c6c00c39b97e547f5f1195aa3d02d70af647e9c36f9b63923d957f5cba7e9d2b16388e6c64e163576d038af2e2a0363f2acf197e3e155190ac54995ebbd3b4a25d497bd6befcca192ae75b2e501228f077136bdc8d747cbd8e6d641623c4cf0f49615fd5997b2227040f32e859bd24799504cbab8933773bab029d5abeba60d597737a6e6d52f9d2dee5a750947dd940ae8fd04602cf5cad641bd25a95c0308928d55319d470ce77b2fe954867331ca417262535446203332334f138782a0bf537fd5710d4405687aaf1586c3956f5981dc5bd59cfe2bfc6c60c0cc8e4e5df4b66dcb04e6cdaee7cfb9516613dc268ed8fda9f1ac020abf1a64bcd382959be2b4a320ec2ae26c74ee0fe75b1ca039d10f8392dd01c6e0ea5d7797ef34093c77f63fabf3046739a9b1f9c27120988110ab8cd9a59e3caebb430dd05e0f5f81ea0defdf843f8e4e4efe47f46f1e1de101a2f1e7e4d3c5d792a57dd614733a20356dc83d29f96ce01d7438ac00f0d3c4dd9295cedf7b8765292b0c18503246f1cc2d2b02cb60281072ac6b01d8bded5e7e3e9a54f99d122ef9dd91d241a345db29ca6959efb0d320415f0d362eba206ac1637f375667d43ac15feac2709112770efe12708f88d2ba0358bdfc21d5964f555c21100c4834c823557dbb752bfdbf2697ef97a7e71a5e86edd074d0540a02e2eebb201437b27faad5bbbff4b1d7f41cdbb3ded02e96728edbb20f0dad723c01aac059f57cbc0b94044b121bf33e2d12f22cbdcae6596a9113ecd9d8b23229dd75548156c9cd13a5bda1897b304c4df881637b3d11e317004ec3137b9fe9b4ed6adfc191266e3edc20ea1c15521b3be77921a7109ae2bd95a45ce142a3660ea12d10e2111bcb76efc1b9f7d17c74b8606188252e081db4fc72475722ed81377ec1016bf4394795b238bb261f41fc735887099b9bafc80612ae212d274fa5d1650421554bf77342a7a8961a5ad891091e2307bf40a113e42c21b48c973fd97bd62ef48cd9ba22d58048faf47c8dfe1e2987bc9a676df35a99648a823b01fd4bac1893d0d77517dedd48bd870e820c213e62d4e2a91fef1ef739</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码拿来</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL笔记</title>
    <url>/2021/11/09/MYSQL%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="MYSQL常用命令"><a href="#MYSQL常用命令" class="headerlink" title="MYSQL常用命令"></a>MYSQL常用命令</h3><p>1.启用/暂停/退出MYSQL服务：启用——&gt;net start mysql80(最后的是本机的mysql 服务名称)//必须要以管理员身份运行命令行cmd，本机已经设置cmd默认管理员身份运行。</p>
<span id="more"></span>

<p>​                                                      暂停——&gt;net stop mysql80</p>
<p>​                                                      退出——&gt;exit                            </p>
<p>2.查看有哪些数据库：show databases;(注意mysql命令以英文的分号;结尾)</p>
<p>3.使用某个具体数据库：use 数据库名;</p>
<p>4.创建一个新的数据库：create database 新数库名;</p>
<p>5.查看某个数据库下有哪些表：show tables;</p>
<p>6.登录mysql： win+R cmd 后  mysql -uroot -p 然后输入密码就可以了。</p>
<p>7.导入数据：source 路径名（路径中不要有中文）//没有分号</p>
<p>8.查看表的所有数据：select     *     from     表名;（*代表所有） </p>
<p>9.查看表的结构：desc     表名;（desc是describe的缩写）</p>
<p>10.查看MYSQL版本号：select version();</p>
<p>11.查看当前使用的数据库：select database();</p>
<p>12.终止命令的输入:\c或者;(英文)（使用；会执行之前写的所有语句，而\c直接结束这条命令的输入，之前的输入无效。</p>
<hr>
<h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><p>DQL:</p>
<p>数据查询语言（凡是带有select关键字的都是查询语句）</p>
<p>select…</p>
<p>DML:</p>
<p>数据操作语言（凡是对表当中的数据进行增删改都是DML）</p>
<p>insert     delete        update </p>
<p>insert增</p>
<p>delete删</p>
<p>update改</p>
<p>DDL:</p>
<p>数据定义语言（凡是带有create，drop，alter的都是DDL）</p>
<p>DDL主要是操作表的结构，不是表中的数据</p>
<p>create：新建</p>
<p>drop：删除</p>
<p>alter：修改</p>
<p>TCL:</p>
<p>事务控制语言</p>
<p>包括：</p>
<p>​    事务提交：commit；</p>
<p>​    事务回滚：rollback；</p>
<p>DCL:</p>
<p>是数据控制语言</p>
<p>例如：授权grant、撤销权限revoke…</p>
<hr>
<h3 id="导入数据-amp-查看表的数据或结构"><a href="#导入数据-amp-查看表的数据或结构" class="headerlink" title="导入数据&amp;查看表的数据或结构"></a>导入数据&amp;查看表的数据或结构</h3><p>首先要有一个sql文件</p>
<p>导入命令：source 路径名（路径中不要有中文）</p>
<p>查看表的数据：select * from 表名;</p>
<p>查看表的结构：desc     表名;（desc是describe的缩写）</p>
<hr>
<h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p>查询字段要注意：    </p>
<p>1.查询一个字段：select  字段名 from 表名;</p>
<p>​                select和from都是关键字。</p>
<p>​                字段名和表名都是标识符。</p>
<p>​            强调：</p>
<p>​                对于SQL语句来说都是通用的，</p>
<p>​                所有的SQL语句以”;”结尾。</p>
<p>​                另外SQL语句不区分大小写。</p>
<p>2.查询两个字段：用逗号“,“隔开；注意要用英文</p>
<p>select  字段名1,字段名2 from 表名;</p>
<p>3.查询所有字段：</p>
<p>​                            方式1：用13.2把 所有字段一个个写上；</p>
<p>​                            方式2：select  * from 表名;</p>
<p>注意：方式2的效率低且可读性差。在实际开发中不建议写，可以自己玩，在dos命令窗口中想快速看一看全表数据可以使用这种方式。</p>
<hr>
<h3 id="给查询的列起别名"><a href="#给查询的列起别名" class="headerlink" title="给查询的列起别名"></a>给查询的列起别名</h3><p>select 列名 as 别名 from 表名；</p>
<p>结论：字段可以参加数学运算</p>
<p>注意：</p>
<p>1.当别名里面没有空格时，可以把as省略，变成空格。select 列名 别名 from 表名；</p>
<p>2.有别名空格时可以用单引号或者双引号（不标准）括起来；//单引号是标准，一般数据库所有字符串都用单引号括起来。</p>
<p>3.别名是中文的时候也要用单引号括起来；</p>
<p>4.注意这里的起别名只是查询显示时，起别名的项变成你改的样子，在数据库里面列名并没有被更改.</p>
<p>select不会改变数据库里面的内容；</p>
<hr>
<h3 id="列参与数学运算"><a href="#列参与数学运算" class="headerlink" title="列参与数学运算"></a>列参与数学运算</h3><p>select 列名*12（数学运算式可以按照要求自己写，这时显示的列名会变成类名乘以12，如果觉得不好看可以用as起别名） from 表名；</p>
<hr>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>查询符合条件的数据。</p>
<p>1.语法格式： </p>
<p>select</p>
<p>​        字段1，字段2，字段3…</p>
<p>from</p>
<p>​        表名</p>
<p>where</p>
<p>​        条件；</p>
<p>2.条件有：</p>
<p>=    等于</p>
<p>&lt;&gt;或！=不等于</p>
<p>&lt;,&gt;大于和小于；&lt;=,&gt;=小于等于和大于等于；</p>
<p>between…and…两个值之间，等同于 &gt;= and &lt;= ；注意：必须遵循左小右大；是闭区间；</p>
<p>is null 为空（is not null 不为空）注：数据库里的null不能用=衡量，只能用is</p>
<p>and并且</p>
<p>or或者</p>
<p>in包含，相当于多个or（not in 不在这个范围之中）//in后面跟的是具体的值，不是区间。例子：num in（800,5000）找出num为800和5000的num，不是找800-5000之间的所有的num。</p>
<p>not  可以取非，主要用在is或in中</p>
<p>like 称为模糊查询，支持%或下划线匹配查找特殊字符入_时会导致歧义，这时候可以使用转义子父来查询。</p>
<p>%匹配任意多个字符</p>
<p>下划线，一个下划线只匹配任意一个字符</p>
<p>注意：条件之间有优先级关系，注意使用括号。</p>
<hr>
<h3 id="查询排序"><a href="#查询排序" class="headerlink" title="查询排序"></a>查询排序</h3><p>格式：</p>
<p>select 列名 from 表名 order by 排序条件列；默认升序查询</p>
<p>select 列名 from 表名 order by 排序条件列 asc；指定升序查询</p>
<p>select 列名 from 表名 order by 排序条件列 desc；指定降序查询</p>
<p>注意：关键字的顺序不能改变</p>
<p>select    …    from    …    where    …    group by     …    order by    …</p>
<p>执行顺序：</p>
<p>第一步    from</p>
<p>第二步    where</p>
<p>第三步    group by</p>
<p>第四步    having（必配合group by使用）</p>
<p>第五步     select</p>
<p>第六步     order by（排序总在最后执行！）</p>
<p>（因为group by 在where后面，而分组函数使用前必须进行分组，所以where子句中不可以使用分组函数）</p>
<p>按多个字段排序：</p>
<p>select 列名 form 表名 order by 排序条件1 排序升降序，排序条件2 排序升降序；</p>
<p>注意：这里的排序主要是按照排序条件1的顺序来排，当两项的排序条件1相同时才使用排序条件2比较排出二者顺序。</p>
<p>按照字段的顺序来排</p>
<p>select 列名 form 表名 order by 列数；（按表中的第二列来排）</p>
<p>不建议使用，因为不健壮，列的顺序很容易发生改变。</p>
<p>注：select后面可以跟某个字段名（看做变量）或者字面量/字面值</p>
<hr>
<h3 id="单行处理函数"><a href="#单行处理函数" class="headerlink" title="单行处理函数"></a>单行处理函数</h3><p>概述：数据处理函数又被称为单行处理函数。</p>
<p>单行处理函数的特点：一个输入对应一个输出。</p>
<p>和单行处理函数对应的是多行处理函数：多个输入对应一个输出。</p>
<p>常见的单行处理函数：</p>
<p>sum()    求和函数</p>
<p>lower()     转换小写</p>
<p>upper()    转换大写</p>
<p>substr()    取子串//起始下标是1select substr(ename,1,1);从第一个字母开始截取，截取的长度为1；</p>
<p>concat()    字符串拼接</p>
<p>length()    取字符串长度</p>
<p>trim()    去除字符串中的空格</p>
<p>str_to_date()     将字符串转换成日期</p>
<p>概述：将字符串varchar转换成date类型，通常使用在insert后面</p>
<p>格式：str_to_date(‘字符串日期’,    ‘日期格式’)</p>
<p>mysql的日期格式（将你写的字符串日期格式里的对应数字换成下面的符号就得到了你的日期格式）</p>
<p>%Y    年</p>
<p>%m    月</p>
<p>%d    日</p>
<p>%h    时</p>
<p>%i    分</p>
<p>%s    秒    </p>
<p>注意：如果你提供的日期格式是%Y-%m-%d，那么就不用str_to_date()了，mysql会自动把字符串转换成date。</p>
<p>date_format(date类型数据,    ‘日期格式’)    格式化日期，date转换成字符串</p>
<p>概述：这个函数通常使用在查询日期方面，设置展示的日期</p>
<p>注意：当你不用date_format(date类型数据,    ‘日期格式’)函数时，select后的date类型数据会自动转换成varchar类型，并且固定展示成’%Y-%m-%d’</p>
<p>format(数字，格式‘$999,999’)    设置千分位</p>
<p>round(num,保留小数位数)    四舍五入//如果是负数就是继续往左边四舍五入个，十，百，千，万。。。</p>
<p>rand()    生成0-1内的随机数</p>
<p>ifnull(数据，代替值)    空处理函数，当数据为NULL时，数据就会被代替值代替//注意在数据库中，只要有NULL参与的数学运算式，其结果就是NULL，但分组函数自动忽略NULL；</p>
<p>case…when…then …when…then …else …end</p>
<p>注：改变表中的数据大小都是在select后面直接写的，不在其他地方写。（但只是改变显示的大小，不改变数据库中真实的数据）</p>
<hr>
<h3 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h3><p>概述：又称多行处理函数，特点是输入多行，输出一个最终结果；</p>
<p>一共有5个：</p>
<p>​    count()    计数</p>
<p>​    sum()    求和</p>
<p>​    avg()    求平均值</p>
<p>​    max()    求最大值</p>
<p>​    min()    求最小值</p>
<p>注:</p>
<p>1.分组函数在使用前必须先对数据进行分组，然后才能使用；如果没有对数据进行分组，就默认整张表是一组。</p>
<p>2.分组函数会自动忽略null；</p>
<p>3.count(具体字段)：表示统计该字段下所有不为NULL的元素的总数</p>
<p>   count(*)：统计表中的总行数（只要有一行数据就count++，并且数据库中不存在一行记录全为null）</p>
<p>4.分组函数不能直接使用在where子句中//解释在上面</p>
<p>5.所有的分组函数可以组合起来使用</p>
<p>​    </p>
<hr>
<h3 id="分组查询-非常重要，五颗星"><a href="#分组查询-非常重要，五颗星" class="headerlink" title="分组查询(非常重要，五颗星)"></a>分组查询(非常重要，五颗星)</h3><p>概述：在实际应用中，需要先进行分组，然后对每一组的数据进行操作。这时候我们需要进行分组查询。</p>
<p>1.格式：</p>
<p>select    …    from    …    group by    …</p>
<p>2.重要结论：</p>
<p>在一条select语句当中，如果有group语句，select后面只能跟：参加分组的字段，以及分组函数。其他的一律不能跟！！！添加其他的没有实际意义而且在其他数据库里面可能会报错。</p>
<p>（mysql语法相对松散，编译时不会报错；oracle里面就会报错）</p>
<p>3.技巧：</p>
<p>1.多个字段合成一个字段来看（多个字段联合分组）</p>
<p>2.使用having 可以对分完组的数据进一步过滤。having不能单独使用，必须配合group by配合。</p>
<p>3.having不能代替where，二者有很大的区别。where的执行顺序在group by前，having执行顺序在group by后，因此分组函数可以在having字句中使用，不可以在where字句中使用。</p>
<p>4.优先策略：where和having，优先使用where，where实在完成不了的再选择having。因为用where筛选后，可以减少分组的工作量，提高运行效率。</p>
<p>执行顺序：</p>
<p>第一步    from</p>
<p>第二步    where</p>
<p>第三步    group by</p>
<p>第四步    having（必配合group by使用）</p>
<p>第五步     select</p>
<p>第六步     order by（排序总在最后执行！）</p>
<p>语言描述：先选择数据库中的某张表，先经过where条件筛选出有价值的数据。对这些有价值的数据进行分组，分组之后可以使用having继续筛选，select查询出来，最后排序输出</p>
<p>书写顺序：</p>
<p>select…    from    …    where    …    group by    …    having    …    order by    …    limit    ….</p>
<hr>
<h3 id="distinct关键字"><a href="#distinct关键字" class="headerlink" title="distinct关键字"></a>distinct关键字</h3><p>概述：查询结果中可能会出现重复的数据，此时需要使用distinct关键字。</p>
<p>注意：distinct关键字只能放在所有字段的最前方，表示去除后面的所有字段的重复数据。</p>
<hr>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>1.概述：从一张表中单独查询，称为单表查询。跨表查询，多张表联合起来查询数据，被称为连接查询。</p>
<p>2.分类：</p>
<p>根据年代分类：SQL92，SQL99（分别是1992年和1999年出现的语法）</p>
<p>根据表的连接方式分类：</p>
<p>内连接：等值连接，非等值连接，自连接。</p>
<p>外连接：左外连接（左连接），右外连接（右连接）</p>
<p>全连接：不讲</p>
<hr>
<h3 id="笛卡尔积现象"><a href="#笛卡尔积现象" class="headerlink" title="笛卡尔积现象"></a>笛卡尔积现象</h3><p>当两张表进行连接查询，没有任何条件限制时候，最终查询的条数，是两张表条数的乘积，这种现象被称为笛卡尔乘积。</p>
<p>避免方法：添加附加的连接条件</p>
<p>给表起别名可以提高匹配效率。</p>
<hr>
<h3 id="内连接之等值连接，非等值连接，自连接"><a href="#内连接之等值连接，非等值连接，自连接" class="headerlink" title="内连接之等值连接，非等值连接，自连接"></a>内连接之等值连接，非等值连接，自连接</h3><p>SQL92语法：select e.ename,d.dname from emp e,dept d where e.deptno=d.deptno;</p>
<p>SQL99语法：select e.ename,d.dname from emp e join dept d on e.deptno=d.deptno;</p>
<p>SQL99 优点:结构更清晰，表的连接条件和后期的where的筛选条件进行了区分。</p>
<p>SQL语法：</p>
<p>select </p>
<p>​    …</p>
<p>from</p>
<p>​    a</p>
<p>inner join    //inner可省略</p>
<p>​    b</p>
<p>on</p>
<p>​    a和b的连接条件//条件是等式就是等值连接，不是等式就是非等值连接，表内的查询就是自连接（一张表看成两张表）</p>
<p>where</p>
<p>​    筛选条件</p>
<p>内连接特点：把完全能够匹配表连接条件的数据查询出来</p>
<hr>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="外连接之右（外）连接"><a href="#外连接之右（外）连接" class="headerlink" title="外连接之右（外）连接"></a>外连接之右（外）连接</h4><p>格式：select 左表.字段1，右表.字段2… from 表A名 right（此处省略outer,写不写都可以） join 表B名 on 表连接条件。</p>
<p>right：表示join关键字右边的表是主表即被匹配表，左表是匹配表，查询出的结果要包含右表中的每一行，意思是把左表中的数据拿来和右表的每一行数据进行匹配，匹配成功就显示出来，若右表中的某一行和左表中的每一行都不匹配，此时左表.字段1显示NULL，右表.字段2正常显示。（若这种情况发生，在内连接时，两个表都不会显示</p>
<h4 id="外连接之左（外）连接"><a href="#外连接之左（外）连接" class="headerlink" title="外连接之左（外）连接"></a>外连接之左（外）连接</h4><p>格式：select 左表.字段1，右表.字段2… from 表A名 left （此处省略outer,写不写都可以）  join 表B名 on 表连接条件。</p>
<p>类比右连接，位置关系相反</p>
<p>注意：</p>
<p>1.在外连接中，表有主次关系，而内连接中没有。</p>
<p>2.左连接和右连接可以相互转换。</p>
<p>3.外连接的查询结果条数一定大于等于内连接的查询结果条数。</p>
<hr>
<h3 id="多张表的连接"><a href="#多张表的连接" class="headerlink" title="多张表的连接"></a>多张表的连接</h3><p>语法：</p>
<p>select …from     a     </p>
<p>join      b     on      a,b连接条件    </p>
<p>join     c    on    a,c连接条件</p>
<p>join    d    on    a,d连接条件；</p>
<p>注意：一条SQL语句中内连接和外连接可以混合使用。</p>
<hr>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>概述：select 语句中嵌套select语句，被嵌套的select语句称为子查询。</p>
<p>位置：</p>
<p>select</p>
<p>..(select ).</p>
<p>from</p>
<p>..(select).</p>
<p>where </p>
<p>..(select ).</p>
<h4 id="where中的子查询"><a href="#where中的子查询" class="headerlink" title="where中的子查询"></a>where中的子查询</h4><p>一般是利用子查询处理分组函数，得到结果当做where的筛选条件</p>
<h4 id="from子句的子查询"><a href="#from子句的子查询" class="headerlink" title="from子句的子查询"></a>from子句的子查询</h4><p>注：from后面的子查询，可以将子查询的查询结果当做临时表</p>
<h4 id="select后的子查询"><a href="#select后的子查询" class="headerlink" title="select后的子查询"></a>select后的子查询</h4><p>就是把where后面的的筛选条件改写到select后面，注意此时子查询一次返回的记录数目只能为1，不然会报错。</p>
<hr>
<h3 id="union合并查询结果集"><a href="#union合并查询结果集" class="headerlink" title="union合并查询结果集"></a>union合并查询结果集</h3><p>union的效率要高一些，对于表的连接来说，没连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。但union可以减少匹配次数，在减少匹配次数的情况下，还可以完成两个结果集的合并。union把乘法变成了加法，减少了连接次数。</p>
<p>格式：</p>
<p>select….(后面省略，是一个完整的查询语句)//注意此处没有分号，语句还没有写完</p>
<p>union</p>
<p>select…(后面省略，是另一个完整的查询语句)；</p>
<p>注意：</p>
<p>1.union在进行结果集合并的时候，要求两个结果的列数相同。</p>
<p>2.合并集合的对应列的数据类型也要一致（在没有mysql里面不会报错，在oracle里面会报错。）</p>
<hr>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>概述：limit是将查询结果集的一部分取出来，通常使用在分页查询之中。分页的作用是为了提高用户体验，一次都提取出来会不方便阅读，limit可以分页查看。</p>
<p>格式：select …  一个完整的查询语句…  limit startIndex，length/num；</p>
<p>解释：</p>
<p>完整用法： limit startIndex，length</p>
<p>startIndex是起始下标最小是0，length是要提取的数量。</p>
<p>缺省用法：limit num</p>
<p>直接提取前num位</p>
<p>注意：mysql中limit在order后执行！！！！！！！！</p>
<h4 id="通用分页"><a href="#通用分页" class="headerlink" title="通用分页"></a>通用分页</h4><p>公式：limit （页数-1）*每页数据条数，每页数据条数；</p>
<hr>
<h3 id="表的创建和删除"><a href="#表的创建和删除" class="headerlink" title="表的创建和删除"></a>表的创建和删除</h3><p>1.概述：建表，删除属于DDL语句，DDL包括create，drop，alter；</p>
<p>2.建表的格式：</p>
<p>create    table    表名（</p>
<p>字段1    数据类型，</p>
<p>字段2    数据类型，</p>
<p>字段3    数据类型）；    </p>
<p>3.表名建议：以    t_    或者    tbl_    开始，可读性强，见名知意。            </p>
<p>4.mysql中的部分常用数据类型：</p>
<p>varchar ：最长255位，可变长度的字符串，根据实际的数据长度动态分配空间，但速度慢。</p>
<p>char：最长255位，定长字符串，不管实际的数据长度是多少，分配固定长度的空间存储数据，速度快，但使用不恰当会导致空间的浪费。</p>
<p>int：最长11位，数字中的整数型，等同于java中的int</p>
<p>bigint：数字中的长整型，等同与java中的long</p>
<p>float：单精度浮点型</p>
<p>double：双精度浮点型</p>
<p>date：短日期类型</p>
<p>datetime：长日期类型</p>
<p>clob：字符大对象，最多可以存储4G的字符串，超过255个字的都要采用这个来存储，全称：Character Large OBject</p>
<p>blob：二进制大对象，全称Binary Large OBject，专门用来存储图片，声音，视频等流媒体数据。往BLOB类型的字段上插入数据的时候，必须采用IO流。</p>
<p>5.删除表:</p>
<p>drop table 表名；//注意当表不存在的时候会报错</p>
<p>另一种种写法：drop     table     if     exists     表名;//防止表不存在</p>
<hr>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>1.格式：insert into 表名（字段1,字段2,字段3…)    values(值1,值2,值3…);</p>
<p>注意：</p>
<p>1.字段名要和值一一对应，即数量和数据类型要对应。这里的字段是创建表的时候指定写好的。不给字段指定值默认NULL。</p>
<p>2.insert语句执行成功一定会多一条记录。</p>
<p>3.建表的时候default可以指定字段不给出的时候的默认值。</p>
<p>4.insert插入记录是从上到下依次插入的</p>
<p>create    table    表名（</p>
<p>字段1    数据类型    default     默认值1，</p>
<p>字段2    数据类型    default     默认值2，</p>
<p>字段3    数据类型    default     默认值3）；    </p>
<p>4.如果insert的字段命都不写就默认是写上了所有的字段名，所有的值都要写上。</p>
<p>insert into 表名    values(值1,值2,值3…);</p>
<p>5.insert语句插入多条记录</p>
<p>insert into 表名（字段1,字段2,字段3…)    values(值1,值2,值3…),    (值4,值5,值6…),    (值7,值8,值9…),    (值10,值11,值12…);</p>
<p>6.将插入结果插入一张表</p>
<p>insert    into    表名    select    要插入的内容;</p>
<p>上面插入了四行数据</p>
<p>数据库中的命名规则：所有的标识符全都小写，单词和单词之间用下划线 _ 分隔开</p>
<hr>
<h3 id="date和datetime区别"><a href="#date和datetime区别" class="headerlink" title="date和datetime区别"></a>date和datetime区别</h3><p>date：短日期，只包括年月日信息</p>
<p>datetime：长日期，包括年月日时分秒信息</p>
<p>mysql短日期默认格式：%Y-%m-%d</p>
<p>mysql长日期默认格式：%Y-%m-%d     %h-%i-%s</p>
<p>now()    获取系统当前时间，并且是长日期的格式。</p>
<hr>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>1.格式：update    表名    set    字段名1=值1，字段名2=值2，字段名3=值3    …    where    条件;</p>
<p>注意：没有条件限制会导致所有数据全部更新。</p>
<hr>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>1.格式：delete    from    表名    where     条件；//删除表所有满足条件的行</p>
<p>2.注意：不加条件会删除所有的数据</p>
<hr>
<h3 id="快速复制表"><a href="#快速复制表" class="headerlink" title="快速复制表"></a>快速复制表</h3><p>create    table    表名1    select     *    from    表名2（已存在）;</p>
<p>这个就是把表2完全复制给表1</p>
<hr>
<h3 id="快速删除表中的数据"><a href="#快速删除表中的数据" class="headerlink" title="快速删除表中的数据"></a>快速删除表中的数据</h3>]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL java后端</tag>
      </tags>
  </entry>
</search>
